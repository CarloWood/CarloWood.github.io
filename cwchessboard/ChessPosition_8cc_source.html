<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html LANG="en_US">

<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="Author" content="Carlo Wood">
<meta name="description" content="cwchessboard version 2.0.9">
<title>cwchessboard: ChessPosition.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="main.css" rel="stylesheet" type="text/css">
</head>

<body>

<div class="normal">
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>ChessPosition.cc</h1>  </div>
</div>
<div class="contents">
<a href="ChessPosition_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// cwchessboard -- A C++ chessboard tool set</span>
<a name="l00002"></a>00002 <span class="comment">//</span><span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">//! @file ChessPosition.cc This file contains the implementation of class ChessPosition.</span>
<a name="l00004"></a>00004 <span class="comment"></span><span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">// Copyright (C) 2008, by</span>
<a name="l00006"></a>00006 <span class="comment">// </span>
<a name="l00007"></a>00007 <span class="comment">// Carlo Wood, Run on IRC &lt;carlo@alinoe.com&gt;</span>
<a name="l00008"></a>00008 <span class="comment">// RSA-1024 0x624ACAD5 1997-01-26                    Sign &amp; Encrypt</span>
<a name="l00009"></a>00009 <span class="comment">// Fingerprint16 = 32 EC A7 B6 AC DB 65 A6  F6 F6 55 DD 1C DC FF 61</span>
<a name="l00010"></a>00010 <span class="comment">// </span>
<a name="l00011"></a>00011 <span class="comment">// This program is free software: you can redistribute it and/or modify</span>
<a name="l00012"></a>00012 <span class="comment">// it under the terms of the GNU General Public License as published by</span>
<a name="l00013"></a>00013 <span class="comment">// the Free Software Foundation, either version 2 of the License, or</span>
<a name="l00014"></a>00014 <span class="comment">// (at your option) any later version.</span>
<a name="l00015"></a>00015 <span class="comment">// </span>
<a name="l00016"></a>00016 <span class="comment">// This program is distributed in the hope that it will be useful,</span>
<a name="l00017"></a>00017 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00018"></a>00018 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00019"></a>00019 <span class="comment">// GNU General Public License for more details.</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">// You should have received a copy of the GNU General Public License</span>
<a name="l00022"></a>00022 <span class="comment">// along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#ifndef USE_PCH</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span><span class="preprocessor">#include &quot;sys.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#endif</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="ChessPosition_8h.html" title="This file contains the declaration of class ChessPosition.">ChessPosition.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="Direction_8h.html" title="This file contains the declaration of class Direction.">Direction.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="ChessNotation_8h.html" title="This file contains the declaration of class ChessNotation.">ChessNotation.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;debug.h&quot;</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="keyword">namespace </span>cwchess {
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="preprocessor">#ifndef DOXYGEN</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>std::string EnPassant::FEN4(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00039"></a>00039 <span class="keyword"></span>{
<a name="l00040"></a>00040   <span class="keywordflow">if</span> (!<a class="code" href="classcwchess_1_1EnPassant.html#a4d2a5402133c3f3c8d001a44786ac02d" title="Return TRUE if the last move was a pawn advancing two squares.">exists</a>())
<a name="l00041"></a>00041     <span class="keywordflow">return</span> <span class="stringliteral">&quot;-&quot;</span>;
<a name="l00042"></a>00042   std::ostringstream fen;
<a name="l00043"></a>00043   Index passed(this-&gt;<a class="code" href="classcwchess_1_1EnPassant.html#a877e86f096b677f19ddd52a55d29a216" title="Return the index of the square that was passed.">index</a>());
<a name="l00044"></a>00044   fen &lt;&lt; (char)(<span class="charliteral">&#39;a&#39;</span> + passed.col()) &lt;&lt; (passed.row() + 1);
<a name="l00045"></a>00045   <span class="keywordflow">return</span> fen.str();
<a name="l00046"></a>00046 }
<a name="l00047"></a>00047 <span class="preprocessor">#endif</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span>
<a name="l00049"></a>00049 <span class="keywordtype">void</span> ChessPosition::clear_en_passant(<span class="keywordtype">void</span>)
<a name="l00050"></a>00050 {
<a name="l00051"></a>00051   Index index = M_en_passant.pawn_index();
<a name="l00052"></a>00052   <span class="keywordflow">if</span> (index &gt; <a class="code" href="namespacecwchess.html#a634e252ff0fea31cef65aba7c78d30da" title="A constant representing the index to square h1.">ih1</a> &amp;&amp; <a class="code" href="classcwchess_1_1ChessPosition.html#a62c4a39daac4305fa8bb5c870fdf109c" title="Return the Piece on the square index.">piece_at</a>(index - 1) == <a class="code" href="namespacecwchess.html#a6c67ba2364b136bfc37bab16576ff289" title="A constant representing a pawn.">pawn</a>)
<a name="l00053"></a>00053     M_pieces[index - 1].reset_can_take_king_side();
<a name="l00054"></a>00054   <span class="keywordflow">if</span> (index &lt; <a class="code" href="namespacecwchess.html#a67d73c47ebd6652d0502cc7499ab5c42" title="A constant representing the index to square a8.">ia8</a> &amp;&amp; <a class="code" href="classcwchess_1_1ChessPosition.html#a62c4a39daac4305fa8bb5c870fdf109c" title="Return the Piece on the square index.">piece_at</a>(index + 1) == <a class="code" href="namespacecwchess.html#a6c67ba2364b136bfc37bab16576ff289" title="A constant representing a pawn.">pawn</a>)
<a name="l00055"></a>00055     M_pieces[index + 1].reset_can_take_queen_side();
<a name="l00056"></a>00056   M_en_passant.clear();
<a name="l00057"></a>00057 }
<a name="l00058"></a>00058 
<a name="l00059"></a><a class="code" href="classcwchess_1_1ChessPosition.html#a49ecca7f847204957b161ff1034a411d">00059</a> <span class="keywordtype">void</span> <a class="code" href="classcwchess_1_1ChessPosition.html#a49ecca7f847204957b161ff1034a411d" title="Clear the board.">ChessPosition::clear</a>(<span class="keywordtype">void</span>)
<a name="l00060"></a>00060 {
<a name="l00061"></a>00061   <span class="keywordflow">for</span> (<a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> index = <a class="code" href="namespacecwchess.html#a5f575bff9af84d4cddda44acd6e6bf0d" title="A constant representing the&amp; #39;first&amp;#39; index.">index_begin</a>; index != <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>; ++index)
<a name="l00062"></a>00062     M_pieces[index].set_type(<a class="code" href="namespacecwchess.html#ada2c41d3cd72288d05e31c3efbd42c12" title="A constant representing the absence of a piece.">nothing</a>);
<a name="l00063"></a>00063   M_en_passant.clear();
<a name="l00064"></a>00064   M_castle_flags.clear();
<a name="l00065"></a>00065   M_half_move_clock = 0;
<a name="l00066"></a>00066   M_full_move_number = 1;
<a name="l00067"></a>00067   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; ++i)
<a name="l00068"></a>00068   {
<a name="l00069"></a>00069     <a class="code" href="structcwchess_1_1CodeData.html" title="The POD base type of class Code.">CodeData</a> data = { i };
<a name="l00070"></a>00070     M_bitboards[data].reset();
<a name="l00071"></a>00071   }
<a name="l00072"></a>00072   M_attackers[<a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>].reset();
<a name="l00073"></a>00073   M_attackers[<a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>].reset();
<a name="l00074"></a>00074   M_pinning[<a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>].reset();
<a name="l00075"></a>00075   M_pinning[<a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>].reset();
<a name="l00076"></a>00076   M_defended[<a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>].reset();
<a name="l00077"></a>00077   M_defended[<a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>].reset();
<a name="l00078"></a>00078   M_king_battery_attack_count[<a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>] = 0;
<a name="l00079"></a>00079   M_king_battery_attack_count[<a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>] = 0;
<a name="l00080"></a>00080   M_double_check = <span class="keyword">false</span>;
<a name="l00081"></a>00081 }
<a name="l00082"></a>00082 
<a name="l00083"></a><a class="code" href="classcwchess_1_1ChessPosition.html#ad8d76a65e0959c2dd2314564223db06b">00083</a> <span class="keywordtype">void</span> <a class="code" href="classcwchess_1_1ChessPosition.html#ad8d76a65e0959c2dd2314564223db06b" title="Set up the initial position.">ChessPosition::initial_position</a>(<span class="keywordtype">void</span>)
<a name="l00084"></a>00084 {
<a name="l00085"></a>00085   <a class="code" href="classcwchess_1_1ChessPosition.html#a49ecca7f847204957b161ff1034a411d" title="Clear the board.">clear</a>();
<a name="l00086"></a>00086   <span class="comment">// It&#39;s white&#39;s turn.</span>
<a name="l00087"></a>00087   M_to_move = <a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>;
<a name="l00088"></a>00088   <span class="comment">// White pawns.</span>
<a name="l00089"></a>00089   <span class="keywordflow">for</span> (<a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> index = <a class="code" href="namespacecwchess.html#ab7871ede7e27efd4a40b80d194c4a53f" title="A constant representing the index to square a2.">ia2</a>; index &lt;= <a class="code" href="namespacecwchess.html#a4080492ec63392226c45157f20e22560" title="A constant representing the index to square h2.">ih2</a>; ++index)
<a name="l00090"></a>00090     <a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">place</a>(<a class="code" href="namespacecwchess.html#acbefae1953a03a417fcf2b5c9e3b55a6" title="A constant representing a white pawn.">white_pawn</a>, index);
<a name="l00091"></a>00091   <span class="comment">// Black pawns.</span>
<a name="l00092"></a>00092   <span class="keywordflow">for</span> (<a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> index = <a class="code" href="namespacecwchess.html#a77d9595b8f4cb1707a30cac0209019a8" title="A constant representing the index to square a7.">ia7</a>; index &lt;= <a class="code" href="namespacecwchess.html#abfde923eca88250adf568264d8cfd8e3" title="A constant representing the index to square h7.">ih7</a>; ++index)
<a name="l00093"></a>00093     <a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">place</a>(<a class="code" href="namespacecwchess.html#acd891cc1843e2bce6978c194647c928a" title="A constant representing a black pawn.">black_pawn</a>, index);
<a name="l00094"></a>00094   <span class="comment">// The other pieces.</span>
<a name="l00095"></a>00095   <a class="code" href="classcwchess_1_1Color.html" title="A color (black or white).">Color</a> color = <a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>;
<a name="l00096"></a>00096   <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> index = <a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a>;
<a name="l00097"></a>00097   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ci = 0; ci &lt; 2; ++ci)
<a name="l00098"></a>00098   {
<a name="l00099"></a>00099     <a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">place</a>(<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(color, <a class="code" href="namespacecwchess.html#a4ff984a16c54b56749db5209e31b29f9" title="A constant representing a rook.">rook</a>), ++index);
<a name="l00100"></a>00100     <a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">place</a>(<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(color, <a class="code" href="namespacecwchess.html#abf2c4ea392fe31bf861f9eb143ca299a" title="A constant representing a knight.">knight</a>), ++index);
<a name="l00101"></a>00101     <a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">place</a>(<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(color, <a class="code" href="namespacecwchess.html#a3f166611f4301dafd492316030d6ecab" title="A constant representing a bishop.">bishop</a>), ++index);
<a name="l00102"></a>00102     <a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">place</a>(<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(color, <a class="code" href="namespacecwchess.html#ad3a2fc51450ffe511826ea0ddc6781ec" title="A constant representing a queen.">queen</a>), ++index);
<a name="l00103"></a>00103     <a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">place</a>(<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(color, <a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>), ++index);
<a name="l00104"></a>00104     <a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">place</a>(<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(color, <a class="code" href="namespacecwchess.html#a3f166611f4301dafd492316030d6ecab" title="A constant representing a bishop.">bishop</a>), ++index);
<a name="l00105"></a>00105     <a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">place</a>(<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(color, <a class="code" href="namespacecwchess.html#abf2c4ea392fe31bf861f9eb143ca299a" title="A constant representing a knight.">knight</a>), ++index);
<a name="l00106"></a>00106     <a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">place</a>(<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(color, <a class="code" href="namespacecwchess.html#a4ff984a16c54b56749db5209e31b29f9" title="A constant representing a rook.">rook</a>), ++index);
<a name="l00107"></a>00107     color = <a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>;
<a name="l00108"></a>00108     index += 48;        <span class="comment">// Skip all pawns and empty squares.</span>
<a name="l00109"></a>00109   }
<a name="l00110"></a>00110 }
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="keywordtype">bool</span> ChessPosition::increment_counters(<span class="keywordtype">bool</span> pawn_advance_or_capture)
<a name="l00113"></a>00113 {
<a name="l00114"></a>00114   <span class="keywordflow">if</span> (pawn_advance_or_capture)
<a name="l00115"></a>00115     M_half_move_clock = 0;
<a name="l00116"></a>00116   <span class="keywordflow">else</span>
<a name="l00117"></a>00117     ++M_half_move_clock;
<a name="l00118"></a>00118   <span class="keywordflow">if</span> (M_to_move == <a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>)
<a name="l00119"></a>00119     ++M_full_move_number;
<a name="l00120"></a>00120   <span class="keywordflow">return</span> M_half_move_clock == 100;
<a name="l00121"></a>00121 }
<a name="l00122"></a>00122 
<a name="l00123"></a><a class="code" href="classcwchess_1_1ChessPosition.html#affde50d177411d6fdf895734565aabc9">00123</a> <span class="keywordtype">bool</span> <a class="code" href="classcwchess_1_1ChessPosition.html#affde50d177411d6fdf895734565aabc9" title="Skip a move.">ChessPosition::skip_move</a>(<span class="keywordtype">void</span>)
<a name="l00124"></a>00124 {
<a name="l00125"></a>00125   reset_en_passant();
<a name="l00126"></a>00126   M_to_move.<a class="code" href="classcwchess_1_1Color.html#a0dac16b632d96296732cbc4f3c2573b4" title="Change the color from black to white or vica versa.">toggle</a>();
<a name="l00127"></a>00127   M_double_check = M_castle_flags.in_check(M_to_move) ? <a class="code" href="classcwchess_1_1ChessPosition.html#a787c6d8859c8e06fe3c95b5464af2ea6" title="Return true if the king of color color is in double check.">double_check</a>(M_to_move) : <span class="keyword">false</span>;
<a name="l00128"></a>00128   <span class="keywordflow">return</span> increment_counters(<span class="keyword">false</span>);
<a name="l00129"></a>00129 }
<a name="l00130"></a>00130 
<a name="l00131"></a><a class="code" href="classcwchess_1_1ChessPosition.html#a56e563951860339501280924d1518a93">00131</a> <span class="keywordtype">void</span> <a class="code" href="classcwchess_1_1ChessPosition.html#ada921b0f214849c994b0cfdc0b2cb908" title="Return whose turn it is.">ChessPosition::to_move</a>(<a class="code" href="classcwchess_1_1Color.html" title="A color (black or white).">Color</a> <span class="keyword">const</span>&amp; color)
<a name="l00132"></a>00132 {
<a name="l00133"></a>00133   M_to_move = color;
<a name="l00134"></a>00134   M_double_check = M_castle_flags.in_check(M_to_move) ? <a class="code" href="classcwchess_1_1ChessPosition.html#a787c6d8859c8e06fe3c95b5464af2ea6" title="Return true if the king of color color is in double check.">double_check</a>(M_to_move) : <span class="keyword">false</span>;
<a name="l00135"></a>00135 }
<a name="l00136"></a>00136 
<a name="l00137"></a><a class="code" href="classcwchess_1_1ChessPosition.html#a62a75079212aebf8d36b9ff4507caa74">00137</a> <span class="keywordtype">void</span> <a class="code" href="classcwchess_1_1ChessPosition.html#a62a75079212aebf8d36b9ff4507caa74" title="Swap colors.">ChessPosition::swap_colors</a>(<span class="keywordtype">void</span>)
<a name="l00138"></a>00138 {
<a name="l00139"></a>00139   <a class="code" href="classcwchess_1_1ChessPosition.html" title="A chess position.">ChessPosition</a> new_chess_position;
<a name="l00140"></a>00140   new_chess_position.<a class="code" href="classcwchess_1_1ChessPosition.html#a49ecca7f847204957b161ff1034a411d" title="Clear the board.">clear</a>();
<a name="l00141"></a>00141   new_chess_position.M_to_move = M_to_move.<a class="code" href="classcwchess_1_1Color.html#ae7b69104c64e17005f5eb3ad277c4bdf" title="Return a Color object with the opposite color of this object.">opposite</a>();
<a name="l00142"></a>00142   <span class="comment">// First place the pawn that can be taken en passant, if any.</span>
<a name="l00143"></a>00143   <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> en_passant_index = <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>;
<a name="l00144"></a>00144   <span class="keywordflow">if</span> (M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#a4d2a5402133c3f3c8d001a44786ac02d" title="Return TRUE if the last move was a pawn advancing two squares.">exists</a>())
<a name="l00145"></a>00145   {
<a name="l00146"></a>00146     <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> index = M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#a9211a09a94a79cddf6030f522c20daae" title="Return the index of the pawn that just advanced two squares.">pawn_index</a>();
<a name="l00147"></a>00147     <a class="code" href="classcwchess_1_1Piece.html" title="A particular piece on the board.">Piece</a>&amp; piece(M_pieces[index]);
<a name="l00148"></a>00148     en_passant_index = <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a>(index.col(), 7 - index.row());
<a name="l00149"></a>00149     new_chess_position.<a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">place</a>(<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(piece.<a class="code" href="classcwchess_1_1Piece.html#a4f0beda5729eff7633ace66348f35ae6" title="Return the color of the piece.">color</a>().<a class="code" href="classcwchess_1_1Color.html#ae7b69104c64e17005f5eb3ad277c4bdf" title="Return a Color object with the opposite color of this object.">opposite</a>(), <a class="code" href="namespacecwchess.html#a6c67ba2364b136bfc37bab16576ff289" title="A constant representing a pawn.">pawn</a>), en_passant_index);
<a name="l00150"></a>00150     new_chess_position.<a class="code" href="classcwchess_1_1ChessPosition.html#aa5893a55201a592bb4e5ff7fa00fdb26" title="Explicity set the en passant information.">set_en_passant</a>(<a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a>(index.col(), 7 - M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#a877e86f096b677f19ddd52a55d29a216" title="Return the index of the square that was passed.">index</a>().<a class="code" href="classcwchess_1_1Index.html#a7ea9520a22986f986f6e9dd818b8ad90" title="Returns the row.">row</a>()));
<a name="l00151"></a>00151   }
<a name="l00152"></a>00152   <span class="comment">// Then place all other pawns (and pieces).</span>
<a name="l00153"></a>00153   <a class="code" href="classcwchess_1_1PieceIterator.html" title="Non-mutable iterator over selective chess pieces in a chess position.">PieceIterator</a> <span class="keyword">const</span> end;
<a name="l00154"></a>00154   <span class="keywordflow">for</span> (<a class="code" href="classcwchess_1_1PieceIterator.html" title="Non-mutable iterator over selective chess pieces in a chess position.">PieceIterator</a> iter(<span class="keyword">this</span>, M_bitboards[<a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>] | M_bitboards[<a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>]); iter != end; ++iter)
<a name="l00155"></a>00155   {
<a name="l00156"></a>00156     <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> index(iter.index().col(), 7 - iter.index().row());
<a name="l00157"></a>00157     <span class="keywordflow">if</span> (index == en_passant_index)
<a name="l00158"></a>00158       <span class="keywordflow">continue</span>;
<a name="l00159"></a>00159     new_chess_position.<a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">place</a>(<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(iter-&gt;color().opposite(), iter-&gt;type()), index);
<a name="l00160"></a>00160   }
<a name="l00161"></a>00161   new_chess_position.M_full_move_number = 1;    <span class="comment">// The history of the game was changed in an unknown way: it is not allowed that black started the game.</span>
<a name="l00162"></a>00162  * <span class="keyword">this</span> = new_chess_position;
<a name="l00163"></a>00163 }
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 <span class="comment">// Called when a piece of color \a color has been removed from (col, row) (possibly replaced</span>
<a name="l00166"></a>00166 <span class="comment">// by a piece of the opposite color). This function updates the pawn flags of influenced</span>
<a name="l00167"></a>00167 <span class="comment">// pawns on the board.</span>
<a name="l00168"></a>00168 <span class="keywordtype">void</span> ChessPosition::update_removed(uint8_t col, uint8_t row, <a class="code" href="classcwchess_1_1Color.html" title="A color (black or white).">Color</a> <span class="keyword">const</span>&amp; color)
<a name="l00169"></a>00169 {
<a name="l00170"></a>00170   <span class="comment">// A piece was removed from (col, row).</span>
<a name="l00171"></a>00171   <span class="comment">// We have to update possible pawns on (col - 1, row +/- 1) and (col + 1, row +/- 1).</span>
<a name="l00172"></a>00172   <span class="keywordtype">bool</span> ok;
<a name="l00173"></a>00173   <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> other_pawn;
<a name="l00174"></a>00174   <span class="keywordflow">if</span> (color == <a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>)
<a name="l00175"></a>00175   {
<a name="l00176"></a>00176     ++row;
<a name="l00177"></a>00177     ok = row &lt;= 6;      <span class="comment">// 6, not 7, because there can&#39;t be black pawns on row 7.</span>
<a name="l00178"></a>00178     other_pawn = <a class="code" href="namespacecwchess.html#acd891cc1843e2bce6978c194647c928a" title="A constant representing a black pawn.">black_pawn</a>;
<a name="l00179"></a>00179   }
<a name="l00180"></a>00180   <span class="keywordflow">else</span>
<a name="l00181"></a>00181   {
<a name="l00182"></a>00182     --row;
<a name="l00183"></a>00183     ok = (int8_t)row &gt;= 1;      <span class="comment">// 1, not 0, because there can&#39;t be white pawns on row 0.</span>
<a name="l00184"></a>00184     other_pawn = <a class="code" href="namespacecwchess.html#acbefae1953a03a417fcf2b5c9e3b55a6" title="A constant representing a white pawn.">white_pawn</a>;
<a name="l00185"></a>00185   }
<a name="l00186"></a>00186   <span class="keywordflow">if</span> (ok)
<a name="l00187"></a>00187   {
<a name="l00188"></a>00188     <span class="keywordflow">if</span> (col &gt; 0)
<a name="l00189"></a>00189     {
<a name="l00190"></a>00190       Index index(col - 1, row);
<a name="l00191"></a>00191       <span class="keywordflow">if</span> (M_pieces[index] == other_pawn)
<a name="l00192"></a>00192         M_pieces[index].reset_can_take_king_side();
<a name="l00193"></a>00193     }
<a name="l00194"></a>00194     <span class="keywordflow">if</span> (col &lt; 7)
<a name="l00195"></a>00195     {
<a name="l00196"></a>00196       Index index(col + 1, row);
<a name="l00197"></a>00197       <span class="keywordflow">if</span> (M_pieces[index] == other_pawn)
<a name="l00198"></a>00198         M_pieces[index].reset_can_take_queen_side();
<a name="l00199"></a>00199     }
<a name="l00200"></a>00200   }
<a name="l00201"></a>00201 }
<a name="l00202"></a>00202 
<a name="l00203"></a>00203 <span class="comment">// Called when a piece of color \a color has been placed at (col, row) (possibly replacing</span>
<a name="l00204"></a>00204 <span class="comment">// a piece of the opposite color). This function updates the pawn flags of influenced</span>
<a name="l00205"></a>00205 <span class="comment">// pawns on the board.</span>
<a name="l00206"></a>00206 <span class="keywordtype">void</span> ChessPosition::update_placed(uint8_t col, uint8_t row, Color <span class="keyword">const</span>&amp; color)
<a name="l00207"></a>00207 {
<a name="l00208"></a>00208   <span class="comment">// A piece was placed at (col, row).</span>
<a name="l00209"></a>00209   <span class="comment">// We have to update possible pawns on (col - 1, row +/- 1) and (col + 1, row +/- 1).</span>
<a name="l00210"></a>00210   <span class="keywordtype">bool</span> ok;
<a name="l00211"></a>00211   Code other_pawn;
<a name="l00212"></a>00212   <span class="keywordflow">if</span> (color == <a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>)
<a name="l00213"></a>00213   {
<a name="l00214"></a>00214     ++row;
<a name="l00215"></a>00215     ok = row &lt;= 6;      <span class="comment">// 6, not 7, because there can&#39;t be black pawns on row 7.</span>
<a name="l00216"></a>00216     other_pawn = <a class="code" href="namespacecwchess.html#acd891cc1843e2bce6978c194647c928a" title="A constant representing a black pawn.">black_pawn</a>;
<a name="l00217"></a>00217   }
<a name="l00218"></a>00218   <span class="keywordflow">else</span>
<a name="l00219"></a>00219   {
<a name="l00220"></a>00220     --row;
<a name="l00221"></a>00221     ok = (int8_t)row &gt;= 1;      <span class="comment">// 1, not 0, because there can&#39;t be white pawns on row 0.</span>
<a name="l00222"></a>00222     other_pawn = <a class="code" href="namespacecwchess.html#acbefae1953a03a417fcf2b5c9e3b55a6" title="A constant representing a white pawn.">white_pawn</a>;
<a name="l00223"></a>00223   }
<a name="l00224"></a>00224   <span class="keywordflow">if</span> (ok)
<a name="l00225"></a>00225   {
<a name="l00226"></a>00226     <span class="keywordflow">if</span> (col &gt; 0)
<a name="l00227"></a>00227     {
<a name="l00228"></a>00228       Index index(col - 1, row);
<a name="l00229"></a>00229       <span class="keywordflow">if</span> (M_pieces[index] == other_pawn)
<a name="l00230"></a>00230         M_pieces[index].set_can_take_king_side();
<a name="l00231"></a>00231     }
<a name="l00232"></a>00232     <span class="keywordflow">if</span> (col &lt; 7)
<a name="l00233"></a>00233     {
<a name="l00234"></a>00234       Index index(col + 1, row);
<a name="l00235"></a>00235       <span class="keywordflow">if</span> (M_pieces[index] == other_pawn)
<a name="l00236"></a>00236         M_pieces[index].set_can_take_queen_side();
<a name="l00237"></a>00237     }
<a name="l00238"></a>00238   }
<a name="l00239"></a>00239 }
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 <span class="comment">// This function recalculates M_pinning for the color of code (a black_king or white_king).</span>
<a name="l00242"></a>00242 <span class="comment">//</span>
<a name="l00243"></a>00243 <span class="comment">// @param code : The code of the king.</span>
<a name="l00244"></a>00244 <span class="comment">// @param index : The index of the king.</span>
<a name="l00245"></a>00245 <span class="comment">// @param mask : The position of the king.</span>
<a name="l00246"></a>00246 <span class="comment">// @param direction : The direction from the king towards the attacker.</span>
<a name="l00247"></a>00247 <span class="comment">// @param relevant_pieces : All pieces along that line (possibly cut off at the last attacker).</span>
<a name="l00248"></a>00248 <span class="comment">//</span>
<a name="l00249"></a>00249 <span class="keywordtype">void</span> ChessPosition::update_pinning(Code <span class="keyword">const</span>&amp; code, Index <span class="keyword">const</span>&amp; index, mask_t mask, <a class="code" href="structDirection.html">Direction</a> <span class="keyword">const</span>&amp; direction, BitBoard <span class="keyword">const</span>&amp; relevant_pieces)
<a name="l00250"></a>00250 {
<a name="l00251"></a>00251   <span class="keywordtype">bool</span> king_side_is_msb = (relevant_pieces() &lt; mask);   <span class="comment">// This means that the most significant bit is on the side of the king.</span>
<a name="l00252"></a>00252   <span class="comment">// Run over all pieces, starting at the side of the king.</span>
<a name="l00253"></a>00253   PieceIterator piece_iter = king_side_is_msb ? PieceIterator(<span class="keyword">this</span>, relevant_pieces, 0) : PieceIterator(this, relevant_pieces);
<a name="l00254"></a>00254   PieceIterator end = king_side_is_msb ? PieceIterator(0) : PieceIterator();
<a name="l00255"></a>00255   Code first_piece_code;
<a name="l00256"></a>00256   Index first_piece_index;
<a name="l00257"></a>00257   <span class="keywordtype">bool</span> found_first_piece = <span class="keyword">false</span>;
<a name="l00258"></a>00258   <span class="keywordtype">bool</span> taking_en_passant_not_allowed = <span class="keyword">false</span>;
<a name="l00259"></a>00259   <span class="keywordflow">while</span> (piece_iter != end)
<a name="l00260"></a>00260   {
<a name="l00261"></a>00261     <span class="keywordflow">if</span> (found_first_piece)
<a name="l00262"></a>00262     {
<a name="l00263"></a>00263       Code second_piece_code = piece_iter-&gt;code();
<a name="l00264"></a>00264       <span class="keywordflow">if</span> (!second_piece_code.has_opposite_color_of(code))
<a name="l00265"></a>00265         <span class="keywordflow">break</span>;
<a name="l00266"></a>00266       <span class="keywordflow">else</span>
<a name="l00267"></a>00267       {
<a name="l00268"></a>00268         <span class="keywordflow">if</span> (second_piece_code.moves_along(direction))
<a name="l00269"></a>00269         {
<a name="l00270"></a>00270           <span class="keywordflow">if</span> (taking_en_passant_not_allowed)
<a name="l00271"></a>00271             M_en_passant.pinned_set();          <span class="comment">// Disallow taking en passant.</span>
<a name="l00272"></a>00272           <span class="keywordflow">else</span>
<a name="l00273"></a>00273             M_pinning[code.color()] |= squares_from_to(piece_iter.index(), index);
<a name="l00274"></a>00274           <span class="keywordflow">break</span>;
<a name="l00275"></a>00275         }
<a name="l00276"></a>00276         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (M_en_passant.exists() &amp;&amp; M_en_passant.pawn_index() == piece_iter.index() &amp;&amp; first_piece_code.is_a(<a class="code" href="namespacecwchess.html#a6c67ba2364b136bfc37bab16576ff289" title="A constant representing a pawn.">pawn</a>)&amp;&amp; 
<a name="l00277"></a>00277             direction.is_horizontal() &amp;&amp; M_en_passant.pawn_index() - direction == first_piece_index&amp;&amp; 
<a name="l00278"></a>00278             first_piece_code.has_opposite_color_of(second_piece_code))
<a name="l00279"></a>00279           taking_en_passant_not_allowed = <span class="keyword">true</span>;
<a name="l00280"></a>00280         <span class="keywordflow">else</span>
<a name="l00281"></a>00281           <span class="keywordflow">break</span>;
<a name="l00282"></a>00282       }
<a name="l00283"></a>00283     } 
<a name="l00284"></a>00284     <span class="keywordflow">else</span>
<a name="l00285"></a>00285     {
<a name="l00286"></a>00286       first_piece_code = piece_iter-&gt;code();
<a name="l00287"></a>00287       first_piece_index = piece_iter.index();
<a name="l00288"></a>00288       <span class="keywordflow">if</span> (first_piece_code.has_opposite_color_of(code))
<a name="l00289"></a>00289       {
<a name="l00290"></a>00290         <span class="keywordflow">if</span> (!M_en_passant.exists() || M_en_passant.pawn_index() != first_piece_index || !direction.is_horizontal())
<a name="l00291"></a>00291           <span class="keywordflow">break</span>;        <span class="comment">// Nothing is pinned (though we might be in check).</span>
<a name="l00292"></a>00292         <span class="keywordflow">else</span>
<a name="l00293"></a>00293         {
<a name="l00294"></a>00294           <span class="comment">// This handles a very special case.</span>
<a name="l00295"></a>00295           taking_en_passant_not_allowed = <span class="keyword">true</span>;
<a name="l00296"></a>00296         }
<a name="l00297"></a>00297       }
<a name="l00298"></a>00298       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (taking_en_passant_not_allowed&amp;&amp; 
<a name="l00299"></a>00299           (!first_piece_code.is_a(<a class="code" href="namespacecwchess.html#a6c67ba2364b136bfc37bab16576ff289" title="A constant representing a pawn.">pawn</a>) || first_piece_index - direction != M_en_passant.pawn_index()))
<a name="l00300"></a>00300         <span class="keywordflow">break</span>;  <span class="comment">// Also special case does not apply.</span>
<a name="l00301"></a>00301       <span class="keywordflow">else</span>
<a name="l00302"></a>00302         found_first_piece = <span class="keyword">true</span>;
<a name="l00303"></a>00303     }
<a name="l00304"></a>00304     <span class="keywordflow">if</span> (king_side_is_msb)
<a name="l00305"></a>00305     {
<a name="l00306"></a>00306       <span class="keywordflow">if</span> (piece_iter.index() == <a class="code" href="namespacecwchess.html#a5dd35023ca8c8cfaed9d55de308b607c" title="A constant representing the index to square a1.">ia1</a>)    <span class="comment">// We are not allowed to call --piece_iter if we&#39;re already at square a1.</span>
<a name="l00307"></a>00307         <span class="keywordflow">break</span>;
<a name="l00308"></a>00308       --piece_iter;
<a name="l00309"></a>00309     }
<a name="l00310"></a>00310     <span class="keywordflow">else</span>
<a name="l00311"></a>00311       ++piece_iter;
<a name="l00312"></a>00312   }
<a name="l00313"></a>00313 }
<a name="l00314"></a>00314 
<a name="l00315"></a>00315 <span class="comment">// This function updates M_pieces and M_bitboards.</span>
<a name="l00316"></a><a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a">00316</a> <span class="keywordtype">bool</span> <a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">ChessPosition::place</a>(<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> <span class="keyword">const</span>&amp; code, <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> <span class="keyword">const</span>&amp; index)
<a name="l00317"></a>00317 {
<a name="l00318"></a>00318   DoutEntering(dc::place, <span class="stringliteral">&quot;ChessPosition::place(&quot;</span> &lt;&lt; code &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; index &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>);
<a name="l00319"></a>00319 
<a name="l00320"></a>00320   <span class="comment">// Refuse to place pawns on row 1 or 8.</span>
<a name="l00321"></a>00321   <span class="keywordflow">if</span> (code.<a class="code" href="classcwchess_1_1Code.html#a7e9e51ca2eb4c4fb0147e2373ec7dfcb" title="Returns TRUE if the type is equal.">is_a</a>(<a class="code" href="namespacecwchess.html#a6c67ba2364b136bfc37bab16576ff289" title="A constant representing a pawn.">pawn</a>))
<a name="l00322"></a>00322   {
<a name="l00323"></a>00323     <span class="keywordtype">int</span> row = index.<a class="code" href="classcwchess_1_1Index.html#a7ea9520a22986f986f6e9dd818b8ad90" title="Returns the row.">row</a>();
<a name="l00324"></a>00324     <span class="keywordflow">if</span> (row == 0 || row == 7)
<a name="l00325"></a>00325       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00326"></a>00326   }
<a name="l00327"></a>00327   <span class="comment">// Refuse to place two kings of the same color on the board.</span>
<a name="l00328"></a>00328   <span class="keywordflow">if</span> (code.<a class="code" href="classcwchess_1_1Code.html#a7e9e51ca2eb4c4fb0147e2373ec7dfcb" title="Returns TRUE if the type is equal.">is_a</a>(<a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>) &amp;&amp; M_bitboards[code].test())
<a name="l00329"></a>00329     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00330"></a>00330 
<a name="l00331"></a>00331   <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> <span class="keyword">const</span> old_code = M_pieces[index].code();         <span class="comment">// The current piece that is on this square, if any.</span>
<a name="l00332"></a>00332 
<a name="l00333"></a>00333   <span class="comment">// Do nothing if we replace a piece with the same piece.</span>
<a name="l00334"></a>00334   <span class="comment">// This test is actually only effective if we&#39;re replacing a pawn that can be taken</span>
<a name="l00335"></a>00335   <span class="comment">// en passant with a pawn of the same color; in which case this causes the en passant</span>
<a name="l00336"></a>00336   <span class="comment">// state to be preserved.</span>
<a name="l00337"></a>00337   <span class="keywordflow">if</span> (old_code == code)
<a name="l00338"></a>00338     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00339"></a>00339 
<a name="l00340"></a>00340   <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> <span class="keyword">const</span> mask(<a class="code" href="namespacecwchess.html#a61b5311c7bc3b89a4c252d76dcfdbd40" title="Convert Index to a mask_t.">index2mask</a>(index));                 <span class="comment">// Calculate the bitboard mask.</span>
<a name="l00341"></a>00341   <span class="keywordtype">int</span> index_row = index.<a class="code" href="classcwchess_1_1Index.html#a7ea9520a22986f986f6e9dd818b8ad90" title="Returns the row.">row</a>();                          <span class="comment">// Cache the row of the square involved.</span>
<a name="l00342"></a>00342 
<a name="l00343"></a>00343   <span class="keywordflow">if</span> (!old_code.<a class="code" href="classcwchess_1_1Code.html#ac9bd2b012eda487a8dea719dfae925d3" title="Returns TRUE if the code represents&amp; #39;nothing&amp;#39;.">is_nothing</a>())
<a name="l00344"></a>00344   {
<a name="l00345"></a>00345     <span class="comment">// Update administration regarding removal of a piece.</span>
<a name="l00346"></a>00346     M_bitboards[old_code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>()].reset(mask);
<a name="l00347"></a>00347     M_bitboards[old_code].reset(mask);
<a name="l00348"></a>00348 
<a name="l00349"></a>00349     <span class="comment">// Update castling flags.</span>
<a name="l00350"></a>00350     M_castle_flags.update_removed(old_code, index);
<a name="l00351"></a>00351 
<a name="l00352"></a>00352     <span class="comment">// Update can_take_king/queen_side flags.</span>
<a name="l00353"></a>00353     <span class="keywordflow">if</span> (code.<a class="code" href="classcwchess_1_1Code.html#ac9bd2b012eda487a8dea719dfae925d3" title="Returns TRUE if the code represents&amp; #39;nothing&amp;#39;.">is_nothing</a>() || code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>() != old_code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>())
<a name="l00354"></a>00354       update_removed(index.<a class="code" href="classcwchess_1_1Index.html#aeeeece4a4238c83b806ea83a45db322c" title="Returns the column.">col</a>(), index_row, old_code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>());
<a name="l00355"></a>00355 
<a name="l00356"></a>00356     <span class="comment">// Update can_take_king/queen_side flags for pawns &#39;taking&#39; the en_passant pawn, if any.</span>
<a name="l00357"></a>00357     <span class="keywordflow">if</span> (
<a name="l00358"></a>00358 #<span class="keywordflow">if</span> DEBUG_ENPASSANT_EXISTS
<a name="l00359"></a>00359         M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#a4d2a5402133c3f3c8d001a44786ac02d" title="Return TRUE if the last move was a pawn advancing two squares.">exists</a>() &amp;&amp;                <span class="comment">// This check is normally not needed because if M_en_passant.M_bits == 64,</span>
<a name="l00360"></a>00360                                                 <span class="comment">// then M_en_passant.pawn_index() returns 72, so the test will fail anyway.</span>
<a name="l00361"></a>00361 <span class="preprocessor">#endif</span>
<a name="l00362"></a>00362 <span class="preprocessor"></span>        M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#a9211a09a94a79cddf6030f522c20daae" title="Return the index of the pawn that just advanced two squares.">pawn_index</a>() == index)
<a name="l00363"></a>00363       clear_en_passant();       <span class="comment">// The pawn that could be taken en passant was removed.</span>
<a name="l00364"></a>00364 
<a name="l00365"></a>00365     <span class="comment">// Update is_blocked flag for pawns.</span>
<a name="l00366"></a>00366     <span class="keywordflow">if</span> (code.<a class="code" href="classcwchess_1_1Code.html#ac9bd2b012eda487a8dea719dfae925d3" title="Returns TRUE if the code represents&amp; #39;nothing&amp;#39;.">is_nothing</a>())
<a name="l00367"></a>00367     {
<a name="l00368"></a>00368       <span class="keywordflow">if</span> (index_row &gt; 1 &amp;&amp; M_pieces[index - 8] == <a class="code" href="namespacecwchess.html#acbefae1953a03a417fcf2b5c9e3b55a6" title="A constant representing a white pawn.">white_pawn</a>)
<a name="l00369"></a>00369       {
<a name="l00370"></a>00370         M_pieces[index - 8].set_is_not_blocked();
<a name="l00371"></a>00371         <span class="keywordflow">if</span> (index_row == 2 &amp;&amp; M_pieces[index + 8] == <a class="code" href="namespacecwchess.html#ada2c41d3cd72288d05e31c3efbd42c12" title="A constant representing the absence of a piece.">nothing</a>)
<a name="l00372"></a>00372             M_pieces[index - 8].set_can_move_two_squares();
<a name="l00373"></a>00373       }
<a name="l00374"></a>00374       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (index_row == 3 &amp;&amp; M_pieces[index - 16] == <a class="code" href="namespacecwchess.html#acbefae1953a03a417fcf2b5c9e3b55a6" title="A constant representing a white pawn.">white_pawn</a>)
<a name="l00375"></a>00375         M_pieces[index - 16].set_can_move_two_squares_if_not_blocked();
<a name="l00376"></a>00376       <span class="keywordflow">if</span> (index_row &lt; 6 &amp;&amp; M_pieces[index + 8] == <a class="code" href="namespacecwchess.html#acd891cc1843e2bce6978c194647c928a" title="A constant representing a black pawn.">black_pawn</a>)
<a name="l00377"></a>00377       {
<a name="l00378"></a>00378         M_pieces[index + 8].set_is_not_blocked();
<a name="l00379"></a>00379         <span class="keywordflow">if</span> (index_row == 5 &amp;&amp; M_pieces[index - 8] == <a class="code" href="namespacecwchess.html#ada2c41d3cd72288d05e31c3efbd42c12" title="A constant representing the absence of a piece.">nothing</a>)
<a name="l00380"></a>00380             M_pieces[index + 8].set_can_move_two_squares();
<a name="l00381"></a>00381       }
<a name="l00382"></a>00382       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (index_row == 4 &amp;&amp; M_pieces[index + 16] == <a class="code" href="namespacecwchess.html#acd891cc1843e2bce6978c194647c928a" title="A constant representing a black pawn.">black_pawn</a>)
<a name="l00383"></a>00383         M_pieces[index + 16].set_can_move_two_squares_if_not_blocked();
<a name="l00384"></a>00384     }
<a name="l00385"></a>00385 
<a name="l00386"></a>00386     <span class="comment">// Reset all pinning flags if piece being removed is a king.</span>
<a name="l00387"></a>00387     <span class="keywordflow">if</span> (old_code.<a class="code" href="classcwchess_1_1Code.html#a7e9e51ca2eb4c4fb0147e2373ec7dfcb" title="Returns TRUE if the type is equal.">is_a</a>(<a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>))
<a name="l00388"></a>00388     {
<a name="l00389"></a>00389       M_attackers[old_code].reset();
<a name="l00390"></a>00390       M_pinning[old_code].reset();
<a name="l00391"></a>00391       M_en_passant.pinned_reset();
<a name="l00392"></a>00392       M_king_battery_attack_count[old_code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>().<a class="code" href="classcwchess_1_1Color.html#ae7b69104c64e17005f5eb3ad277c4bdf" title="Return a Color object with the opposite color of this object.">opposite</a>()] = 0;
<a name="l00393"></a>00393     }
<a name="l00394"></a>00394 
<a name="l00395"></a>00395     <span class="comment">// Update the M_defended CountBoard.</span>
<a name="l00396"></a>00396     <span class="keywordtype">bool</span> battery = <span class="keyword">false</span>;
<a name="l00397"></a>00397     M_defended[old_code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>()].sub(<a class="code" href="classcwchess_1_1ChessPosition.html#adb1463cd7c4aacd46fe836793ccfa1be" title="Return a BitBoard with bits set for each square that a piece defends, or would defend if an exchange ...">defendables</a>(old_code, index, battery));
<a name="l00398"></a>00398     <span class="keywordflow">if</span> (battery)
<a name="l00399"></a>00399       --M_king_battery_attack_count[old_code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>()];
<a name="l00400"></a>00400     update_blocked_defendables(old_code, index, <span class="keyword">true</span>);
<a name="l00401"></a>00401   }
<a name="l00402"></a>00402 
<a name="l00403"></a>00403   <span class="keywordflow">if</span> (!code.<a class="code" href="classcwchess_1_1Code.html#ac9bd2b012eda487a8dea719dfae925d3" title="Returns TRUE if the code represents&amp; #39;nothing&amp;#39;.">is_nothing</a>())
<a name="l00404"></a>00404   {
<a name="l00405"></a>00405     <span class="comment">// Update administration regarding adding of a piece.</span>
<a name="l00406"></a>00406     M_bitboards[code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>()].set(mask);
<a name="l00407"></a>00407     M_bitboards[code].set(mask);
<a name="l00408"></a>00408 
<a name="l00409"></a>00409     <span class="comment">// Update castling flags.</span>
<a name="l00410"></a>00410     M_castle_flags.update_placed(code, index);
<a name="l00411"></a>00411 
<a name="l00412"></a>00412     <span class="comment">// Clear the right of taking en passant if a piece is placed behind the en passant pawn.</span>
<a name="l00413"></a>00413     <span class="keywordflow">if</span> (M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#a4d2a5402133c3f3c8d001a44786ac02d" title="Return TRUE if the last move was a pawn advancing two squares.">exists</a>() &amp;&amp; (index == M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#a877e86f096b677f19ddd52a55d29a216" title="Return the index of the square that was passed.">index</a>() || index == M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#aec896b8159bb5b79883dff78e50d3b1e" title="Return the index of the square that pawn came from.">from_index</a>()))
<a name="l00414"></a>00414       clear_en_passant();
<a name="l00415"></a>00415 
<a name="l00416"></a>00416     <span class="comment">// Update can_take_king/queen_side flags.</span>
<a name="l00417"></a>00417     <span class="keywordflow">if</span> (old_code.<a class="code" href="classcwchess_1_1Code.html#ac9bd2b012eda487a8dea719dfae925d3" title="Returns TRUE if the code represents&amp; #39;nothing&amp;#39;.">is_nothing</a>() || code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>() != old_code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>())
<a name="l00418"></a>00418       update_placed(index.<a class="code" href="classcwchess_1_1Index.html#aeeeece4a4238c83b806ea83a45db322c" title="Returns the column.">col</a>(), index_row, code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>());
<a name="l00419"></a>00419 
<a name="l00420"></a>00420     <span class="comment">// Update is_blocked flag for pawns.</span>
<a name="l00421"></a>00421     <span class="keywordflow">if</span> (old_code.<a class="code" href="classcwchess_1_1Code.html#ac9bd2b012eda487a8dea719dfae925d3" title="Returns TRUE if the code represents&amp; #39;nothing&amp;#39;.">is_nothing</a>())
<a name="l00422"></a>00422     {
<a name="l00423"></a>00423       <span class="keywordflow">if</span> (index_row &gt; 1 &amp;&amp; M_pieces[index - 8] == <a class="code" href="namespacecwchess.html#acbefae1953a03a417fcf2b5c9e3b55a6" title="A constant representing a white pawn.">white_pawn</a>)
<a name="l00424"></a>00424         M_pieces[index - 8].reset_is_not_blocked();
<a name="l00425"></a>00425       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (index_row == 3 &amp;&amp; M_pieces[index - 16] == <a class="code" href="namespacecwchess.html#acbefae1953a03a417fcf2b5c9e3b55a6" title="A constant representing a white pawn.">white_pawn</a>)
<a name="l00426"></a>00426         M_pieces[index - 16].reset_can_move_two_squares();
<a name="l00427"></a>00427       <span class="keywordflow">if</span> (index_row &lt; 6 &amp;&amp; M_pieces[index + 8] == <a class="code" href="namespacecwchess.html#acd891cc1843e2bce6978c194647c928a" title="A constant representing a black pawn.">black_pawn</a>)
<a name="l00428"></a>00428         M_pieces[index + 8].reset_is_not_blocked();
<a name="l00429"></a>00429       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (index_row == 4 &amp;&amp; M_pieces[index + 16] == <a class="code" href="namespacecwchess.html#acd891cc1843e2bce6978c194647c928a" title="A constant representing a black pawn.">black_pawn</a>)
<a name="l00430"></a>00430         M_pieces[index + 16].reset_can_move_two_squares();
<a name="l00431"></a>00431     }
<a name="l00432"></a>00432 
<a name="l00433"></a>00433     <span class="comment">// Update pinning flags if a king is being placed on the board.</span>
<a name="l00434"></a>00434     <span class="keywordflow">if</span> (code.<a class="code" href="classcwchess_1_1Code.html#a7e9e51ca2eb4c4fb0147e2373ec7dfcb" title="Returns TRUE if the type is equal.">is_a</a>(<a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>))
<a name="l00435"></a>00435     {
<a name="l00436"></a>00436       <span class="comment">// Set bishop_code, rook_code and queen_code to the code of respective pieces of the opposite color.</span>
<a name="l00437"></a>00437       <a class="code" href="classcwchess_1_1Color.html" title="A color (black or white).">Color</a> color(code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>());
<a name="l00438"></a>00438       color.toggle();
<a name="l00439"></a>00439       <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> bishop_code(color, <a class="code" href="namespacecwchess.html#a3f166611f4301dafd492316030d6ecab" title="A constant representing a bishop.">bishop</a>);
<a name="l00440"></a>00440       <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> rook_code(color, <a class="code" href="namespacecwchess.html#a4ff984a16c54b56749db5209e31b29f9" title="A constant representing a rook.">rook</a>);
<a name="l00441"></a>00441       <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> queen_code(color, <a class="code" href="namespacecwchess.html#ad3a2fc51450ffe511826ea0ddc6781ec" title="A constant representing a queen.">queen</a>);
<a name="l00442"></a>00442       <span class="comment">// Find all rook movers on the same line as this king.</span>
<a name="l00443"></a>00443       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> rook_attackers(candidates_table[<a class="code" href="classcwchess_1_1ChessPosition.html#a3a4bfb81ed0560b839522ccda16476d9" title="Return the offset into the candidates_table for type type.">candidates_table_offset</a>(<a class="code" href="namespacecwchess.html#a4ff984a16c54b56749db5209e31b29f9" title="A constant representing a rook.">rook</a>) + index()]);
<a name="l00444"></a>00444       rook_attackers&amp; = M_bitboards[rook_code] | M_bitboards[queen_code];
<a name="l00445"></a>00445       <span class="comment">// Find all bishop movers on the same line as this king.</span>
<a name="l00446"></a>00446       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> bishop_attackers(candidates_table[<a class="code" href="classcwchess_1_1ChessPosition.html#a3a4bfb81ed0560b839522ccda16476d9" title="Return the offset into the candidates_table for type type.">candidates_table_offset</a>(<a class="code" href="namespacecwchess.html#a3f166611f4301dafd492316030d6ecab" title="A constant representing a bishop.">bishop</a>) + index()]);
<a name="l00447"></a>00447       bishop_attackers&amp; = M_bitboards[bishop_code] | M_bitboards[queen_code];
<a name="l00448"></a>00448       <span class="comment">// Finally fill M_attackers with all squares between king and attacking pieces (inclusive).</span>
<a name="l00449"></a>00449       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> attackers(CW_MASK_T_CONST(0));
<a name="l00450"></a>00450       <span class="keywordflow">for</span> (PieceIterator piece_iter(<span class="keyword">this</span>, rook_attackers); piece_iter != <a class="code" href="classcwchess_1_1ChessPosition.html#ae3c2f52411c85422dff0d0689cd7249a" title="Return an iterator one beyond the last piece.">piece_end</a>(); ++piece_iter)
<a name="l00451"></a>00451         attackers |= squares_from_to(piece_iter.index(), index);
<a name="l00452"></a>00452       <span class="keywordflow">for</span> (PieceIterator piece_iter(<span class="keyword">this</span>, bishop_attackers); piece_iter != <a class="code" href="classcwchess_1_1ChessPosition.html#ae3c2f52411c85422dff0d0689cd7249a" title="Return an iterator one beyond the last piece.">piece_end</a>(); ++piece_iter)
<a name="l00453"></a>00453         attackers |= squares_from_to(piece_iter.index(), index);
<a name="l00454"></a>00454       M_attackers[code] = attackers;
<a name="l00455"></a>00455       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> <span class="keyword">const</span> all_pieces(M_bitboards[<a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>] | M_bitboards[<a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>]);
<a name="l00456"></a>00456       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> possible_pinning_directions(candidates_table[<a class="code" href="classcwchess_1_1ChessPosition.html#a3a4bfb81ed0560b839522ccda16476d9" title="Return the offset into the candidates_table for type type.">candidates_table_offset</a>(<a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>) + index()]);  <span class="comment">// All squares around the king.</span>
<a name="l00457"></a>00457       possible_pinning_directions&amp; = attackers;                         <span class="comment">// Only those squares in the direction of attackers.</span>
<a name="l00458"></a>00458       <span class="keywordflow">for</span> (PieceIterator direction_iter(<span class="keyword">this</span>, possible_pinning_directions); direction_iter != <a class="code" href="classcwchess_1_1ChessPosition.html#ae3c2f52411c85422dff0d0689cd7249a" title="Return an iterator one beyond the last piece.">piece_end</a>(); ++direction_iter)
<a name="l00459"></a>00459       {
<a name="l00460"></a>00460         <a class="code" href="structcwchess_1_1Direction.html">Direction</a> direction(direction_from_to(index, direction_iter.index()));  <span class="comment">// Run over all directions in which there are attackers.</span>
<a name="l00461"></a>00461         <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> relevant_pieces(all_pieces);                                   <span class="comment">// Only the pieces.</span>
<a name="l00462"></a>00462         relevant_pieces&amp; = direction.<a class="code" href="structcwchess_1_1Direction.html#ac774c9ba1cc29045849a85fd7fdd89f8" title="Return a BitBoard with all squares in this direction.">from</a>(index);                               <span class="comment">// On the line towards the attacker.</span>
<a name="l00463"></a>00463         update_pinning(code, index, mask, direction, relevant_pieces);
<a name="l00464"></a>00464       }
<a name="l00465"></a>00465     }
<a name="l00466"></a>00466 
<a name="l00467"></a>00467     <span class="comment">// Update the M_defended CountBoard.</span>
<a name="l00468"></a>00468     <span class="keywordtype">bool</span> battery = <span class="keyword">false</span>;
<a name="l00469"></a>00469     M_defended[code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>()].add(<a class="code" href="classcwchess_1_1ChessPosition.html#adb1463cd7c4aacd46fe836793ccfa1be" title="Return a BitBoard with bits set for each square that a piece defends, or would defend if an exchange ...">defendables</a>(code, index, battery));
<a name="l00470"></a>00470     <span class="keywordflow">if</span> (battery)
<a name="l00471"></a>00471       ++M_king_battery_attack_count[code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>()];
<a name="l00472"></a>00472     update_blocked_defendables(code, index, <span class="keyword">false</span>);
<a name="l00473"></a>00473   }
<a name="l00474"></a>00474 
<a name="l00475"></a>00475   <a class="code" href="classcwchess_1_1Flags.html" title="Flags representing the state of a piece on the chessboard.">Flags</a> flags(fl_none);
<a name="l00476"></a>00476 
<a name="l00477"></a>00477   <span class="keywordflow">if</span> (code.<a class="code" href="classcwchess_1_1Code.html#a7e9e51ca2eb4c4fb0147e2373ec7dfcb" title="Returns TRUE if the type is equal.">is_a</a>(<a class="code" href="namespacecwchess.html#a6c67ba2364b136bfc37bab16576ff289" title="A constant representing a pawn.">pawn</a>))
<a name="l00478"></a>00478   {
<a name="l00479"></a>00479     <span class="comment">// Initialize the pawn flags for this pawn.</span>
<a name="l00480"></a>00480     <span class="comment">// Calculate forward1: the square right in front of the pawn,</span>
<a name="l00481"></a>00481     <span class="comment">//           forward2: the square two squares in front of the pawn, or 0 if that&#39;s off the board.</span>
<a name="l00482"></a>00482     <span class="comment">//           kingside: the square that the pawn attacks towards the h-file (or 0 when the pawn is on the h-file).</span>
<a name="l00483"></a>00483     <span class="comment">//           queenside: the square that the pawn attacks towards the a-file (or 0 when the pawn is on the a-file).</span>
<a name="l00484"></a>00484     <span class="comment">//           other_pieces: All pieces of a different color.</span>
<a name="l00485"></a>00485     <span class="comment">//           all_pieces: All pieces.</span>
<a name="l00486"></a>00486     <a class="code" href="structcwchess_1_1BitBoardData.html" title="The POD base type of class BitBoard.">BitBoardData</a> forward1 = { mask };
<a name="l00487"></a>00487     <a class="code" href="structcwchess_1_1BitBoardData.html" title="The POD base type of class BitBoard.">BitBoardData</a> forward2 = { mask };
<a name="l00488"></a>00488     <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> other_pieces, all_pieces;
<a name="l00489"></a>00489     uint8_t initial_row;
<a name="l00490"></a>00490     <span class="keywordflow">if</span> (code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>() == <a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>)
<a name="l00491"></a>00491     {
<a name="l00492"></a>00492       other_pieces = M_bitboards[<a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>];
<a name="l00493"></a>00493       forward1.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a> &lt;&lt;= 8;
<a name="l00494"></a>00494       forward2.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a> &lt;&lt;= 16;
<a name="l00495"></a>00495       all_pieces = other_pieces | M_bitboards[<a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>];
<a name="l00496"></a>00496       initial_row = 1;
<a name="l00497"></a>00497     }
<a name="l00498"></a>00498     <span class="keywordflow">else</span>
<a name="l00499"></a>00499     {
<a name="l00500"></a>00500       other_pieces = M_bitboards[<a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>];
<a name="l00501"></a>00501       forward1.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a> &gt;&gt;= 8;
<a name="l00502"></a>00502       forward2.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a> &gt;&gt;= 16;
<a name="l00503"></a>00503       all_pieces = other_pieces | M_bitboards[<a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>];
<a name="l00504"></a>00504       initial_row = 6;
<a name="l00505"></a>00505     }
<a name="l00506"></a>00506     <a class="code" href="structcwchess_1_1BitBoardData.html" title="The POD base type of class BitBoard.">BitBoardData</a> kingside(forward1), queenside(forward1);
<a name="l00507"></a>00507     kingside.M_bitmask &lt;&lt;= 1;
<a name="l00508"></a>00508     queenside.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a> &gt;&gt;= 1;
<a name="l00509"></a>00509     kingside.M_bitmask&amp; = ~<a class="code" href="namespacecwchess.html#a3d47283c624760531b65ae0e88e40be9" title="The a-file.">file_a</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l00510"></a>00510     queenside.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>&amp; = ~<a class="code" href="namespacecwchess.html#adfb6784a238922e3b2a2e2c01269deb9" title="The h-file.">file_h</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l00511"></a>00511     <span class="keywordflow">if</span> (!(all_pieces &amp; forward1))
<a name="l00512"></a>00512     {
<a name="l00513"></a>00513       flags |= <a class="code" href="namespacecwchess.html#aa9e4da3ad830a2fd86c221b1486350dc" title="A constant representing the flag&amp; #39;pawn is not blocked&amp;#39;.">fl_pawn_is_not_blocked</a>;
<a name="l00514"></a>00514       <span class="keywordflow">if</span> (!(all_pieces &amp; forward2) &amp;&amp; initial_row == index_row)
<a name="l00515"></a>00515         flags |= <a class="code" href="namespacecwchess.html#aee2d6e45cf070b3d223a7c7dd6372cfd" title="A constant representing the flag&amp; #39;pawn can move two squares&amp;#39;.">fl_pawn_can_move_two_squares</a>;
<a name="l00516"></a>00516     }
<a name="l00517"></a>00517     <span class="keywordflow">if</span> (M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#a4d2a5402133c3f3c8d001a44786ac02d" title="Return TRUE if the last move was a pawn advancing two squares.">exists</a>() &amp;&amp; M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#aec896b8159bb5b79883dff78e50d3b1e" title="Return the index of the square that pawn came from.">from_index</a>().<a class="code" href="classcwchess_1_1Index.html#a7ea9520a22986f986f6e9dd818b8ad90" title="Returns the row.">row</a>() != initial_row)
<a name="l00518"></a>00518       other_pieces |= M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#a877e86f096b677f19ddd52a55d29a216" title="Return the index of the square that was passed.">index</a>();
<a name="l00519"></a>00519     <span class="keywordflow">if</span> ((other_pieces &amp; queenside))
<a name="l00520"></a>00520       flags |= <a class="code" href="namespacecwchess.html#ad48f98cb4b6d0df34aba736c0a89d235" title="A constant representing the flag&amp; #39;pawn can take queen side&amp;#39;.">fl_pawn_can_take_queen_side</a>;
<a name="l00521"></a>00521     <span class="keywordflow">if</span> ((other_pieces &amp; kingside))
<a name="l00522"></a>00522       flags |= <a class="code" href="namespacecwchess.html#a7eb6bd010f4ee47f8cebc8ebef117c58" title="A constant representing the flag&amp; #39;pawn can take king side&amp;#39;.">fl_pawn_can_take_king_side</a>;
<a name="l00523"></a>00523   }
<a name="l00524"></a>00524 
<a name="l00525"></a>00525   <span class="comment">// Replace or put the piece on the board.</span>
<a name="l00526"></a>00526   M_pieces[index] = <a class="code" href="classcwchess_1_1Piece.html" title="A particular piece on the board.">Piece</a>(code, flags);
<a name="l00527"></a>00527 
<a name="l00528"></a>00528   <span class="comment">// Update pinning flags.</span>
<a name="l00529"></a>00529   <span class="comment">//</span>
<a name="l00530"></a>00530   <span class="comment">// We have two pinning masks (for each color of the king, so four in total).</span>
<a name="l00531"></a>00531   <span class="comment">// The first mask (M_attackers) contains bits for every square between every attacker and the king (not including the king).</span>
<a name="l00532"></a>00532   <span class="comment">// The second mask (M_pinning) contains the same, but only for those attackers that actually pin a piece.</span>
<a name="l00533"></a>00533   <span class="comment">//</span>
<a name="l00534"></a>00534   <span class="comment">// For the examples, we consider only rooks as attackers, and only over a horizontal line.</span>
<a name="l00535"></a>00535   <span class="comment">//</span>
<a name="l00536"></a>00536   <span class="comment">// We have the following cases:</span>
<a name="l00537"></a>00537   <span class="comment">//</span>
<a name="l00538"></a>00538   <span class="comment">// 1) The new piece is on a line with the enemy king : we need to check more.</span>
<a name="l00539"></a>00539   <span class="comment">//</span>
<a name="l00540"></a>00540   <span class="comment">//     x ? ? ? ? K</span>
<a name="l00541"></a>00541   <span class="comment">//</span>
<a name="l00542"></a>00542   <span class="comment">// 2) The new piece is not on a line with the enemy king : we do not need to update anything.</span>
<a name="l00543"></a>00543   <span class="comment">//</span>
<a name="l00544"></a>00544   <span class="comment">//     x ? ? ? ? ?</span>
<a name="l00545"></a>00545   <span class="comment">//     ? ? ? ? ? K</span>
<a name="l00546"></a>00546   <span class="comment">//</span>
<a name="l00547"></a>00547   <span class="comment">// In case 1), we have the possibilities:</span>
<a name="l00548"></a>00548   <span class="comment">//</span>
<a name="l00549"></a>00549   <span class="comment">// 1a) The new piece is an attacker (a rook or queen, in the case of a horizontal line) of the enemy king.</span>
<a name="l00550"></a>00550   <span class="comment">//</span>
<a name="l00551"></a>00551   <span class="comment">//     r ? ? ? ? K</span>
<a name="l00552"></a>00552   <span class="comment">//</span>
<a name="l00553"></a>00553   <span class="comment">// 1b) The new piece is not an attacker (or empty)</span>
<a name="l00554"></a>00554   <span class="comment">//</span>
<a name="l00555"></a>00555   <span class="comment">//     n ? ? ? ? K</span>
<a name="l00556"></a>00556   <span class="comment">//</span>
<a name="l00557"></a>00557   <span class="comment">// This is sufficient information to update mask 1:</span>
<a name="l00558"></a>00558   <span class="comment">// In the case of 1b we need to do nothing unless we&#39;re removing a piece (case 1br).</span>
<a name="l00559"></a>00559   <span class="comment">// In the case 1a we need set bits only if the bit under the piece is not set already.</span>
<a name="l00560"></a>00560   <span class="comment">//</span>
<a name="l00561"></a>00561   <span class="comment">// For example,</span>
<a name="l00562"></a>00562   <span class="comment">//            __ no attackers</span>
<a name="l00563"></a>00563   <span class="comment">//        ___/</span>
<a name="l00564"></a>00564   <span class="comment">//        ? ? r ? ? ? ? K</span>
<a name="l00565"></a>00565   <span class="comment">// mask1: 0 0 1 1 1 1 1 0</span>
<a name="l00566"></a>00566   <span class="comment">// place:         r           --&gt; mask doesn&#39;t change.</span>
<a name="l00567"></a>00567   <span class="comment">// place: r                   --&gt; mask is extended.</span>
<a name="l00568"></a>00568   <span class="comment">//</span>
<a name="l00569"></a>00569   <span class="comment">// In case 1br, there are two cases:</span>
<a name="l00570"></a>00570   <span class="comment">//</span>
<a name="l00571"></a>00571   <span class="comment">// 1br1) We are removing an attacker.</span>
<a name="l00572"></a>00572   <span class="comment">// 1br2) We are not removing an attacker.</span>
<a name="l00573"></a>00573   <span class="comment">//</span>
<a name="l00574"></a>00574   <span class="comment">// In case 1br1 it is necessary to recalculate mask 1. For example,</span>
<a name="l00575"></a>00575   <span class="comment">//</span>
<a name="l00576"></a>00576   <span class="comment">//        ? ? r - r - N K</span>
<a name="l00577"></a>00577   <span class="comment">// mask1: 0 0 1 1 1 1 1 0</span>
<a name="l00578"></a>00578   <span class="comment">// remove:    ^</span>
<a name="l00579"></a>00579   <span class="comment">// mask1: 0 0 0 0 1 1 1 0</span>
<a name="l00580"></a>00580   <span class="comment">//</span>
<a name="l00581"></a>00581   <span class="comment">// At this point mask 1 is updated.</span>
<a name="l00582"></a>00582   <span class="comment">//</span>
<a name="l00583"></a>00583   <span class="comment">// In case 1br1 we only need to update mask 2 if the attacker being removed</span>
<a name="l00584"></a>00584   <span class="comment">// was the pinning attacker, if the corresponding bit in mask 2 is set as well,</span>
<a name="l00585"></a>00585   <span class="comment">// or if there wasn&#39;t any pinning along this line.</span>
<a name="l00586"></a>00586   <span class="comment">//</span>
<a name="l00587"></a>00587   <span class="comment">// For example,</span>
<a name="l00588"></a>00588   <span class="comment">//</span>
<a name="l00589"></a>00589   <span class="comment">//        ? ? r - r - N K</span>
<a name="l00590"></a>00590   <span class="comment">// mask1: 0 0 1 1 1 1 1 0</span>
<a name="l00591"></a>00591   <span class="comment">// mask2: 0 0 0 0 1 1 1 0</span>
<a name="l00592"></a>00592   <span class="comment">// remove:    ^               Not update of mask2 is needed.</span>
<a name="l00593"></a>00593   <span class="comment">// remove:        ^</span>
<a name="l00594"></a>00594   <span class="comment">// mask2: 0 0 1 1 1 1 1 0</span>
<a name="l00595"></a>00595   <span class="comment">//</span>
<a name="l00596"></a>00596   <span class="comment">// or</span>
<a name="l00597"></a>00597   <span class="comment">//</span>
<a name="l00598"></a>00598   <span class="comment">//        ? ? r N r - - K</span>
<a name="l00599"></a>00599   <span class="comment">// mask1: 0 0 1 1 1 1 1 0</span>
<a name="l00600"></a>00600   <span class="comment">// mask2: 0 0 0 0 0 0 0 0</span>
<a name="l00601"></a>00601   <span class="comment">// remove:        ^</span>
<a name="l00602"></a>00602   <span class="comment">// mask2: 0 0 1 1 1 1 1 0</span>
<a name="l00603"></a>00603   <span class="comment">//</span>
<a name="l00604"></a>00604   <span class="comment">// In case 1br2 we need to reset mask 2, and there is only a need to recalculate</span>
<a name="l00605"></a>00605   <span class="comment">// it if the piece being removed wasn&#39;t actually pinned. For example,</span>
<a name="l00606"></a>00606   <span class="comment">//</span>
<a name="l00607"></a>00607   <span class="comment">//        ? ? r - N - N K</span>
<a name="l00608"></a>00608   <span class="comment">// mask1: 0 0 1 1 1 1 1 0</span>
<a name="l00609"></a>00609   <span class="comment">// mask2: 0 0 0 0 0 0 0 0</span>
<a name="l00610"></a>00610   <span class="comment">// remove:            ^</span>
<a name="l00611"></a>00611   <span class="comment">// mask2: 0 0 1 1 1 1 1 0</span>
<a name="l00612"></a>00612   <span class="comment">//</span>
<a name="l00613"></a>00613   <span class="comment">// or</span>
<a name="l00614"></a>00614   <span class="comment">//</span>
<a name="l00615"></a>00615   <span class="comment">//        ? ? r - N - - K</span>
<a name="l00616"></a>00616   <span class="comment">// mask1: 0 0 1 1 1 1 1 0</span>
<a name="l00617"></a>00617   <span class="comment">// mask2: 0 0 1 1 1 1 1 0</span>
<a name="l00618"></a>00618   <span class="comment">// remove:        ^</span>
<a name="l00619"></a>00619   <span class="comment">// mask2: 0 0 0 0 0 0 0 0     Just reset: the removed piece was pinned (we&#39;re in check now).</span>
<a name="l00620"></a>00620   <span class="comment">//</span>
<a name="l00621"></a>00621   <span class="comment">// If the piece is an attacker (==&gt; the corresponding bit in mask 1 is set), we need</span>
<a name="l00622"></a>00622   <span class="comment">// to reset the bits for this direction in mask 2 and call ChessPosition::update_pinning.</span>
<a name="l00623"></a>00623   <span class="comment">//</span>
<a name="l00624"></a>00624   <span class="comment">//        ? ? r - - - N K     The knight is pinned.</span>
<a name="l00625"></a>00625   <span class="comment">// mask1: 0 0 1 1 1 1 1 0</span>
<a name="l00626"></a>00626   <span class="comment">// mask2: 0 0 1 1 1 1 1 0</span>
<a name="l00627"></a>00627   <span class="comment">// place:         r</span>
<a name="l00628"></a>00628   <span class="comment">// mask2: 0 0 0 0 1 1 1 0     The knight is pinned by the new piece.</span>
<a name="l00629"></a>00629   <span class="comment">//</span>
<a name="l00630"></a>00630   <span class="comment">// If the piece is not an attacker and the corresponding bit in mask 1 is not set,</span>
<a name="l00631"></a>00631   <span class="comment">// then we are done.</span>
<a name="l00632"></a>00632   <span class="comment">//</span>
<a name="l00633"></a>00633   <span class="comment">//        ? ? r - - - N K</span>
<a name="l00634"></a>00634   <span class="comment">// mask1: 0 0 1 1 1 1 1 0</span>
<a name="l00635"></a>00635   <span class="comment">// mask2: 0 0 1 1 1 1 1 0</span>
<a name="l00636"></a>00636   <span class="comment">// place:   b</span>
<a name="l00637"></a>00637   <span class="comment">// mask2: 0 0 1 1 1 1 1 0     The knight is still pinnded by the old piece (r).</span>
<a name="l00638"></a>00638   <span class="comment">//</span>
<a name="l00639"></a>00639   <span class="comment">// If the piece is not an attacker and the corresponding bit in mask 1 is set,</span>
<a name="l00640"></a>00640   <span class="comment">// We have two possibilities: the corresponding bit in mask 2 is set, or not set:</span>
<a name="l00641"></a>00641   <span class="comment">//</span>
<a name="l00642"></a>00642   <span class="comment">// 1ba) The new piece is not an attacker and the corresponding bit in mask 1 and mask 2 are set.</span>
<a name="l00643"></a>00643   <span class="comment">// 1bb) The new piece is not an attacker and the corresponding bit in mask 1 is set, and in mask 2 is not set.</span>
<a name="l00644"></a>00644   <span class="comment">//</span>
<a name="l00645"></a>00645   <span class="comment">// In case 1ba, the bits for this direction in mask 2 must be reset, and if old_code</span>
<a name="l00646"></a>00646   <span class="comment">// is not empty, ChessPosition::update_pinning must be called.</span>
<a name="l00647"></a>00647   <span class="comment">// </span>
<a name="l00648"></a>00648   <span class="comment">//        ? ? r - - - N K</span>
<a name="l00649"></a>00649   <span class="comment">// mask1: 0 0 1 1 1 1 1 0</span>
<a name="l00650"></a>00650   <span class="comment">// mask2: 0 0 1 1 1 1 1 0</span>
<a name="l00651"></a>00651   <span class="comment">// place:     b</span>
<a name="l00652"></a>00652   <span class="comment">// mask2: 0 0 0 0 0 0 0 0</span>
<a name="l00653"></a>00653   <span class="comment">// place:         b</span>
<a name="l00654"></a>00654   <span class="comment">// mask2: 0 0 0 0 0 0 0 0</span>
<a name="l00655"></a>00655   <span class="comment">// place:             B</span>
<a name="l00656"></a>00656   <span class="comment">// mask2: 0 0 1 1 1 1 1 0</span>
<a name="l00657"></a>00657   <span class="comment">//</span>
<a name="l00658"></a>00658   <span class="comment">// In case 1bb, if any bit for this direction in mask 2 is set, or if the color</span>
<a name="l00659"></a>00659   <span class="comment">// of the piece that is placed is different from the king, we are done.</span>
<a name="l00660"></a>00660   <span class="comment">// Otherwise we need to call ChessPosition::update_pinning.</span>
<a name="l00661"></a>00661   <span class="comment">//</span>
<a name="l00662"></a>00662   <span class="comment">//        ? ? r - r - N K</span>
<a name="l00663"></a>00663   <span class="comment">// mask1: 0 0 1 1 1 1 1 0</span>
<a name="l00664"></a>00664   <span class="comment">// mask2: 0 0 0 0 1 1 1 0</span>
<a name="l00665"></a>00665   <span class="comment">// place:       b             We are done.</span>
<a name="l00666"></a>00666   <span class="comment">//</span>
<a name="l00667"></a>00667   <span class="comment">//        ? ? r - - - - K</span>
<a name="l00668"></a>00668   <span class="comment">// mask1: 0 0 1 1 1 1 1 0</span>
<a name="l00669"></a>00669   <span class="comment">// mask2: 0 0 0 0 0 0 0 0</span>
<a name="l00670"></a>00670   <span class="comment">// place:         B</span>
<a name="l00671"></a>00671   <span class="comment">// mask2: 0 0 1 1 1 1 1 0</span>
<a name="l00672"></a>00672   <span class="comment">//</span>
<a name="l00673"></a>00673   <span class="keywordtype">int</span> color_count = 0;
<a name="l00674"></a>00674   <span class="comment">// Run over all colors.</span>
<a name="l00675"></a>00675   <span class="keywordflow">for</span> (<a class="code" href="classcwchess_1_1Color.html" title="A color (black or white).">Color</a> color = <a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>; color_count &lt; 2; ++color_count, color = <a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>)
<a name="l00676"></a>00676   {
<a name="l00677"></a>00677     <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> <span class="keyword">const</span> king_code(color, <a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>);                          <span class="comment">// The king of this color.</span>
<a name="l00678"></a>00678     <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> <span class="keyword">const</span> king_index(<a class="code" href="namespacecwchess.html#a556a7930206c9c994411661cd2896dd1" title="Convert a single bit mask into it&amp;#39;s Index.">mask2index</a>(M_bitboards[king_code]()));       <span class="comment">// Where that king is.</span>
<a name="l00679"></a>00679     <span class="keywordflow">if</span> (king_index == <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>)
<a name="l00680"></a>00680       <span class="keywordflow">continue</span>;                                                 <span class="comment">// If there isn&#39;t a king of that color, nothing can be pinned.</span>
<a name="l00681"></a>00681     <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> <span class="keyword">const</span> line(squares_from_to(index, king_index));            <span class="comment">// All squares from the new piece to the that king.</span>
<a name="l00682"></a>00682     <span class="keywordflow">if</span> (!line.<a class="code" href="classcwchess_1_1BitBoard.html#acdb49d61eb3a825048c17627d1bc8f10" title="Test if any bit is set at all.">test</a>())                                                   <span class="comment">// Are the piece and this king on one line at all?</span>
<a name="l00683"></a>00683       <span class="keywordflow">continue</span>;                                                 <span class="comment">// case 2: If not, then this piece cannot influence pinning.</span>
<a name="l00684"></a>00684 
<a name="l00685"></a>00685     <span class="comment">// case 1:</span>
<a name="l00686"></a>00686     <a class="code" href="structcwchess_1_1Direction.html">Direction</a> <span class="keyword">const</span> direction(direction_from_to(king_index, index));                    <span class="comment">// The direction from king to this piece.</span>
<a name="l00687"></a>00687     <span class="keywordtype">bool</span> <span class="keyword">const</span> attacker = (code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>() != color) &amp;&amp; direction.matches(code.<a class="code" href="classcwchess_1_1Code.html#a071640067d0b914b055a1818d368f4cd" title="Return the Type of this Code.">type</a>());    <span class="comment">// The new piece attacks the king if it is of opposite color</span>
<a name="l00688"></a>00688                                                                                       <span class="comment">// and can move along the given direction.</span>
<a name="l00689"></a>00689     <span class="keywordtype">bool</span> need_reset = <span class="keyword">false</span>;            <span class="comment">// Set if M_pinning might have bits set that need to be unset.</span>
<a name="l00690"></a>00690     <span class="keywordtype">bool</span> need_update = <span class="keyword">false</span>;           <span class="comment">// Recalculate M_pinning.</span>
<a name="l00691"></a>00691 
<a name="l00692"></a>00692     <span class="keywordtype">bool</span> <span class="keyword">const</span> corresponding_bit_in_M_attackers_is_set = M_attackers[color]() &amp; mask;
<a name="l00693"></a>00693     <span class="keywordflow">if</span> (attacker)
<a name="l00694"></a>00694     {
<a name="l00695"></a>00695       <span class="comment">// case 1a.</span>
<a name="l00696"></a>00696       <span class="keywordflow">if</span> (!corresponding_bit_in_M_attackers_is_set)
<a name="l00697"></a>00697       {
<a name="l00698"></a>00698         <span class="comment">// We have a new attacker that is even further away from the king.</span>
<a name="l00699"></a>00699         M_attackers[color] |= line;             <span class="comment">// Extend M_attackers to include the new attacker.</span>
<a name="l00700"></a>00700       }
<a name="l00701"></a>00701       need_reset = need_update = <span class="keyword">true</span>;
<a name="l00702"></a>00702     }
<a name="l00703"></a>00703     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (corresponding_bit_in_M_attackers_is_set)
<a name="l00704"></a>00704     {
<a name="l00705"></a>00705       <span class="comment">// Case 1b.</span>
<a name="l00706"></a>00706       <span class="keywordflow">if</span> (code.<a class="code" href="classcwchess_1_1Code.html#ac9bd2b012eda487a8dea719dfae925d3" title="Returns TRUE if the code represents&amp; #39;nothing&amp;#39;.">is_nothing</a>())
<a name="l00707"></a>00707       {
<a name="l00708"></a>00708         <span class="comment">// Case 1br.</span>
<a name="l00709"></a>00709         <span class="keywordflow">if</span> (direction.matches(old_code.<a class="code" href="classcwchess_1_1Code.html#a071640067d0b914b055a1818d368f4cd" title="Return the Type of this Code.">type</a>()))
<a name="l00710"></a>00710         {
<a name="l00711"></a>00711           <span class="comment">// An attacker was removed. Check if M_attackers needs to be changed.</span>
<a name="l00712"></a>00712           <a class="code" href="structcwchess_1_1TypeData.html" title="The POD base type of class Type.">TypeData</a> mover;
<a name="l00713"></a>00713           mover.<a class="code" href="structcwchess_1_1TypeData.html#ac1bdbde6f15f981c3d11e2393699ba69" title="00000STT, where STT is the type. If S == 1 then the piece is a slider.">M_bits</a> = direction.flags &amp; <a class="code" href="namespacecwchess.html#ad8667c6f4360760e17bf219130fe7794" title="A mask for the bits used for the type of a piece.">type_mask</a>;
<a name="l00714"></a>00714           <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> queen_code(color.opposite(), <a class="code" href="namespacecwchess.html#ad3a2fc51450ffe511826ea0ddc6781ec" title="A constant representing a queen.">queen</a>);
<a name="l00715"></a>00715           <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> mover_code(color.opposite(), mover);
<a name="l00716"></a>00716           <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> mover_attackers(M_bitboards[mover_code] | M_bitboards[queen_code]);
<a name="l00717"></a>00717           <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> line(direction.<a class="code" href="structcwchess_1_1Direction.html#ac774c9ba1cc29045849a85fd7fdd89f8" title="Return a BitBoard with all squares in this direction.">from</a>(king_index));
<a name="l00718"></a>00718           mover_attackers&amp; = line;
<a name="l00719"></a>00719           <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> attackers(CW_MASK_T_CONST(0));
<a name="l00720"></a>00720           <span class="keywordflow">for</span> (PieceIterator piece_iter(<span class="keyword">this</span>, mover_attackers); piece_iter != <a class="code" href="classcwchess_1_1ChessPosition.html#ae3c2f52411c85422dff0d0689cd7249a" title="Return an iterator one beyond the last piece.">piece_end</a>(); ++piece_iter)
<a name="l00721"></a>00721             attackers |= squares_from_to(piece_iter.index(), king_index);
<a name="l00722"></a>00722           M_attackers[color].reset(line);
<a name="l00723"></a>00723           M_attackers[color].set(attackers);
<a name="l00724"></a>00724 
<a name="l00725"></a>00725           <span class="comment">// We only need an update if the corresponding bit in M_pinning is set as well</span>
<a name="l00726"></a>00726           <span class="comment">// (then this was the pinning attacker), or otherwise if M_pinning has no</span>
<a name="l00727"></a>00727           <span class="comment">// bits set at all, in which case this piece could have been blocking the pin.</span>
<a name="l00728"></a>00728           need_reset = need_update = M_pinning[color].test(mask) || !(M_pinning[color] &amp; line).test();
<a name="l00729"></a>00729         }
<a name="l00730"></a>00730         <span class="keywordflow">else</span>
<a name="l00731"></a>00731         {
<a name="l00732"></a>00732           <span class="comment">// A non-attacker was removed.</span>
<a name="l00733"></a>00733           need_reset = <span class="keyword">true</span>;
<a name="l00734"></a>00734           <span class="comment">// If the corresponding bit in M_pinning isn&#39;t set, then this wasn&#39;t a pinned piece, so we need to update M_pinning.</span>
<a name="l00735"></a>00735           need_update = !(M_pinning[color]() &amp; mask);
<a name="l00736"></a>00736         }
<a name="l00737"></a>00737       }
<a name="l00738"></a>00738       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((M_pinning[color]() &amp; mask))     <span class="comment">// Is the corresponding bit in M_pinning set too?</span>
<a name="l00739"></a>00739       {
<a name="l00740"></a>00740         <span class="comment">// Case 1ba.</span>
<a name="l00741"></a>00741         need_reset = <span class="keyword">true</span>;
<a name="l00742"></a>00742         need_update = !old_code.<a class="code" href="classcwchess_1_1Code.html#ac9bd2b012eda487a8dea719dfae925d3" title="Returns TRUE if the code represents&amp; #39;nothing&amp;#39;.">is_nothing</a>();
<a name="l00743"></a>00743       }
<a name="l00744"></a>00744       <span class="keywordflow">else</span>
<a name="l00745"></a>00745       {
<a name="l00746"></a>00746         <span class="comment">// Case 1bb.</span>
<a name="l00747"></a>00747         <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> line(direction.<a class="code" href="structcwchess_1_1Direction.html#ac774c9ba1cc29045849a85fd7fdd89f8" title="Return a BitBoard with all squares in this direction.">from</a>(king_index));
<a name="l00748"></a>00748         need_reset = need_update =
<a name="l00749"></a>00749             (code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>() == color || (M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#a4d2a5402133c3f3c8d001a44786ac02d" title="Return TRUE if the last move was a pawn advancing two squares.">exists</a>() &amp;&amp; direction.is_horizontal())) &amp;&amp; !M_pinning[color].test(line);
<a name="l00750"></a>00750       }
<a name="l00751"></a>00751     }
<a name="l00752"></a>00752     <span class="keywordflow">if</span> (need_reset)
<a name="l00753"></a>00753     {
<a name="l00754"></a>00754       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> line(direction.<a class="code" href="structcwchess_1_1Direction.html#ac774c9ba1cc29045849a85fd7fdd89f8" title="Return a BitBoard with all squares in this direction.">from</a>(king_index));
<a name="l00755"></a>00755       M_pinning[color].reset(line);
<a name="l00756"></a>00756       <span class="keywordflow">if</span> (need_update)
<a name="l00757"></a>00757       {
<a name="l00758"></a>00758         <span class="keywordflow">if</span> (__builtin_expect(M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#a4d2a5402133c3f3c8d001a44786ac02d" title="Return TRUE if the last move was a pawn advancing two squares.">exists</a>(), <span class="keyword">false</span>))
<a name="l00759"></a>00759         {
<a name="l00760"></a>00760           <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> pawn_index(M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#a9211a09a94a79cddf6030f522c20daae" title="Return the index of the pawn that just advanced two squares.">pawn_index</a>());
<a name="l00761"></a>00761           <span class="keywordflow">if</span> (M_pieces[pawn_index].color() != color &amp;&amp; line.<a class="code" href="classcwchess_1_1BitBoard.html#acdb49d61eb3a825048c17627d1bc8f10" title="Test if any bit is set at all.">test</a>(pawn_index))
<a name="l00762"></a>00762             M_en_passant.pinned_reset();
<a name="l00763"></a>00763         }
<a name="l00764"></a>00764         update_pinning(king_code, king_index, M_bitboards[king_code](), direction, (M_bitboards[<a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>] | M_bitboards[<a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>]) &amp; line);
<a name="l00765"></a>00765       }
<a name="l00766"></a>00766     }
<a name="l00767"></a>00767   }
<a name="l00768"></a>00768 
<a name="l00769"></a>00769   <span class="comment">// Update caching of in_check and M_double_check.</span>
<a name="l00770"></a>00770   <span class="keywordtype">bool</span> in_check = <a class="code" href="classcwchess_1_1ChessPosition.html#a068f4a67a7bcb07c491b81deb1396f0a" title="Return true if the king is in check.">check</a>();
<a name="l00771"></a>00771   M_castle_flags.set_check(M_to_move, in_check);
<a name="l00772"></a>00772   M_castle_flags.set_check(M_to_move.<a class="code" href="classcwchess_1_1Color.html#ae7b69104c64e17005f5eb3ad277c4bdf" title="Return a Color object with the opposite color of this object.">opposite</a>(), <a class="code" href="classcwchess_1_1ChessPosition.html#a068f4a67a7bcb07c491b81deb1396f0a" title="Return true if the king is in check.">check</a>(M_to_move.<a class="code" href="classcwchess_1_1Color.html#ae7b69104c64e17005f5eb3ad277c4bdf" title="Return a Color object with the opposite color of this object.">opposite</a>()));
<a name="l00773"></a>00773   M_double_check = in_check ? <a class="code" href="classcwchess_1_1ChessPosition.html#a787c6d8859c8e06fe3c95b5464af2ea6" title="Return true if the king of color color is in double check.">double_check</a>(M_to_move) : <span class="keyword">false</span>;
<a name="l00774"></a>00774 
<a name="l00775"></a>00775   <span class="comment">// Success.</span>
<a name="l00776"></a>00776   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00777"></a>00777 }
<a name="l00778"></a>00778 
<a name="l00779"></a><a class="code" href="classcwchess_1_1ChessPosition.html#a3f7244d15ec7d5d45cbb63f6ae7db085">00779</a> <span class="keywordtype">bool</span> <a class="code" href="classcwchess_1_1ChessPosition.html#a3f7244d15ec7d5d45cbb63f6ae7db085" title="Read a FEN code.">ChessPosition::load_FEN</a>(std::string <span class="keyword">const</span>&amp; FEN)
<a name="l00780"></a>00780 {
<a name="l00781"></a>00781   DoutEntering(dc::notice, <span class="stringliteral">&quot;ChessPosition::load_FEN(\&quot;&quot;</span> &lt;&lt; FEN &lt;&lt; <span class="stringliteral">&quot;\&quot;)&quot;</span>);
<a name="l00782"></a>00782 
<a name="l00783"></a>00783   <span class="comment">// Clear the position.</span>
<a name="l00784"></a>00784   <a class="code" href="classcwchess_1_1ChessPosition.html#a49ecca7f847204957b161ff1034a411d" title="Clear the board.">clear</a>();
<a name="l00785"></a>00785   std::string::const_iterator iter = FEN.begin();
<a name="l00786"></a>00786   <span class="keywordtype">char</span> c;
<a name="l00787"></a>00787   <span class="comment">// Eat preceding spaces.</span>
<a name="l00788"></a>00788   <span class="keywordflow">while</span> (*iter == <span class="charliteral">&#39; &#39;</span>)
<a name="l00789"></a>00789     ++iter;
<a name="l00790"></a>00790   <span class="keywordflow">if</span> (iter == FEN.end())
<a name="l00791"></a>00791     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00792"></a>00792   <span class="comment">// Field 1: Piece placement.</span>
<a name="l00793"></a>00793   <a class="code" href="classcwchess_1_1Color.html" title="A color (black or white).">Color</a> color;
<a name="l00794"></a>00794   <span class="keywordtype">int</span> col = 0, row = 7;
<a name="l00795"></a>00795   <span class="keywordflow">while</span> ((c =* iter++) != <span class="charliteral">&#39; &#39;</span>)
<a name="l00796"></a>00796   {
<a name="l00797"></a>00797     color = <a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>;
<a name="l00798"></a>00798     <span class="keywordflow">switch</span> (c)
<a name="l00799"></a>00799     {
<a name="l00800"></a>00800       <span class="keywordflow">case</span> <span class="charliteral">&#39;/&#39;</span>:
<a name="l00801"></a>00801         <span class="keywordflow">if</span> (col != 8 || row &lt;= 0)
<a name="l00802"></a>00802           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00803"></a>00803         col = 0;
<a name="l00804"></a>00804         --row;
<a name="l00805"></a>00805         <span class="keywordflow">break</span>;
<a name="l00806"></a>00806       <span class="keywordflow">case</span> <span class="charliteral">&#39;1&#39;</span>:
<a name="l00807"></a>00807       <span class="keywordflow">case</span> <span class="charliteral">&#39;2&#39;</span>:
<a name="l00808"></a>00808       <span class="keywordflow">case</span> <span class="charliteral">&#39;3&#39;</span>:
<a name="l00809"></a>00809       <span class="keywordflow">case</span> <span class="charliteral">&#39;4&#39;</span>:
<a name="l00810"></a>00810       <span class="keywordflow">case</span> <span class="charliteral">&#39;5&#39;</span>:
<a name="l00811"></a>00811       <span class="keywordflow">case</span> <span class="charliteral">&#39;6&#39;</span>:
<a name="l00812"></a>00812       <span class="keywordflow">case</span> <span class="charliteral">&#39;7&#39;</span>:
<a name="l00813"></a>00813       <span class="keywordflow">case</span> <span class="charliteral">&#39;8&#39;</span>:
<a name="l00814"></a>00814         col += (int)(c - <span class="charliteral">&#39;0&#39;</span>);
<a name="l00815"></a>00815         <span class="keywordflow">break</span>;
<a name="l00816"></a>00816       <span class="keywordflow">case</span> <span class="charliteral">&#39;p&#39;</span>:
<a name="l00817"></a>00817       <span class="keywordflow">case</span> <span class="charliteral">&#39;r&#39;</span>:
<a name="l00818"></a>00818       <span class="keywordflow">case</span> <span class="charliteral">&#39;n&#39;</span>:
<a name="l00819"></a>00819       <span class="keywordflow">case</span> <span class="charliteral">&#39;b&#39;</span>:
<a name="l00820"></a>00820       <span class="keywordflow">case</span> <span class="charliteral">&#39;q&#39;</span>:
<a name="l00821"></a>00821       <span class="keywordflow">case</span> <span class="charliteral">&#39;k&#39;</span>:
<a name="l00822"></a>00822         color = <a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>;
<a name="l00823"></a>00823       <span class="keywordflow">case</span> <span class="charliteral">&#39;P&#39;</span>:
<a name="l00824"></a>00824       <span class="keywordflow">case</span> <span class="charliteral">&#39;R&#39;</span>:
<a name="l00825"></a>00825       <span class="keywordflow">case</span> <span class="charliteral">&#39;N&#39;</span>:
<a name="l00826"></a>00826       <span class="keywordflow">case</span> <span class="charliteral">&#39;B&#39;</span>:
<a name="l00827"></a>00827       <span class="keywordflow">case</span> <span class="charliteral">&#39;Q&#39;</span>:
<a name="l00828"></a>00828       <span class="keywordflow">case</span> <span class="charliteral">&#39;K&#39;</span>:
<a name="l00829"></a>00829       {
<a name="l00830"></a>00830         c = std::toupper(c);
<a name="l00831"></a>00831         <a class="code" href="classcwchess_1_1Type.html" title="A chess piece type.">Type</a> type;
<a name="l00832"></a>00832         <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;P&#39;</span>)
<a name="l00833"></a>00833           type = <a class="code" href="namespacecwchess.html#a6c67ba2364b136bfc37bab16576ff289" title="A constant representing a pawn.">pawn</a>;
<a name="l00834"></a>00834         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;R&#39;</span>)
<a name="l00835"></a>00835           type = <a class="code" href="namespacecwchess.html#a4ff984a16c54b56749db5209e31b29f9" title="A constant representing a rook.">rook</a>;
<a name="l00836"></a>00836         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;N&#39;</span>)
<a name="l00837"></a>00837           type = <a class="code" href="namespacecwchess.html#abf2c4ea392fe31bf861f9eb143ca299a" title="A constant representing a knight.">knight</a>;
<a name="l00838"></a>00838         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;B&#39;</span>)
<a name="l00839"></a>00839           type = <a class="code" href="namespacecwchess.html#a3f166611f4301dafd492316030d6ecab" title="A constant representing a bishop.">bishop</a>;
<a name="l00840"></a>00840         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;Q&#39;</span>)
<a name="l00841"></a>00841           type = <a class="code" href="namespacecwchess.html#ad3a2fc51450ffe511826ea0ddc6781ec" title="A constant representing a queen.">queen</a>;
<a name="l00842"></a>00842         <span class="keywordflow">else</span> <span class="comment">// if (c == &#39;K&#39;)</span>
<a name="l00843"></a>00843           type = <a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>;
<a name="l00844"></a>00844         <a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">place</a>(<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(color, type), <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a>(col, row));
<a name="l00845"></a>00845         ++col;
<a name="l00846"></a>00846         <span class="keywordflow">break</span>;
<a name="l00847"></a>00847       }
<a name="l00848"></a>00848       <span class="keywordflow">default</span>:
<a name="l00849"></a>00849         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00850"></a>00850     }
<a name="l00851"></a>00851     <span class="keywordflow">if</span> (iter == FEN.end())
<a name="l00852"></a>00852       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00853"></a>00853   }
<a name="l00854"></a>00854   <span class="keywordflow">if</span> (col != 8)
<a name="l00855"></a>00855     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00856"></a>00856   <span class="keywordflow">if</span> (iter == FEN.end())
<a name="l00857"></a>00857     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00858"></a>00858   <span class="comment">// Eat extra spaces.</span>
<a name="l00859"></a>00859   <span class="keywordflow">while</span> (*iter == <span class="charliteral">&#39; &#39;</span>)
<a name="l00860"></a>00860     <span class="keywordflow">if</span> (++iter == FEN.end())
<a name="l00861"></a>00861       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00862"></a>00862   <span class="comment">// Field 2: Active color. </span>
<a name="l00863"></a>00863   c =* iter++;
<a name="l00864"></a>00864   <span class="keywordflow">if</span> (c != <span class="charliteral">&#39;w&#39;</span> &amp;&amp; c != <span class="charliteral">&#39;b&#39;</span>)
<a name="l00865"></a>00865     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00866"></a>00866   M_to_move = (c == <span class="charliteral">&#39;w&#39;</span>) ? <a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a> : <a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>;
<a name="l00867"></a>00867   <span class="keywordtype">bool</span> in_check = <a class="code" href="classcwchess_1_1ChessPosition.html#a068f4a67a7bcb07c491b81deb1396f0a" title="Return true if the king is in check.">check</a>();
<a name="l00868"></a>00868   M_double_check = in_check ? <a class="code" href="classcwchess_1_1ChessPosition.html#a787c6d8859c8e06fe3c95b5464af2ea6" title="Return true if the king of color color is in double check.">double_check</a>(M_to_move) : <span class="keyword">false</span>;
<a name="l00869"></a>00869   <span class="keywordflow">if</span> (iter == FEN.end() ||* iter != <span class="charliteral">&#39; &#39;</span>)
<a name="l00870"></a>00870     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00871"></a>00871   <span class="comment">// Eat space and possibly extra spaces.</span>
<a name="l00872"></a>00872   <span class="keywordflow">while</span> (*iter == <span class="charliteral">&#39; &#39;</span>)
<a name="l00873"></a>00873     <span class="keywordflow">if</span> (++iter == FEN.end())
<a name="l00874"></a>00874       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00875"></a>00875   <span class="comment">// Field 3: Castling availability.</span>
<a name="l00876"></a>00876   uint8_t white_castle_flags = white_rook_queen_side_moved | white_king_moved | white_rook_king_side_moved;
<a name="l00877"></a>00877   uint8_t black_castle_flags = black_rook_queen_side_moved | black_king_moved | black_rook_king_side_moved;
<a name="l00878"></a>00878   <span class="keywordflow">while</span> ((c =* iter++) != <span class="charliteral">&#39; &#39;</span>)
<a name="l00879"></a>00879   {
<a name="l00880"></a>00880     <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;-&#39;</span>)
<a name="l00881"></a>00881       <span class="keywordflow">break</span>;
<a name="l00882"></a>00882     <span class="keywordflow">switch</span> (c)
<a name="l00883"></a>00883     {
<a name="l00884"></a>00884       <span class="keywordflow">case</span> <span class="charliteral">&#39;K&#39;</span>:
<a name="l00885"></a>00885         white_castle_flags&amp; = ~(white_king_moved | white_rook_king_side_moved);
<a name="l00886"></a>00886         <span class="keywordflow">break</span>;
<a name="l00887"></a>00887       <span class="keywordflow">case</span> <span class="charliteral">&#39;Q&#39;</span>:
<a name="l00888"></a>00888         white_castle_flags&amp; = ~(white_king_moved | white_rook_queen_side_moved);
<a name="l00889"></a>00889         <span class="keywordflow">break</span>;
<a name="l00890"></a>00890       <span class="keywordflow">case</span> <span class="charliteral">&#39;k&#39;</span>:
<a name="l00891"></a>00891         black_castle_flags&amp; = ~(black_king_moved | black_rook_king_side_moved);
<a name="l00892"></a>00892         <span class="keywordflow">break</span>;
<a name="l00893"></a>00893       <span class="keywordflow">case</span> <span class="charliteral">&#39;q&#39;</span>:
<a name="l00894"></a>00894         black_castle_flags&amp; = ~(black_king_moved | black_rook_queen_side_moved);
<a name="l00895"></a>00895         <span class="keywordflow">break</span>;
<a name="l00896"></a>00896       <span class="keywordflow">default</span>:
<a name="l00897"></a>00897         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00898"></a>00898     }
<a name="l00899"></a>00899     <span class="keywordflow">if</span> (iter == FEN.end())
<a name="l00900"></a>00900       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00901"></a>00901   }
<a name="l00902"></a>00902   M_castle_flags = white_castle_flags | black_castle_flags;
<a name="l00903"></a>00903   M_castle_flags.set_check(M_to_move, in_check);
<a name="l00904"></a>00904   <span class="keywordflow">if</span> (iter == FEN.end())
<a name="l00905"></a>00905     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00906"></a>00906   <span class="comment">// Eat extra spaces.</span>
<a name="l00907"></a>00907   <span class="keywordflow">while</span> (*iter == <span class="charliteral">&#39; &#39;</span>)
<a name="l00908"></a>00908     <span class="keywordflow">if</span> (++iter == FEN.end())
<a name="l00909"></a>00909       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00910"></a>00910   <span class="comment">// Field 4: En passant target square in algebraic notation.</span>
<a name="l00911"></a>00911   <span class="keywordflow">if</span> ((c =* iter++) != <span class="charliteral">&#39;-&#39;</span>)
<a name="l00912"></a>00912   {
<a name="l00913"></a>00913     <span class="keywordflow">if</span> (c &lt; &#39;a&#39; || c &gt; <span class="charliteral">&#39;h&#39;</span> || iter == FEN.end())
<a name="l00914"></a>00914       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00915"></a>00915     <span class="keywordtype">int</span> col = c - <span class="charliteral">&#39;a&#39;</span>;
<a name="l00916"></a>00916     c =* iter++;
<a name="l00917"></a>00917     <span class="keywordflow">if</span> (c &lt; &#39;1&#39; || c &gt; <span class="charliteral">&#39;8&#39;</span> || iter == FEN.end())
<a name="l00918"></a>00918       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00919"></a>00919     <span class="keywordtype">int</span> row = c - <span class="charliteral">&#39;1&#39;</span>;
<a name="l00920"></a>00920     <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> other_pawn;
<a name="l00921"></a>00921     <span class="keywordflow">if</span> (M_to_move == <a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>)
<a name="l00922"></a>00922     {
<a name="l00923"></a>00923       other_pawn = <a class="code" href="namespacecwchess.html#acbefae1953a03a417fcf2b5c9e3b55a6" title="A constant representing a white pawn.">white_pawn</a>;
<a name="l00924"></a>00924       <span class="keywordflow">if</span> (row != 5 || M_pieces[<a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a>(col, row - 1)] != <a class="code" href="namespacecwchess.html#acd891cc1843e2bce6978c194647c928a" title="A constant representing a black pawn.">black_pawn</a> || M_pieces[<a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a>(col, row)] != <a class="code" href="namespacecwchess.html#ada2c41d3cd72288d05e31c3efbd42c12" title="A constant representing the absence of a piece.">nothing</a>)
<a name="l00925"></a>00925         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00926"></a>00926     }
<a name="l00927"></a>00927     <span class="keywordflow">else</span>
<a name="l00928"></a>00928     {
<a name="l00929"></a>00929       other_pawn = <a class="code" href="namespacecwchess.html#acd891cc1843e2bce6978c194647c928a" title="A constant representing a black pawn.">black_pawn</a>;
<a name="l00930"></a>00930       <span class="keywordflow">if</span> (row != 2 || M_pieces[<a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a>(col, row + 1)] != <a class="code" href="namespacecwchess.html#acbefae1953a03a417fcf2b5c9e3b55a6" title="A constant representing a white pawn.">white_pawn</a> || M_pieces[<a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a>(col, row)] != <a class="code" href="namespacecwchess.html#ada2c41d3cd72288d05e31c3efbd42c12" title="A constant representing the absence of a piece.">nothing</a>)
<a name="l00931"></a>00931         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00932"></a>00932     }
<a name="l00933"></a>00933     <a class="code" href="classcwchess_1_1ChessPosition.html#aa5893a55201a592bb4e5ff7fa00fdb26" title="Explicity set the en passant information.">set_en_passant</a>(<a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a>(col, row));
<a name="l00934"></a>00934   }
<a name="l00935"></a>00935   <span class="keywordflow">if</span> (iter == FEN.end() ||* iter != <span class="charliteral">&#39; &#39;</span>)
<a name="l00936"></a>00936     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00937"></a>00937   <span class="comment">// Eat space and possibly extra spaces.</span>
<a name="l00938"></a>00938   <span class="keywordflow">while</span> (*iter == <span class="charliteral">&#39; &#39;</span>)
<a name="l00939"></a>00939     <span class="keywordflow">if</span> (++iter == FEN.end())
<a name="l00940"></a>00940       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00941"></a>00941   <span class="comment">// Field 5: Halfmove clock: This is the number of halfmoves since the last pawn advance or capture.</span>
<a name="l00942"></a>00942   M_half_move_clock = 0;
<a name="l00943"></a>00943   <span class="keywordflow">while</span> ((c =* iter++) != <span class="charliteral">&#39; &#39;</span>)
<a name="l00944"></a>00944   {
<a name="l00945"></a>00945     <span class="keywordflow">if</span> (!std::isdigit(c))
<a name="l00946"></a>00946       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00947"></a>00947     M_half_move_clock = 10 * M_half_move_clock + c - <span class="charliteral">&#39;0&#39;</span>;
<a name="l00948"></a>00948     <span class="keywordflow">if</span> (iter == FEN.end())
<a name="l00949"></a>00949       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00950"></a>00950   }
<a name="l00951"></a>00951   <span class="comment">// Eat extra spaces.</span>
<a name="l00952"></a>00952   <span class="keywordflow">while</span> (*iter == <span class="charliteral">&#39; &#39;</span>)
<a name="l00953"></a>00953     <span class="keywordflow">if</span> (++iter == FEN.end())
<a name="l00954"></a>00954       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00955"></a>00955   <span class="comment">// Field 6: Fullmove number: The number of the full move.</span>
<a name="l00956"></a>00956   M_full_move_number = 0;
<a name="l00957"></a>00957   <span class="keywordflow">while</span> (iter != FEN.end() &amp;&amp;* iter != <span class="charliteral">&#39; &#39;</span>)
<a name="l00958"></a>00958   {
<a name="l00959"></a>00959     <span class="keywordflow">if</span> (!std::isdigit(*iter))
<a name="l00960"></a>00960       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00961"></a>00961     M_full_move_number = 10 * M_full_move_number +* iter++ - <span class="charliteral">&#39;0&#39;</span>;
<a name="l00962"></a>00962   }
<a name="l00963"></a>00963   <span class="keywordflow">if</span> (M_full_move_number == 0)
<a name="l00964"></a>00964     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00965"></a>00965   <span class="comment">// Success.</span>
<a name="l00966"></a>00966   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00967"></a>00967 }
<a name="l00968"></a>00968 
<a name="l00969"></a><a class="code" href="classcwchess_1_1ChessPosition.html#ae498d567bbec7c33d83de5c31a317291">00969</a> std::string <a class="code" href="classcwchess_1_1ChessPosition.html#ae498d567bbec7c33d83de5c31a317291" title="Return the FEN code for this position.">ChessPosition::FEN</a>(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00970"></a>00970 <span class="keyword"></span>{
<a name="l00971"></a>00971   std::ostringstream fen;
<a name="l00972"></a>00972   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> row = 7; row &gt;= 0; --row)
<a name="l00973"></a>00973   {
<a name="l00974"></a>00974     <span class="keywordtype">int</span> empty_count = 0;
<a name="l00975"></a>00975     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> col = 0; col &lt;= 7; ++col)
<a name="l00976"></a>00976     {
<a name="l00977"></a>00977       <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> code = M_pieces[<a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a>(col, row)].code();
<a name="l00978"></a>00978       <span class="keywordflow">if</span> (code.<a class="code" href="classcwchess_1_1Code.html#ac9bd2b012eda487a8dea719dfae925d3" title="Returns TRUE if the code represents&amp; #39;nothing&amp;#39;.">is_nothing</a>())
<a name="l00979"></a>00979         ++empty_count;
<a name="l00980"></a>00980       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (empty_count &gt; 0)
<a name="l00981"></a>00981       {
<a name="l00982"></a>00982         fen &lt;&lt; (char)(<span class="charliteral">&#39;0&#39;</span> + empty_count);
<a name="l00983"></a>00983         empty_count = 0;
<a name="l00984"></a>00984       }
<a name="l00985"></a>00985       <span class="keywordflow">switch</span> (code())
<a name="l00986"></a>00986       {
<a name="l00987"></a>00987         <span class="keywordflow">case</span> (<a class="code" href="namespacecwchess.html#ad20629f8163cc1ca8bc712ba774c5ba8" title="The underlaying integral value of color&amp; #39;black&amp;#39;.">black_bits</a>|<a class="code" href="namespacecwchess.html#aa1d2a1c03b6f090d8f03a8e0abf47149" title="The underlaying integral value of type&amp; #39;pawn&amp;#39;.">pawn_bits</a>):
<a name="l00988"></a>00988           fen &lt;&lt; <span class="charliteral">&#39;p&#39;</span>;
<a name="l00989"></a>00989           <span class="keywordflow">break</span>;
<a name="l00990"></a>00990         <span class="keywordflow">case</span> (<a class="code" href="namespacecwchess.html#ad20629f8163cc1ca8bc712ba774c5ba8" title="The underlaying integral value of color&amp; #39;black&amp;#39;.">black_bits</a>|<a class="code" href="namespacecwchess.html#aee3e5ab23dff55cc72e79bc2a7af1f27" title="The underlaying integral value of type&amp; #39;rook&amp;#39;.">rook_bits</a>):
<a name="l00991"></a>00991           fen &lt;&lt; <span class="charliteral">&#39;r&#39;</span>;
<a name="l00992"></a>00992           <span class="keywordflow">break</span>;
<a name="l00993"></a>00993         <span class="keywordflow">case</span> (<a class="code" href="namespacecwchess.html#ad20629f8163cc1ca8bc712ba774c5ba8" title="The underlaying integral value of color&amp; #39;black&amp;#39;.">black_bits</a>|<a class="code" href="namespacecwchess.html#a7924988a8664b174aed31ec9c5641b8d" title="The underlaying integral value of type&amp; #39;knight&amp;#39;.">knight_bits</a>):
<a name="l00994"></a>00994           fen &lt;&lt; <span class="charliteral">&#39;n&#39;</span>;
<a name="l00995"></a>00995           <span class="keywordflow">break</span>;
<a name="l00996"></a>00996         <span class="keywordflow">case</span> (<a class="code" href="namespacecwchess.html#ad20629f8163cc1ca8bc712ba774c5ba8" title="The underlaying integral value of color&amp; #39;black&amp;#39;.">black_bits</a>|<a class="code" href="namespacecwchess.html#a552144ab0ca73853eeaf4db7eb1752a3" title="The underlaying integral value of type&amp; #39;bishop&amp;#39;.">bishop_bits</a>):
<a name="l00997"></a>00997           fen &lt;&lt; <span class="charliteral">&#39;b&#39;</span>;
<a name="l00998"></a>00998           <span class="keywordflow">break</span>;
<a name="l00999"></a>00999         <span class="keywordflow">case</span> (<a class="code" href="namespacecwchess.html#ad20629f8163cc1ca8bc712ba774c5ba8" title="The underlaying integral value of color&amp; #39;black&amp;#39;.">black_bits</a>|<a class="code" href="namespacecwchess.html#adab49cfc55425a26aff6958a85ce1ff6" title="The underlaying integral value of type&amp; #39;queen&amp;#39;.">queen_bits</a>):
<a name="l01000"></a>01000           fen &lt;&lt; <span class="charliteral">&#39;q&#39;</span>;
<a name="l01001"></a>01001           <span class="keywordflow">break</span>;
<a name="l01002"></a>01002         <span class="keywordflow">case</span> (<a class="code" href="namespacecwchess.html#ad20629f8163cc1ca8bc712ba774c5ba8" title="The underlaying integral value of color&amp; #39;black&amp;#39;.">black_bits</a>|<a class="code" href="namespacecwchess.html#a2029e96ee5e55a229499d823a87590d5" title="The underlaying integral value of type&amp; #39;king&amp;#39;.">king_bits</a>):
<a name="l01003"></a>01003           fen &lt;&lt; <span class="charliteral">&#39;k&#39;</span>;
<a name="l01004"></a>01004           <span class="keywordflow">break</span>;
<a name="l01005"></a>01005         <span class="keywordflow">case</span> (<a class="code" href="namespacecwchess.html#aa757d883d20f98ab8210f5cdc87af4a3" title="The underlaying integral value of color&amp; #39;white&amp;#39;.">white_bits</a>|<a class="code" href="namespacecwchess.html#aa1d2a1c03b6f090d8f03a8e0abf47149" title="The underlaying integral value of type&amp; #39;pawn&amp;#39;.">pawn_bits</a>):
<a name="l01006"></a>01006           fen &lt;&lt; <span class="charliteral">&#39;P&#39;</span>;
<a name="l01007"></a>01007           <span class="keywordflow">break</span>;
<a name="l01008"></a>01008         <span class="keywordflow">case</span> (<a class="code" href="namespacecwchess.html#aa757d883d20f98ab8210f5cdc87af4a3" title="The underlaying integral value of color&amp; #39;white&amp;#39;.">white_bits</a>|<a class="code" href="namespacecwchess.html#aee3e5ab23dff55cc72e79bc2a7af1f27" title="The underlaying integral value of type&amp; #39;rook&amp;#39;.">rook_bits</a>):
<a name="l01009"></a>01009           fen &lt;&lt; <span class="charliteral">&#39;R&#39;</span>;
<a name="l01010"></a>01010           <span class="keywordflow">break</span>;
<a name="l01011"></a>01011         <span class="keywordflow">case</span> (<a class="code" href="namespacecwchess.html#aa757d883d20f98ab8210f5cdc87af4a3" title="The underlaying integral value of color&amp; #39;white&amp;#39;.">white_bits</a>|<a class="code" href="namespacecwchess.html#a7924988a8664b174aed31ec9c5641b8d" title="The underlaying integral value of type&amp; #39;knight&amp;#39;.">knight_bits</a>):
<a name="l01012"></a>01012           fen &lt;&lt; <span class="charliteral">&#39;N&#39;</span>;
<a name="l01013"></a>01013           <span class="keywordflow">break</span>;
<a name="l01014"></a>01014         <span class="keywordflow">case</span> (<a class="code" href="namespacecwchess.html#aa757d883d20f98ab8210f5cdc87af4a3" title="The underlaying integral value of color&amp; #39;white&amp;#39;.">white_bits</a>|<a class="code" href="namespacecwchess.html#a552144ab0ca73853eeaf4db7eb1752a3" title="The underlaying integral value of type&amp; #39;bishop&amp;#39;.">bishop_bits</a>):
<a name="l01015"></a>01015           fen &lt;&lt; <span class="charliteral">&#39;B&#39;</span>;
<a name="l01016"></a>01016           <span class="keywordflow">break</span>;
<a name="l01017"></a>01017         <span class="keywordflow">case</span> (<a class="code" href="namespacecwchess.html#aa757d883d20f98ab8210f5cdc87af4a3" title="The underlaying integral value of color&amp; #39;white&amp;#39;.">white_bits</a>|<a class="code" href="namespacecwchess.html#adab49cfc55425a26aff6958a85ce1ff6" title="The underlaying integral value of type&amp; #39;queen&amp;#39;.">queen_bits</a>):
<a name="l01018"></a>01018           fen &lt;&lt; <span class="charliteral">&#39;Q&#39;</span>;
<a name="l01019"></a>01019           <span class="keywordflow">break</span>;
<a name="l01020"></a>01020         <span class="keywordflow">case</span> (<a class="code" href="namespacecwchess.html#aa757d883d20f98ab8210f5cdc87af4a3" title="The underlaying integral value of color&amp; #39;white&amp;#39;.">white_bits</a>|<a class="code" href="namespacecwchess.html#a2029e96ee5e55a229499d823a87590d5" title="The underlaying integral value of type&amp; #39;king&amp;#39;.">king_bits</a>):
<a name="l01021"></a>01021           fen &lt;&lt; <span class="charliteral">&#39;K&#39;</span>;
<a name="l01022"></a>01022           <span class="keywordflow">break</span>;
<a name="l01023"></a>01023       }
<a name="l01024"></a>01024     }
<a name="l01025"></a>01025     <span class="keywordflow">if</span> (empty_count &gt; 0)
<a name="l01026"></a>01026       fen &lt;&lt; (char)(<span class="charliteral">&#39;0&#39;</span> + empty_count);
<a name="l01027"></a>01027     <span class="keywordflow">if</span> (row != 0)
<a name="l01028"></a>01028       fen &lt;&lt; <span class="charliteral">&#39;/&#39;</span>;
<a name="l01029"></a>01029   }
<a name="l01030"></a>01030   <span class="keywordflow">if</span> (M_to_move == <a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>)
<a name="l01031"></a>01031     fen &lt;&lt; <span class="stringliteral">&quot; w &quot;</span>;
<a name="l01032"></a>01032   <span class="keywordflow">else</span>
<a name="l01033"></a>01033     fen &lt;&lt; <span class="stringliteral">&quot; b &quot;</span>;
<a name="l01034"></a>01034   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags = 0;
<a name="l01035"></a>01035   <span class="keywordflow">if</span> (M_castle_flags.<a class="code" href="classcwchess_1_1CastleFlags.html#ad33ef250470fc5c29301e00fe3e4fef1" title="Return TRUE if color is still allowed to castle short (not taking into account checks).">can_castle_short</a>(<a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>))
<a name="l01036"></a>01036     flags |= 1;
<a name="l01037"></a>01037   <span class="keywordflow">if</span> (M_castle_flags.<a class="code" href="classcwchess_1_1CastleFlags.html#a3f4986eb202c3bff8c02aedff97b437f" title="Return TRUE if color is still allowed to castle long (not taking into account checks).">can_castle_long</a>(<a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>))
<a name="l01038"></a>01038     flags |= 2;
<a name="l01039"></a>01039   <span class="keywordflow">if</span> (M_castle_flags.<a class="code" href="classcwchess_1_1CastleFlags.html#ad33ef250470fc5c29301e00fe3e4fef1" title="Return TRUE if color is still allowed to castle short (not taking into account checks).">can_castle_short</a>(<a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>))
<a name="l01040"></a>01040     flags |= 4;
<a name="l01041"></a>01041   <span class="keywordflow">if</span> (M_castle_flags.<a class="code" href="classcwchess_1_1CastleFlags.html#a3f4986eb202c3bff8c02aedff97b437f" title="Return TRUE if color is still allowed to castle long (not taking into account checks).">can_castle_long</a>(<a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>))
<a name="l01042"></a>01042     flags |= 8;
<a name="l01043"></a>01043   <span class="keywordflow">if</span> (flags == 0)
<a name="l01044"></a>01044     fen &lt;&lt; <span class="charliteral">&#39;-&#39;</span>;
<a name="l01045"></a>01045   <span class="keywordflow">else</span>
<a name="l01046"></a>01046   {
<a name="l01047"></a>01047     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mask = 1; mask &lt;= 8; mask &lt;&lt;= 1)
<a name="l01048"></a>01048     {
<a name="l01049"></a>01049       <span class="keywordflow">if</span> ((flags &amp; mask))
<a name="l01050"></a>01050       {
<a name="l01051"></a>01051         <span class="keywordflow">switch</span> (mask)
<a name="l01052"></a>01052         {
<a name="l01053"></a>01053           <span class="keywordflow">case</span> 1:
<a name="l01054"></a>01054             fen &lt;&lt; <span class="charliteral">&#39;K&#39;</span>;
<a name="l01055"></a>01055             <span class="keywordflow">break</span>;
<a name="l01056"></a>01056           <span class="keywordflow">case</span> 2:
<a name="l01057"></a>01057             fen &lt;&lt; <span class="charliteral">&#39;Q&#39;</span>;
<a name="l01058"></a>01058             <span class="keywordflow">break</span>;
<a name="l01059"></a>01059           <span class="keywordflow">case</span> 4:
<a name="l01060"></a>01060             fen &lt;&lt; <span class="charliteral">&#39;k&#39;</span>;
<a name="l01061"></a>01061             <span class="keywordflow">break</span>;
<a name="l01062"></a>01062           <span class="keywordflow">case</span> 8:
<a name="l01063"></a>01063             fen &lt;&lt; <span class="charliteral">&#39;q&#39;</span>;
<a name="l01064"></a>01064             <span class="keywordflow">break</span>;
<a name="l01065"></a>01065         }
<a name="l01066"></a>01066       }
<a name="l01067"></a>01067     }
<a name="l01068"></a>01068   }
<a name="l01069"></a>01069   fen &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; M_en_passant.FEN4() &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; (int)M_half_move_clock &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; (<span class="keywordtype">int</span>)M_full_move_number;
<a name="l01070"></a>01070   <span class="keywordflow">return</span> fen.str();
<a name="l01071"></a>01071 }
<a name="l01072"></a>01072 
<a name="l01073"></a><a class="code" href="classcwchess_1_1ChessPosition.html#aa5893a55201a592bb4e5ff7fa00fdb26">01073</a> <span class="keywordtype">bool</span> <a class="code" href="classcwchess_1_1ChessPosition.html#aa5893a55201a592bb4e5ff7fa00fdb26" title="Explicity set the en passant information.">ChessPosition::set_en_passant</a>(<a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> <span class="keyword">const</span>&amp; index)
<a name="l01074"></a>01074 {
<a name="l01075"></a>01075   <span class="keywordtype">int</span> offset;
<a name="l01076"></a>01076   <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> code;
<a name="l01077"></a>01077   <span class="keywordflow">if</span> (index.<a class="code" href="classcwchess_1_1Index.html#a7ea9520a22986f986f6e9dd818b8ad90" title="Returns the row.">row</a>() == 2)
<a name="l01078"></a>01078   {
<a name="l01079"></a>01079     code = <a class="code" href="namespacecwchess.html#acd891cc1843e2bce6978c194647c928a" title="A constant representing a black pawn.">black_pawn</a>;
<a name="l01080"></a>01080     offset = 8;
<a name="l01081"></a>01081     <a class="code" href="classcwchess_1_1ChessPosition.html#ada921b0f214849c994b0cfdc0b2cb908" title="Return whose turn it is.">to_move</a>(<a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>);
<a name="l01082"></a>01082   }
<a name="l01083"></a>01083   <span class="keywordflow">else</span>
<a name="l01084"></a>01084   {
<a name="l01085"></a>01085     code = <a class="code" href="namespacecwchess.html#acbefae1953a03a417fcf2b5c9e3b55a6" title="A constant representing a white pawn.">white_pawn</a>;
<a name="l01086"></a>01086     offset = -8;
<a name="l01087"></a>01087     <a class="code" href="classcwchess_1_1ChessPosition.html#ada921b0f214849c994b0cfdc0b2cb908" title="Return whose turn it is.">to_move</a>(<a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>);
<a name="l01088"></a>01088   }
<a name="l01089"></a>01089   M_en_passant = <a class="code" href="classcwchess_1_1EnPassant.html" title="An object representing en passant information.">EnPassant</a>(index);
<a name="l01090"></a>01090   <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> index_of_only_neighboring_pawn = <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>;
<a name="l01091"></a>01091   <span class="keywordtype">bool</span> possible = <span class="keyword">false</span>;
<a name="l01092"></a>01092   <span class="keywordflow">if</span> (index.<a class="code" href="classcwchess_1_1Index.html#aeeeece4a4238c83b806ea83a45db322c" title="Returns the column.">col</a>() &gt; 0 &amp;&amp; M_pieces[index + offset - 1] == code)
<a name="l01093"></a>01093   {
<a name="l01094"></a>01094     possible = <span class="keyword">true</span>;
<a name="l01095"></a>01095     index_of_only_neighboring_pawn = index + offset - 1;
<a name="l01096"></a>01096     M_pieces[index_of_only_neighboring_pawn].set_can_take_king_side();
<a name="l01097"></a>01097   }
<a name="l01098"></a>01098   <span class="keywordflow">if</span> (index.<a class="code" href="classcwchess_1_1Index.html#aeeeece4a4238c83b806ea83a45db322c" title="Returns the column.">col</a>() &lt; 7 &amp;&amp; M_pieces[index + offset + 1] == code)
<a name="l01099"></a>01099   {
<a name="l01100"></a>01100     possible = <span class="keyword">true</span>;
<a name="l01101"></a>01101     <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> right_pawn_index = index + offset + 1;
<a name="l01102"></a>01102     M_pieces[right_pawn_index].set_can_take_queen_side();
<a name="l01103"></a>01103     <span class="keywordflow">if</span> (index_of_only_neighboring_pawn != <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>)
<a name="l01104"></a>01104       index_of_only_neighboring_pawn = <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>;
<a name="l01105"></a>01105     <span class="keywordflow">else</span>
<a name="l01106"></a>01106       index_of_only_neighboring_pawn = right_pawn_index;
<a name="l01107"></a>01107   }
<a name="l01108"></a>01108   <span class="keywordflow">if</span> (index_of_only_neighboring_pawn != <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>)
<a name="l01109"></a>01109   {
<a name="l01110"></a>01110     <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> mask = <a class="code" href="namespacecwchess.html#a61b5311c7bc3b89a4c252d76dcfdbd40" title="Convert Index to a mask_t.">index2mask</a>(index_of_only_neighboring_pawn);
<a name="l01111"></a>01111     <span class="keywordflow">if</span> (M_attackers[M_to_move].test(mask))
<a name="l01112"></a>01112     {
<a name="l01113"></a>01113       <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> king_code(M_to_move, <a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>);
<a name="l01114"></a>01114       mask = M_bitboards[king_code]();
<a name="l01115"></a>01115       <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> king_index(<a class="code" href="namespacecwchess.html#a556a7930206c9c994411661cd2896dd1" title="Convert a single bit mask into it&amp;#39;s Index.">mask2index</a>(mask));
<a name="l01116"></a>01116       <a class="code" href="structcwchess_1_1Direction.html">Direction</a> direction(direction_from_to(king_index, index_of_only_neighboring_pawn));
<a name="l01117"></a>01117       <span class="keywordflow">if</span> (direction.is_horizontal())
<a name="l01118"></a>01118       {
<a name="l01119"></a>01119         <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> line(direction.<a class="code" href="structcwchess_1_1Direction.html#ac774c9ba1cc29045849a85fd7fdd89f8" title="Return a BitBoard with all squares in this direction.">from</a>(king_index));
<a name="l01120"></a>01120         M_pinning[M_to_move].reset(line);
<a name="l01121"></a>01121         update_pinning(king_code, king_index, mask, direction, (M_bitboards[<a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>] | M_bitboards[<a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>]) &amp; line);
<a name="l01122"></a>01122         M_en_passant.pinned_set();
<a name="l01123"></a>01123       }
<a name="l01124"></a>01124     }
<a name="l01125"></a>01125   }
<a name="l01126"></a>01126   <span class="keywordflow">return</span> possible;
<a name="l01127"></a>01127 }
<a name="l01128"></a>01128 
<a name="l01129"></a>01129 <span class="keyword">enum</span> up_and_right {
<a name="l01130"></a>01130   right = 1,
<a name="l01131"></a>01131   up_left = 7,
<a name="l01132"></a>01132   up = 8,
<a name="l01133"></a>01133   up_right = 9,
<a name="l01134"></a>01134 };
<a name="l01135"></a>01135 
<a name="l01136"></a>01136 <span class="keyword">enum</span> down_and_left {
<a name="l01137"></a>01137   left = 1,
<a name="l01138"></a>01138   down_right = 7,
<a name="l01139"></a>01139   down = 8,
<a name="l01140"></a>01140   down_left = 9
<a name="l01141"></a>01141 };
<a name="l01142"></a>01142 
<a name="l01143"></a>01143 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01144"></a>01144 <span class="keyword">inline</span> <span class="keywordtype">void</span> move(mask_t&amp; m, T);
<a name="l01145"></a>01145 
<a name="l01146"></a>01146 <span class="keyword">template</span> &lt;&gt;
<a name="l01147"></a>01147 <span class="keyword">inline</span> <span class="keywordtype">void</span> move&lt;up_and_right&gt;(mask_t&amp; m, up_and_right offset)
<a name="l01148"></a>01148 {
<a name="l01149"></a>01149   m &lt;&lt;= offset;
<a name="l01150"></a>01150 }
<a name="l01151"></a>01151 
<a name="l01152"></a>01152 <span class="keyword">template</span> &lt;&gt;
<a name="l01153"></a>01153 <span class="keyword">inline</span> <span class="keywordtype">void</span> move&lt;down_and_left&gt;(mask_t&amp; m, down_and_left offset)
<a name="l01154"></a>01154 {
<a name="l01155"></a>01155   m &gt;&gt;= offset;
<a name="l01156"></a>01156 }
<a name="l01157"></a>01157 
<a name="l01158"></a>01158 BitBoard ChessPosition::all_pieces_minus_bishop_movers(Color <span class="keyword">const</span>&amp; color, Index <span class="keyword">const</span>&amp; index)<span class="keyword"> const</span>
<a name="l01159"></a>01159 <span class="keyword"></span>{
<a name="l01160"></a>01160   BitBoard result(M_bitboards[<a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>] | M_bitboards[<a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>]);     <span class="comment">// A bitboard with bits set on every square where there is any piece.</span>
<a name="l01161"></a>01161   <span class="keywordflow">if</span> (color.is_white())
<a name="l01162"></a>01162   {
<a name="l01163"></a>01163     result.reset(M_bitboards[<a class="code" href="namespacecwchess.html#a5db6135d88d56a6f015054d557110238" title="A constant representing a white queen.">white_queen</a>]);     <span class="comment">// Remove the queens and bishop, because we can defend through them.</span>
<a name="l01164"></a>01164     result.reset(M_bitboards[<a class="code" href="namespacecwchess.html#a1cc11c4c834d4a54c14db5d700a403aa" title="A constant representing a white bishop.">white_bishop</a>]);
<a name="l01165"></a>01165 
<a name="l01166"></a>01166     BitBoard north_west_pawn(M_bitboards[<a class="code" href="namespacecwchess.html#acbefae1953a03a417fcf2b5c9e3b55a6" title="A constant representing a white pawn.">white_pawn</a>]);
<a name="l01167"></a>01167     north_west_pawn&amp; = <a class="code" href="structDirection.html">Direction</a>(north_west).from(index);
<a name="l01168"></a>01168     <span class="keywordflow">if</span> (north_west_pawn.test())
<a name="l01169"></a>01169     {
<a name="l01170"></a>01170       Index res(<a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a>);
<a name="l01171"></a>01171       res.next_bit_in(north_west_pawn());
<a name="l01172"></a>01172       result.reset(res);
<a name="l01173"></a>01173       <span class="keywordflow">if</span> (res.col() != 0)
<a name="l01174"></a>01174       {
<a name="l01175"></a>01175         res += north_west.offset;
<a name="l01176"></a>01176         result.set(res);
<a name="l01177"></a>01177       }
<a name="l01178"></a>01178     }
<a name="l01179"></a>01179     BitBoard north_east_pawn(M_bitboards[<a class="code" href="namespacecwchess.html#acbefae1953a03a417fcf2b5c9e3b55a6" title="A constant representing a white pawn.">white_pawn</a>]);
<a name="l01180"></a>01180     north_east_pawn&amp; = <a class="code" href="structDirection.html">Direction</a>(north_east).from(index);
<a name="l01181"></a>01181     <span class="keywordflow">if</span> (north_east_pawn.test())
<a name="l01182"></a>01182     {
<a name="l01183"></a>01183       Index res(<a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a>);
<a name="l01184"></a>01184       res.next_bit_in(north_east_pawn());
<a name="l01185"></a>01185       result.reset(res);
<a name="l01186"></a>01186       <span class="keywordflow">if</span> (res.col() != 7)
<a name="l01187"></a>01187       {
<a name="l01188"></a>01188         res += north_east.offset;
<a name="l01189"></a>01189         result.set(res);
<a name="l01190"></a>01190       }
<a name="l01191"></a>01191     }
<a name="l01192"></a>01192   }
<a name="l01193"></a>01193   <span class="keywordflow">else</span>
<a name="l01194"></a>01194   {
<a name="l01195"></a>01195     result.reset(M_bitboards[<a class="code" href="namespacecwchess.html#a1028d21746b2cbde22c894840684b645" title="A constant representing a black queen;.">black_queen</a>]);     <span class="comment">// Remove the queens and bishop, because we can defend through them.</span>
<a name="l01196"></a>01196     result.reset(M_bitboards[<a class="code" href="namespacecwchess.html#aa76f3519a505c55716fd0aca37781ecc" title="A constant representing a black bishop;.">black_bishop</a>]);
<a name="l01197"></a>01197 
<a name="l01198"></a>01198     BitBoard south_west_pawn(M_bitboards[<a class="code" href="namespacecwchess.html#acd891cc1843e2bce6978c194647c928a" title="A constant representing a black pawn.">black_pawn</a>]);
<a name="l01199"></a>01199     south_west_pawn&amp; = <a class="code" href="structDirection.html">Direction</a>(south_west).from(index);
<a name="l01200"></a>01200     <span class="keywordflow">if</span> (south_west_pawn.test())
<a name="l01201"></a>01201     {
<a name="l01202"></a>01202       Index res(<a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>);
<a name="l01203"></a>01203       res.prev_bit_in(south_west_pawn());
<a name="l01204"></a>01204       result.reset(res);
<a name="l01205"></a>01205       <span class="keywordflow">if</span> (res.col() != 0)
<a name="l01206"></a>01206       {
<a name="l01207"></a>01207         res += south_west.offset;
<a name="l01208"></a>01208         result.set(res);
<a name="l01209"></a>01209       }
<a name="l01210"></a>01210     }
<a name="l01211"></a>01211     BitBoard south_east_pawn(M_bitboards[<a class="code" href="namespacecwchess.html#acd891cc1843e2bce6978c194647c928a" title="A constant representing a black pawn.">black_pawn</a>]);
<a name="l01212"></a>01212     south_east_pawn&amp; = <a class="code" href="structDirection.html">Direction</a>(south_east).from(index);
<a name="l01213"></a>01213     <span class="keywordflow">if</span> (south_east_pawn.test())
<a name="l01214"></a>01214     {
<a name="l01215"></a>01215       Index res(<a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>);
<a name="l01216"></a>01216       res.prev_bit_in(south_east_pawn());
<a name="l01217"></a>01217       result.reset(res);
<a name="l01218"></a>01218       <span class="keywordflow">if</span> (res.col() != 7)
<a name="l01219"></a>01219       {
<a name="l01220"></a>01220         res += south_east.offset;
<a name="l01221"></a>01221         result.set(res);
<a name="l01222"></a>01222       }
<a name="l01223"></a>01223     }
<a name="l01224"></a>01224   }
<a name="l01225"></a>01225   <span class="keywordflow">return</span> result;
<a name="l01226"></a>01226 }
<a name="l01227"></a>01227 
<a name="l01228"></a><a class="code" href="classcwchess_1_1ChessPosition.html#adb1463cd7c4aacd46fe836793ccfa1be">01228</a> <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> <a class="code" href="classcwchess_1_1ChessPosition.html#adb1463cd7c4aacd46fe836793ccfa1be" title="Return a BitBoard with bits set for each square that a piece defends, or would defend if an exchange ...">ChessPosition::defendables</a>(<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> <span class="keyword">const</span>&amp; code, <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> <span class="keyword">const</span>&amp; index, <span class="keywordtype">bool</span>&amp; battery)<span class="keyword"> const</span>
<a name="l01229"></a>01229 <span class="keyword"></span>{
<a name="l01230"></a>01230   <a class="code" href="classcwchess_1_1Color.html" title="A color (black or white).">Color</a> color = code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>();                                           <span class="comment">// The color of the piece.</span>
<a name="l01231"></a>01231   <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> pos = <a class="code" href="namespacecwchess.html#a61b5311c7bc3b89a4c252d76dcfdbd40" title="Convert Index to a mask_t.">index2mask</a>(index);                                       <span class="comment">// The current position of the piece.</span>
<a name="l01232"></a>01232   <span class="keywordflow">switch</span>(code.<a class="code" href="classcwchess_1_1Code.html#a071640067d0b914b055a1818d368f4cd" title="Return the Type of this Code.">type</a>()())
<a name="l01233"></a>01233   {
<a name="l01234"></a>01234     <span class="keywordflow">case</span> <a class="code" href="namespacecwchess.html#a31acd5f9f24ccda6aff23704083e2648" title="The underlaying integral value of type&amp; #39;nothing&amp;#39;.">nothing_bits</a>:          <span class="comment">// This should never be called, but return an empty bitboard anyway.</span>
<a name="l01235"></a>01235     {
<a name="l01236"></a>01236       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> result;
<a name="l01237"></a>01237       result.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>();
<a name="l01238"></a>01238       <span class="keywordflow">return</span> result;
<a name="l01239"></a>01239     }
<a name="l01240"></a>01240     <span class="keywordflow">case</span> <a class="code" href="namespacecwchess.html#aa1d2a1c03b6f090d8f03a8e0abf47149" title="The underlaying integral value of type&amp; #39;pawn&amp;#39;.">pawn_bits</a>:
<a name="l01241"></a>01241     {
<a name="l01242"></a>01242       <span class="keywordtype">int</span> col = index.<a class="code" href="classcwchess_1_1Index.html#aeeeece4a4238c83b806ea83a45db322c" title="Returns the column.">col</a>();
<a name="l01243"></a>01243       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> result((color == <a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>) ? (pos &lt;&lt; 7) | (pos &lt;&lt; 9) : (pos &gt;&gt; 9) | (pos &gt;&gt; 7));
<a name="l01244"></a>01244       <span class="keywordflow">if</span> (__builtin_expect(col == 0, <span class="keyword">false</span>))
<a name="l01245"></a>01245         result.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>(<a class="code" href="namespacecwchess.html#adfb6784a238922e3b2a2e2c01269deb9" title="The h-file.">file_h</a>);
<a name="l01246"></a>01246       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (__builtin_expect(col == 7, <span class="keyword">false</span>))
<a name="l01247"></a>01247         result.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>(<a class="code" href="namespacecwchess.html#a3d47283c624760531b65ae0e88e40be9" title="The a-file.">file_a</a>);
<a name="l01248"></a>01248       <span class="keywordflow">return</span> result;
<a name="l01249"></a>01249     }
<a name="l01250"></a>01250     <span class="keywordflow">case</span> <a class="code" href="namespacecwchess.html#a7924988a8664b174aed31ec9c5641b8d" title="The underlaying integral value of type&amp; #39;knight&amp;#39;.">knight_bits</a>:
<a name="l01251"></a>01251     {
<a name="l01252"></a>01252       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> result(candidates_table[<a class="code" href="classcwchess_1_1ChessPosition.html#a3a4bfb81ed0560b839522ccda16476d9" title="Return the offset into the candidates_table for type type.">candidates_table_offset</a>(<a class="code" href="namespacecwchess.html#abf2c4ea392fe31bf861f9eb143ca299a" title="A constant representing a knight.">knight</a>) + index()]);
<a name="l01253"></a>01253       <span class="keywordflow">return</span> result;
<a name="l01254"></a>01254     }
<a name="l01255"></a>01255     <span class="keywordflow">case</span> <a class="code" href="namespacecwchess.html#a2029e96ee5e55a229499d823a87590d5" title="The underlaying integral value of type&amp; #39;king&amp;#39;.">king_bits</a>:
<a name="l01256"></a>01256     {
<a name="l01257"></a>01257       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> result(candidates_table[<a class="code" href="classcwchess_1_1ChessPosition.html#a3a4bfb81ed0560b839522ccda16476d9" title="Return the offset into the candidates_table for type type.">candidates_table_offset</a>(<a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>) + index()]);
<a name="l01258"></a>01258       <span class="keywordflow">return</span> result;
<a name="l01259"></a>01259     }
<a name="l01260"></a>01260     <span class="keywordflow">case</span> <a class="code" href="namespacecwchess.html#aee3e5ab23dff55cc72e79bc2a7af1f27" title="The underlaying integral value of type&amp; #39;rook&amp;#39;.">rook_bits</a>:
<a name="l01261"></a>01261     {
<a name="l01262"></a>01262       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> all_pieces_minus_rook_movers(M_bitboards[<a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>] | M_bitboards[<a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>]);
<a name="l01263"></a>01263       <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> queen_code(color, <a class="code" href="namespacecwchess.html#ad3a2fc51450ffe511826ea0ddc6781ec" title="A constant representing a queen.">queen</a>);
<a name="l01264"></a>01264       <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> rook_code(color, <a class="code" href="namespacecwchess.html#a4ff984a16c54b56749db5209e31b29f9" title="A constant representing a rook.">rook</a>);
<a name="l01265"></a>01265       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> other_attackers(M_bitboards[queen_code] | M_bitboards[rook_code]);
<a name="l01266"></a>01266       all_pieces_minus_rook_movers.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>(other_attackers);      <span class="comment">// Remove the queens and rooks, because we can defend through them.</span>
<a name="l01267"></a>01267 
<a name="l01268"></a>01268       <span class="comment">// Find reachable squares above the rook.</span>
<a name="l01269"></a>01269       <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> block = all_pieces_minus_rook_movers();
<a name="l01270"></a>01270       <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> probe = pos;
<a name="l01271"></a>01271       <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> <a class="code" href="classcwchess_1_1ChessPosition.html#aee80b4a992db9fbbb10c380d7d1dc612" title="Return a BitBoard with bits set for each square that a piece can reach in one move.">reachables</a> = 0;
<a name="l01272"></a>01272       <span class="keywordflow">do</span>
<a name="l01273"></a>01273       {
<a name="l01274"></a>01274         move(probe, up);
<a name="l01275"></a>01275         reachables |= probe;
<a name="l01276"></a>01276       }
<a name="l01277"></a>01277       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l01278"></a>01278 
<a name="l01279"></a>01279       <span class="comment">// Find reachable squares below the rook.</span>
<a name="l01280"></a>01280       probe = pos;
<a name="l01281"></a>01281       <span class="keywordflow">do</span>
<a name="l01282"></a>01282       {
<a name="l01283"></a>01283         move(probe, down);
<a name="l01284"></a>01284         reachables |= probe;
<a name="l01285"></a>01285       }
<a name="l01286"></a>01286       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l01287"></a>01287 
<a name="l01288"></a>01288       <span class="comment">// Result so far.</span>
<a name="l01289"></a>01289       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> result(reachables);
<a name="l01290"></a>01290 
<a name="l01291"></a>01291       <span class="comment">// Find reachable squares left of the rook.</span>
<a name="l01292"></a>01292       block |= <a class="code" href="namespacecwchess.html#adfb6784a238922e3b2a2e2c01269deb9" title="The h-file.">file_h</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l01293"></a>01293       probe = pos;
<a name="l01294"></a>01294       <span class="keywordflow">do</span>
<a name="l01295"></a>01295       {
<a name="l01296"></a>01296         move(probe, left);
<a name="l01297"></a>01297         reachables |= probe;
<a name="l01298"></a>01298       }
<a name="l01299"></a>01299       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l01300"></a>01300       reachables&amp; = ~<a class="code" href="namespacecwchess.html#adfb6784a238922e3b2a2e2c01269deb9" title="The h-file.">file_h</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l01301"></a>01301 
<a name="l01302"></a>01302       <span class="comment">// Update result.</span>
<a name="l01303"></a>01303       result |= reachables;
<a name="l01304"></a>01304 
<a name="l01305"></a>01305       <span class="comment">// Find reachable squares right of the rook.</span>
<a name="l01306"></a>01306       block = all_pieces_minus_rook_movers() | <a class="code" href="namespacecwchess.html#a3d47283c624760531b65ae0e88e40be9" title="The a-file.">file_a</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l01307"></a>01307       probe = pos;
<a name="l01308"></a>01308       <span class="keywordflow">do</span>
<a name="l01309"></a>01309       {
<a name="l01310"></a>01310         move(probe, right);
<a name="l01311"></a>01311         reachables |= probe;
<a name="l01312"></a>01312       }
<a name="l01313"></a>01313       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l01314"></a>01314       reachables&amp; = ~<a class="code" href="namespacecwchess.html#a3d47283c624760531b65ae0e88e40be9" title="The a-file.">file_a</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l01315"></a>01315 
<a name="l01316"></a>01316       result |= reachables;
<a name="l01317"></a>01317 
<a name="l01318"></a>01318       <span class="comment">// Do we need to update M_king_battery_attack_count?</span>
<a name="l01319"></a>01319       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> opposite_king_pos(M_bitboards[<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(color.<a class="code" href="classcwchess_1_1Color.html#ae7b69104c64e17005f5eb3ad277c4bdf" title="Return a Color object with the opposite color of this object.">opposite</a>(), <a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>)]);    <span class="comment">// The position of the opposite king.</span>
<a name="l01320"></a>01320       <span class="keywordflow">if</span> (__builtin_expect(
<a name="l01321"></a>01321           result.<a class="code" href="classcwchess_1_1BitBoard.html#acdb49d61eb3a825048c17627d1bc8f10" title="Test if any bit is set at all.">test</a>(opposite_king_pos) &amp;&amp;             <span class="comment">// Do we give check?</span>
<a name="l01322"></a>01322           result.<a class="code" href="classcwchess_1_1BitBoard.html#acdb49d61eb3a825048c17627d1bc8f10" title="Test if any bit is set at all.">test</a>(other_attackers),                 <span class="comment">// and block or look through another attacker?</span>
<a name="l01323"></a>01323           <span class="keyword">false</span>))
<a name="l01324"></a>01324       {
<a name="l01325"></a>01325         <span class="comment">// This other attacker could be on a different line than the one to the king.</span>
<a name="l01326"></a>01326         <span class="comment">// So, check if it is really on the line with the king or not.</span>
<a name="l01327"></a>01327         <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> king_index(<a class="code" href="namespacecwchess.html#a556a7930206c9c994411661cd2896dd1" title="Convert a single bit mask into it&amp;#39;s Index.">mask2index</a>(opposite_king_pos()));
<a name="l01328"></a>01328         <a class="code" href="structcwchess_1_1Direction.html">Direction</a> direction(direction_from_to(king_index, index));
<a name="l01329"></a>01329         <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> line(direction.<a class="code" href="structcwchess_1_1Direction.html#ac774c9ba1cc29045849a85fd7fdd89f8" title="Return a BitBoard with all squares in this direction.">from</a>(king_index));      <span class="comment">// All squares from checked king in the direction of the new attacker.</span>
<a name="l01330"></a>01330         line&amp; = result;                                 <span class="comment">// ... but only until the blocker on the other side.</span>
<a name="l01331"></a>01331         line&amp; = other_attackers;                        <span class="comment">// ... only possible other attackers.</span>
<a name="l01332"></a>01332         battery = line.<a class="code" href="classcwchess_1_1BitBoard.html#acdb49d61eb3a825048c17627d1bc8f10" title="Test if any bit is set at all.">test</a>();                          <span class="comment">// Battery exists if line is non-empty (note that &#39;result&#39; has &#39;index&#39; never set).</span>
<a name="l01333"></a>01333       }
<a name="l01334"></a>01334 
<a name="l01335"></a>01335       <span class="keywordflow">return</span> result;
<a name="l01336"></a>01336     }
<a name="l01337"></a>01337     <span class="keywordflow">case</span> <a class="code" href="namespacecwchess.html#a552144ab0ca73853eeaf4db7eb1752a3" title="The underlaying integral value of type&amp; #39;bishop&amp;#39;.">bishop_bits</a>:
<a name="l01338"></a>01338     {
<a name="l01339"></a>01339       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> all_pieces_minus_bishop_movers(this-&gt;all_pieces_minus_bishop_movers(color, index));
<a name="l01340"></a>01340 
<a name="l01341"></a>01341       <span class="comment">// Find reachable squares left below the bishop.</span>
<a name="l01342"></a>01342       <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> block = all_pieces_minus_bishop_movers() | <a class="code" href="namespacecwchess.html#adfb6784a238922e3b2a2e2c01269deb9" title="The h-file.">file_h</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l01343"></a>01343       <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> probe = pos;
<a name="l01344"></a>01344       <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> <a class="code" href="classcwchess_1_1ChessPosition.html#aee80b4a992db9fbbb10c380d7d1dc612" title="Return a BitBoard with bits set for each square that a piece can reach in one move.">reachables</a> = 0;
<a name="l01345"></a>01345       <span class="keywordflow">do</span>
<a name="l01346"></a>01346       {
<a name="l01347"></a>01347         move(probe, down_left);
<a name="l01348"></a>01348         reachables |= probe;
<a name="l01349"></a>01349       }
<a name="l01350"></a>01350       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l01351"></a>01351 
<a name="l01352"></a>01352       <span class="comment">// Find reachable squares left above the bishop.</span>
<a name="l01353"></a>01353       probe = pos;
<a name="l01354"></a>01354       <span class="keywordflow">do</span>
<a name="l01355"></a>01355       {
<a name="l01356"></a>01356         move(probe, up_left);
<a name="l01357"></a>01357         reachables |= probe;
<a name="l01358"></a>01358       }
<a name="l01359"></a>01359       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l01360"></a>01360       reachables&amp; = ~<a class="code" href="namespacecwchess.html#adfb6784a238922e3b2a2e2c01269deb9" title="The h-file.">file_h</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l01361"></a>01361 
<a name="l01362"></a>01362       <span class="comment">// Result so far.</span>
<a name="l01363"></a>01363       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> result(reachables);
<a name="l01364"></a>01364 
<a name="l01365"></a>01365       <span class="comment">// Find reachable squares right above the bishop;</span>
<a name="l01366"></a>01366       block = all_pieces_minus_bishop_movers() | <a class="code" href="namespacecwchess.html#a3d47283c624760531b65ae0e88e40be9" title="The a-file.">file_a</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l01367"></a>01367       probe = pos;
<a name="l01368"></a>01368       <span class="keywordflow">do</span>
<a name="l01369"></a>01369       {
<a name="l01370"></a>01370         move(probe, up_right);
<a name="l01371"></a>01371         reachables |= probe;
<a name="l01372"></a>01372       }
<a name="l01373"></a>01373       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l01374"></a>01374 
<a name="l01375"></a>01375       <span class="comment">// Find reachable squares right below the bishop;</span>
<a name="l01376"></a>01376       probe = pos;
<a name="l01377"></a>01377       <span class="keywordflow">do</span>
<a name="l01378"></a>01378       {
<a name="l01379"></a>01379         move(probe, down_right);
<a name="l01380"></a>01380         reachables |= probe;
<a name="l01381"></a>01381       }
<a name="l01382"></a>01382       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l01383"></a>01383       reachables&amp; = ~<a class="code" href="namespacecwchess.html#a3d47283c624760531b65ae0e88e40be9" title="The a-file.">file_a</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l01384"></a>01384 
<a name="l01385"></a>01385       result |= reachables;
<a name="l01386"></a>01386 
<a name="l01387"></a>01387       <span class="comment">// Do we need to update M_king_battery_attack_count?</span>
<a name="l01388"></a>01388       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> opposite_king_pos(M_bitboards[<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(color.<a class="code" href="classcwchess_1_1Color.html#ae7b69104c64e17005f5eb3ad277c4bdf" title="Return a Color object with the opposite color of this object.">opposite</a>(), <a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>)]);    <span class="comment">// The position of the opposite king.</span>
<a name="l01389"></a>01389       <span class="keywordflow">if</span> (__builtin_expect(result.<a class="code" href="classcwchess_1_1BitBoard.html#acdb49d61eb3a825048c17627d1bc8f10" title="Test if any bit is set at all.">test</a>(opposite_king_pos), <span class="keyword">false</span>))      <span class="comment">// Do we give check?</span>
<a name="l01390"></a>01390       {
<a name="l01391"></a>01391         <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> queen_code(color, <a class="code" href="namespacecwchess.html#ad3a2fc51450ffe511826ea0ddc6781ec" title="A constant representing a queen.">queen</a>);
<a name="l01392"></a>01392         <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> bishop_code(color, <a class="code" href="namespacecwchess.html#a3f166611f4301dafd492316030d6ecab" title="A constant representing a bishop.">bishop</a>);
<a name="l01393"></a>01393         <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> other_attackers(M_bitboards[queen_code] | M_bitboards[bishop_code]);
<a name="l01394"></a>01394         <span class="keywordflow">if</span> (result.<a class="code" href="classcwchess_1_1BitBoard.html#acdb49d61eb3a825048c17627d1bc8f10" title="Test if any bit is set at all.">test</a>(other_attackers))                               <span class="comment">// and block or look through another attacker?</span>
<a name="l01395"></a>01395         {
<a name="l01396"></a>01396           <span class="comment">// This other attacker could be on a different line than the one to the king.</span>
<a name="l01397"></a>01397           <span class="comment">// So, check if it is really on the line with the king or not.</span>
<a name="l01398"></a>01398           <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> king_index(<a class="code" href="namespacecwchess.html#a556a7930206c9c994411661cd2896dd1" title="Convert a single bit mask into it&amp;#39;s Index.">mask2index</a>(opposite_king_pos()));
<a name="l01399"></a>01399           <a class="code" href="structcwchess_1_1Direction.html">Direction</a> direction(direction_from_to(king_index, index));
<a name="l01400"></a>01400           <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> line(direction.<a class="code" href="structcwchess_1_1Direction.html#ac774c9ba1cc29045849a85fd7fdd89f8" title="Return a BitBoard with all squares in this direction.">from</a>(king_index));    <span class="comment">// All squares from checked king in the direction of the new attacker.</span>
<a name="l01401"></a>01401           line&amp; = result;                                       <span class="comment">// ... but only until the blocker on the other side.</span>
<a name="l01402"></a>01402           line&amp; = other_attackers;                      <span class="comment">// ... only possible other attackers.</span>
<a name="l01403"></a>01403           battery = line.<a class="code" href="classcwchess_1_1BitBoard.html#acdb49d61eb3a825048c17627d1bc8f10" title="Test if any bit is set at all.">test</a>();                                <span class="comment">// Battery exists if line is non-empty (note that &#39;result&#39; has &#39;index&#39; never set).</span>
<a name="l01404"></a>01404         }
<a name="l01405"></a>01405       }
<a name="l01406"></a>01406 
<a name="l01407"></a>01407       <span class="keywordflow">return</span> result;
<a name="l01408"></a>01408     }
<a name="l01409"></a>01409     <span class="keywordflow">case</span> <a class="code" href="namespacecwchess.html#adab49cfc55425a26aff6958a85ce1ff6" title="The underlaying integral value of type&amp; #39;queen&amp;#39;.">queen_bits</a>:
<a name="l01410"></a>01410     {
<a name="l01411"></a>01411       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> all_pieces_minus_bishop_movers(this-&gt;all_pieces_minus_bishop_movers(color, index));
<a name="l01412"></a>01412       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> all_pieces_minus_rook_movers(M_bitboards[<a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>] | M_bitboards[<a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>]);   <span class="comment">// A bitboard with bits set on every square where there is any piece.</span>
<a name="l01413"></a>01413       <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> queen_code(color, <a class="code" href="namespacecwchess.html#ad3a2fc51450ffe511826ea0ddc6781ec" title="A constant representing a queen.">queen</a>);
<a name="l01414"></a>01414       <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> rook_code(color, <a class="code" href="namespacecwchess.html#a4ff984a16c54b56749db5209e31b29f9" title="A constant representing a rook.">rook</a>);
<a name="l01415"></a>01415       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> other_rook_movers(M_bitboards[queen_code] | M_bitboards[rook_code]);
<a name="l01416"></a>01416       all_pieces_minus_rook_movers.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>(other_rook_movers);    <span class="comment">// Remove the queens and rooks, because we can defend through them.</span>
<a name="l01417"></a>01417 
<a name="l01418"></a>01418       <span class="comment">// Find reachable squares above the queen.</span>
<a name="l01419"></a>01419       <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> block = all_pieces_minus_rook_movers();
<a name="l01420"></a>01420       <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> probe = pos;
<a name="l01421"></a>01421       <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> <a class="code" href="classcwchess_1_1ChessPosition.html#aee80b4a992db9fbbb10c380d7d1dc612" title="Return a BitBoard with bits set for each square that a piece can reach in one move.">reachables</a> = 0;
<a name="l01422"></a>01422       <span class="keywordflow">do</span>
<a name="l01423"></a>01423       {
<a name="l01424"></a>01424         move(probe, up);
<a name="l01425"></a>01425         reachables |= probe;
<a name="l01426"></a>01426       }
<a name="l01427"></a>01427       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l01428"></a>01428 
<a name="l01429"></a>01429       <span class="comment">// Find reachable squares below the queen.</span>
<a name="l01430"></a>01430       probe = pos;
<a name="l01431"></a>01431       <span class="keywordflow">do</span>
<a name="l01432"></a>01432       {
<a name="l01433"></a>01433         move(probe, down);
<a name="l01434"></a>01434         reachables |= probe;
<a name="l01435"></a>01435       }
<a name="l01436"></a>01436       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l01437"></a>01437 
<a name="l01438"></a>01438       <span class="comment">// Result so far.</span>
<a name="l01439"></a>01439       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> result(reachables);
<a name="l01440"></a>01440 
<a name="l01441"></a>01441       <span class="comment">// Find reachable squares left of the queen.</span>
<a name="l01442"></a>01442       block |= <a class="code" href="namespacecwchess.html#adfb6784a238922e3b2a2e2c01269deb9" title="The h-file.">file_h</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l01443"></a>01443       probe = pos;
<a name="l01444"></a>01444       <span class="keywordflow">do</span>
<a name="l01445"></a>01445       {
<a name="l01446"></a>01446         move(probe, left);
<a name="l01447"></a>01447         reachables |= probe;
<a name="l01448"></a>01448       }
<a name="l01449"></a>01449       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l01450"></a>01450 
<a name="l01451"></a>01451       <span class="comment">// And left, but diagonal.</span>
<a name="l01452"></a>01452       block = all_pieces_minus_bishop_movers() | <a class="code" href="namespacecwchess.html#adfb6784a238922e3b2a2e2c01269deb9" title="The h-file.">file_h</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l01453"></a>01453 
<a name="l01454"></a>01454       <span class="comment">// Find reachable squares left below the queen.</span>
<a name="l01455"></a>01455       probe = pos;
<a name="l01456"></a>01456       <span class="keywordflow">do</span>
<a name="l01457"></a>01457       {
<a name="l01458"></a>01458         move(probe, down_left);
<a name="l01459"></a>01459         reachables |= probe;
<a name="l01460"></a>01460       }
<a name="l01461"></a>01461       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l01462"></a>01462 
<a name="l01463"></a>01463       <span class="comment">// Find reachable squares left above the bishop.</span>
<a name="l01464"></a>01464       probe = pos;
<a name="l01465"></a>01465       <span class="keywordflow">do</span>
<a name="l01466"></a>01466       {
<a name="l01467"></a>01467         move(probe, up_left);
<a name="l01468"></a>01468         reachables |= probe;
<a name="l01469"></a>01469       }
<a name="l01470"></a>01470       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l01471"></a>01471       reachables&amp; = ~<a class="code" href="namespacecwchess.html#adfb6784a238922e3b2a2e2c01269deb9" title="The h-file.">file_h</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l01472"></a>01472 
<a name="l01473"></a>01473       <span class="comment">// Update result.</span>
<a name="l01474"></a>01474       result |= reachables;
<a name="l01475"></a>01475 
<a name="l01476"></a>01476       <span class="comment">// Find reachable squares right of the queen.</span>
<a name="l01477"></a>01477       block = all_pieces_minus_rook_movers() | <a class="code" href="namespacecwchess.html#a3d47283c624760531b65ae0e88e40be9" title="The a-file.">file_a</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l01478"></a>01478       probe = pos;
<a name="l01479"></a>01479       <span class="keywordflow">do</span>
<a name="l01480"></a>01480       {
<a name="l01481"></a>01481         move(probe, right);
<a name="l01482"></a>01482         reachables |= probe;
<a name="l01483"></a>01483       }
<a name="l01484"></a>01484       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l01485"></a>01485 
<a name="l01486"></a>01486       <span class="comment">// And right, but diagonal.</span>
<a name="l01487"></a>01487       block = all_pieces_minus_bishop_movers() | <a class="code" href="namespacecwchess.html#a3d47283c624760531b65ae0e88e40be9" title="The a-file.">file_a</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l01488"></a>01488 
<a name="l01489"></a>01489       <span class="comment">// Find reachable squares right above the queen;</span>
<a name="l01490"></a>01490       probe = pos;
<a name="l01491"></a>01491       <span class="keywordflow">do</span>
<a name="l01492"></a>01492       {
<a name="l01493"></a>01493         move(probe, up_right);
<a name="l01494"></a>01494         reachables |= probe;
<a name="l01495"></a>01495       }
<a name="l01496"></a>01496       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l01497"></a>01497 
<a name="l01498"></a>01498       <span class="comment">// Find reachable squares right below the queen;</span>
<a name="l01499"></a>01499       probe = pos;
<a name="l01500"></a>01500       <span class="keywordflow">do</span>
<a name="l01501"></a>01501       {
<a name="l01502"></a>01502         move(probe, down_right);
<a name="l01503"></a>01503         reachables |= probe;
<a name="l01504"></a>01504       }
<a name="l01505"></a>01505       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l01506"></a>01506       reachables&amp; = ~<a class="code" href="namespacecwchess.html#a3d47283c624760531b65ae0e88e40be9" title="The a-file.">file_a</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l01507"></a>01507 
<a name="l01508"></a>01508       result |= reachables;
<a name="l01509"></a>01509 
<a name="l01510"></a>01510       <span class="comment">// Do we need to update M_king_battery_attack_count?</span>
<a name="l01511"></a>01511       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> opposite_king_pos(M_bitboards[<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(color.<a class="code" href="classcwchess_1_1Color.html#ae7b69104c64e17005f5eb3ad277c4bdf" title="Return a Color object with the opposite color of this object.">opposite</a>(), <a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>)]);    <span class="comment">// The position of the opposite king.</span>
<a name="l01512"></a>01512       <span class="keywordflow">if</span> (__builtin_expect(result.<a class="code" href="classcwchess_1_1BitBoard.html#acdb49d61eb3a825048c17627d1bc8f10" title="Test if any bit is set at all.">test</a>(opposite_king_pos), <span class="keyword">false</span>))      <span class="comment">// Do we give check?</span>
<a name="l01513"></a>01513       {
<a name="l01514"></a>01514         <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> queen_code(color, <a class="code" href="namespacecwchess.html#ad3a2fc51450ffe511826ea0ddc6781ec" title="A constant representing a queen.">queen</a>);
<a name="l01515"></a>01515         <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> bishop_code(color, <a class="code" href="namespacecwchess.html#a3f166611f4301dafd492316030d6ecab" title="A constant representing a bishop.">bishop</a>);
<a name="l01516"></a>01516         <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> other_attackers(other_rook_movers | M_bitboards[queen_code] | M_bitboards[bishop_code]);
<a name="l01517"></a>01517         <span class="keywordflow">if</span> (result.<a class="code" href="classcwchess_1_1BitBoard.html#acdb49d61eb3a825048c17627d1bc8f10" title="Test if any bit is set at all.">test</a>(other_attackers))                               <span class="comment">// and block or look through another attacker?</span>
<a name="l01518"></a>01518         {
<a name="l01519"></a>01519           <span class="comment">// This other attacker could be on a different line than the one to the king.</span>
<a name="l01520"></a>01520           <span class="comment">// So, check if it is really on the line with the king or not.</span>
<a name="l01521"></a>01521           <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> king_index(<a class="code" href="namespacecwchess.html#a556a7930206c9c994411661cd2896dd1" title="Convert a single bit mask into it&amp;#39;s Index.">mask2index</a>(opposite_king_pos()));
<a name="l01522"></a>01522           <a class="code" href="structcwchess_1_1Direction.html">Direction</a> direction(direction_from_to(king_index, index));
<a name="l01523"></a>01523           <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> line(direction.<a class="code" href="structcwchess_1_1Direction.html#ac774c9ba1cc29045849a85fd7fdd89f8" title="Return a BitBoard with all squares in this direction.">from</a>(king_index));    <span class="comment">// All squares from checked king in the direction of the new attacker.</span>
<a name="l01524"></a>01524           line&amp; = result;                                       <span class="comment">// ... but only until the blocker on the other side.</span>
<a name="l01525"></a>01525           line&amp; = other_attackers;                      <span class="comment">// ... only possible other attackers.</span>
<a name="l01526"></a>01526           battery = line.<a class="code" href="classcwchess_1_1BitBoard.html#acdb49d61eb3a825048c17627d1bc8f10" title="Test if any bit is set at all.">test</a>();                                <span class="comment">// Battery exists if line is non-empty (note that &#39;result&#39; has &#39;index&#39; never set).</span>
<a name="l01527"></a>01527         }
<a name="l01528"></a>01528       }
<a name="l01529"></a>01529 
<a name="l01530"></a>01530       <span class="keywordflow">return</span> result;
<a name="l01531"></a>01531     }
<a name="l01532"></a>01532   }
<a name="l01533"></a>01533   <span class="keywordflow">return</span> <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a>();    <span class="comment">// Never reached.</span>
<a name="l01534"></a>01534 }
<a name="l01535"></a>01535 
<a name="l01536"></a>01536 <span class="comment">// This function updates M_defended by adding or subtracting BitBoard&#39;s</span>
<a name="l01537"></a>01537 <span class="comment">// that represent blocked squares by placing &#39;code&#39; on square &#39;index&#39;.</span>
<a name="l01538"></a>01538 <span class="comment">// It also updates M_king_battery_attack_count.</span>
<a name="l01539"></a>01539 <span class="keywordtype">void</span> ChessPosition::update_blocked_defendables(<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> <span class="keyword">const</span>&amp; code, <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> <span class="keyword">const</span>&amp; index, <span class="keywordtype">bool</span> add)
<a name="l01540"></a>01540 {
<a name="l01541"></a>01541   <span class="comment">// A bitboard with bits set on every square where there is any piece.</span>
<a name="l01542"></a>01542   <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> <span class="keyword">const</span> all_pieces(M_bitboards[<a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>] | M_bitboards[<a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>]);
<a name="l01543"></a>01543   <span class="comment">// Calculate a bitboard with bits set for every rook and queen.</span>
<a name="l01544"></a>01544   <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> blocked_rookmovers(M_bitboards[<a class="code" href="namespacecwchess.html#a1cd8353264637d37192eb8b2c0b5f932" title="A constant representing a black rook;.">black_rook</a>] | M_bitboards[black_queen] | M_bitboards[<a class="code" href="namespacecwchess.html#a2eb1aa8e34e411c51efcd3b7f26c65f2" title="A constant representing a white rook.">white_rook</a>] | M_bitboards[white_queen]);
<a name="l01545"></a>01545   <span class="comment">// Calculate a bitboard with bits set for every bishop and queen.</span>
<a name="l01546"></a>01546   <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> blocked_bishopmovers(M_bitboards[black_bishop] | M_bitboards[black_queen] | M_bitboards[white_bishop] | M_bitboards[white_queen]);
<a name="l01547"></a>01547   <span class="comment">// However, remove those pieces from these bitboards that can defend THROUGH the considered piece and are of the same color.</span>
<a name="l01548"></a>01548   <span class="comment">// For example, if &#39;code&#39; is a white rook-- then we remove white rooks and white queens from &#39;blocked_rookmovers&#39;</span>
<a name="l01549"></a>01549   <span class="comment">// because they won&#39;t be blocked by &#39;code&#39;.</span>
<a name="l01550"></a>01550   <span class="keywordflow">if</span> (code.<a class="code" href="classcwchess_1_1Code.html#a03cbe24a0f565c3f3835f99e59cdfe5c" title="Returns TRUE if the type is a bishop, rook or queen.">is_a_slider</a>())
<a name="l01551"></a>01551   {
<a name="l01552"></a>01552     <a class="code" href="classcwchess_1_1Color.html" title="A color (black or white).">Color</a> color(code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>());
<a name="l01553"></a>01553     <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> queen_code(color, <a class="code" href="namespacecwchess.html#ad3a2fc51450ffe511826ea0ddc6781ec" title="A constant representing a queen.">queen</a>);
<a name="l01554"></a>01554     <span class="comment">// Queen, rook or bishop.</span>
<a name="l01555"></a>01555     <span class="keywordflow">if</span> (code.<a class="code" href="classcwchess_1_1Code.html#ae4b7f3c50066341c2e06fb1aa866eb03" title="Returns TRUE if the type is a rook or queen.">is_a_rookmover</a>())
<a name="l01556"></a>01556     {
<a name="l01557"></a>01557       <span class="comment">// Queen or rook.</span>
<a name="l01558"></a>01558       <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> rook_code(color, <a class="code" href="namespacecwchess.html#a4ff984a16c54b56749db5209e31b29f9" title="A constant representing a rook.">rook</a>);
<a name="l01559"></a>01559       blocked_rookmovers.reset(M_bitboards[rook_code] | M_bitboards[queen_code]);
<a name="l01560"></a>01560     }
<a name="l01561"></a>01561     <span class="keywordflow">if</span> (code.<a class="code" href="classcwchess_1_1Code.html#a92b978f70e6de6a732bd7d765decbc6c" title="Returns TRUE if the type is a bishop or queen.">is_a_bishopmover</a>())
<a name="l01562"></a>01562     {
<a name="l01563"></a>01563       <span class="comment">// Queen or bishop.</span>
<a name="l01564"></a>01564       Code bishop_code(color, <a class="code" href="namespacecwchess.html#a3f166611f4301dafd492316030d6ecab" title="A constant representing a bishop.">bishop</a>);
<a name="l01565"></a>01565       blocked_bishopmovers.reset(M_bitboards[bishop_code] | M_bitboards[queen_code]);
<a name="l01566"></a>01566     }
<a name="l01567"></a>01567   }
<a name="l01568"></a>01568 
<a name="l01569"></a>01569   <span class="comment">// A single piece can block eight different pieces (for all eight directions). Those pieces</span>
<a name="l01570"></a>01570   <span class="comment">// do not necessarily need to be of the same color of course. In order to update the two</span>
<a name="l01571"></a>01571   <span class="comment">// M_defended[] variables (squares defended by white and squares defended by black), we</span>
<a name="l01572"></a>01572   <span class="comment">// need to keep distinguish between squares that need updating because a white piece</span>
<a name="l01573"></a>01573   <span class="comment">// is (un)blocked, and squares that need updating because a black piece is (un)blocked.</span>
<a name="l01574"></a>01574 
<a name="l01575"></a>01575   ArrayColor&lt;BitBoard&gt; result;
<a name="l01576"></a>01576   result[<a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>].reset();
<a name="l01577"></a>01577   result[<a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>].reset();
<a name="l01578"></a>01578 
<a name="l01579"></a>01579   <span class="comment">// Find the first piece above the piece at &#39;index&#39;.</span>
<a name="l01580"></a>01580   <span class="comment">//</span>
<a name="l01581"></a>01581   <span class="comment">// This first direction is heavily commented.</span>
<a name="l01582"></a>01582   <span class="comment">// Consider the following case:</span>
<a name="l01583"></a>01583   <span class="comment">//</span>
<a name="l01584"></a>01584   <span class="comment">// &lt;-- North, South --&gt;</span>
<a name="l01585"></a>01585   <span class="comment">//   Q R . r . R k .</span>
<a name="l01586"></a>01586   <span class="comment">//         ^</span>
<a name="l01587"></a>01587   <span class="comment">//       index</span>
<a name="l01588"></a>01588   <span class="comment">// Where code = r = black_rook, Q = white_queen, R = white_rook and k = black_king.</span>
<a name="l01589"></a>01589   <span class="comment">//</span>
<a name="l01590"></a>01590   <span class="comment">// This case could for example happen if the right-most white rook just took a black piece</span>
<a name="l01591"></a>01591   <span class="comment">// and now black picks up his rook to take back.</span>
<a name="l01592"></a>01592   <span class="comment">//</span>
<a name="l01593"></a>01593   <span class="comment">// Note that blocked_rookmovers is:</span>
<a name="l01594"></a>01594   <span class="comment">//   Q R . r . R k .</span>
<a name="l01595"></a>01595   <span class="comment">//   1 1 0 0 0 1 0 0 &lt;-- blocked_rookmovers, all rook movers or opposite color of &#39;r&#39;.</span>
<a name="l01596"></a>01596 
<a name="l01597"></a>01597   <span class="comment">// All squares north of index.</span>
<a name="l01598"></a>01598   <span class="comment">//   Q R . r . R k .</span>
<a name="l01599"></a>01599   <span class="comment">//   1 1 1 0 0 0 0 0 &lt;-- line</span>
<a name="l01600"></a>01600   BitBoard line(north.from(index));
<a name="l01601"></a>01601   <span class="comment">// All pieces north of index.</span>
<a name="l01602"></a>01602   <span class="comment">//   Q R . r . R k .</span>
<a name="l01603"></a>01603   <span class="comment">//   1 1 0 0 0 0 0 0 &lt;-- line</span>
<a name="l01604"></a>01604   line&amp; = all_pieces;   
<a name="l01605"></a>01605 
<a name="l01606"></a>01606   <span class="comment">//   Q R . r . R k .</span>
<a name="l01607"></a>01607   <span class="comment">//                   ^</span>
<a name="l01608"></a>01608   <span class="comment">//              blocked_piece</span>
<a name="l01609"></a>01609   Index blocked_piece(<a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a>);
<a name="l01610"></a>01610   <span class="comment">// The first piece north of index, if any.</span>
<a name="l01611"></a>01611   <span class="comment">//   Q R . r . R k .</span>
<a name="l01612"></a>01612   <span class="comment">//     ^</span>
<a name="l01613"></a>01613   <span class="comment">// blocked_piece</span>
<a name="l01614"></a>01614   blocked_piece.next_bit_in(line());
<a name="l01615"></a>01615   <span class="comment">// Does this piece exist, and is it blocked by the piece on index?</span>
<a name="l01616"></a>01616   <span class="comment">// If another white rook or queen was placed (or picked up) instead</span>
<a name="l01617"></a>01617   <span class="comment">// of the black rook (r), then &#39;blocked_piece&#39; would not really be</span>
<a name="l01618"></a>01618   <span class="comment">// blocked (it can see through it). In that case the &#39;test&#39; would</span>
<a name="l01619"></a>01619   <span class="comment">// fail.</span>
<a name="l01620"></a>01620   <span class="keywordflow">if</span> (__builtin_expect(blocked_piece != <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>&amp;&amp; 
<a name="l01621"></a>01621       blocked_rookmovers.test(blocked_piece), <span class="keyword">false</span>))           
<a name="l01622"></a>01622   {
<a name="l01623"></a>01623     <span class="comment">// The piece is really blocked.</span>
<a name="l01624"></a>01624     <span class="comment">//</span>
<a name="l01625"></a>01625     <span class="comment">// Find all rooks and queens on the board of the same color</span>
<a name="l01626"></a>01626     <span class="comment">// as this blocked piece (because they look through eachother).</span>
<a name="l01627"></a>01627     <span class="comment">//   Q R . r . R k .</span>
<a name="l01628"></a>01628     <span class="comment">//   1 1 0 0 0 1 0 0 &lt;-- rookmovers_of_same_color</span>
<a name="l01629"></a>01629     <span class="comment">// In our example this is the same as blocked_rookmovers because</span>
<a name="l01630"></a>01630     <span class="comment">// the removed piece &#39;r&#39; is a rook mover too, of opposite color.</span>
<a name="l01631"></a>01631 
<a name="l01632"></a>01632     Color blocked_piece_color(M_pieces[blocked_piece].color());
<a name="l01633"></a>01633     Code rook_code(blocked_piece_color, <a class="code" href="namespacecwchess.html#a4ff984a16c54b56749db5209e31b29f9" title="A constant representing a rook.">rook</a>);
<a name="l01634"></a>01634     Code queen_code(blocked_piece_color, <a class="code" href="namespacecwchess.html#ad3a2fc51450ffe511826ea0ddc6781ec" title="A constant representing a queen.">queen</a>);
<a name="l01635"></a>01635     BitBoard rookmovers_of_same_color(M_bitboards[rook_code] | M_bitboards[queen_code]);
<a name="l01636"></a>01636 
<a name="l01637"></a>01637     <span class="comment">// Find the current blocker.</span>
<a name="l01638"></a>01638 
<a name="l01639"></a>01639     BitBoard all_blockers(all_pieces);
<a name="l01640"></a>01640     <span class="comment">// All pieces that would block &#39;blocked_piece&#39;.</span>
<a name="l01641"></a>01641     <span class="comment">//   Q R . r . R k .</span>
<a name="l01642"></a>01642     <span class="comment">//   0 0 0 ? 0 0 1 0 &lt;-- all_blockers</span>
<a name="l01643"></a>01643     <span class="comment">// The question mark reflects the fact that we don&#39;t really</span>
<a name="l01644"></a>01644     <span class="comment">// know if that rook is being removed or placed at this point.</span>
<a name="l01645"></a>01645     all_blockers.reset(rookmovers_of_same_color);
<a name="l01646"></a>01646     <span class="comment">// All squares below index.</span>
<a name="l01647"></a>01647     <span class="comment">//   Q R . r . R k .</span>
<a name="l01648"></a>01648     <span class="comment">//   0 0 0 0 1 1 1 1 &lt;-- opposite_line</span>
<a name="l01649"></a>01649     BitBoard opposite_line(south.from(index));
<a name="l01650"></a>01650     <span class="comment">// All pieces below index that would block &#39;blocked_piece&#39; if index is empty.</span>
<a name="l01651"></a>01651     <span class="comment">//   Q R . r . R k .</span>
<a name="l01652"></a>01652     <span class="comment">//   0 0 0 0 0 0 1 0 &lt;-- all_blockers</span>
<a name="l01653"></a>01653     all_blockers&amp; = opposite_line;
<a name="l01654"></a>01654     <span class="comment">// The first piece south of &#39;blocked_piece&#39; that would block &#39;blocked_piece&#39; if index is empty.</span>
<a name="l01655"></a>01655     <span class="comment">//   Q R . r . R k .</span>
<a name="l01656"></a>01656     <span class="comment">//               ^</span>
<a name="l01657"></a>01657     <span class="comment">//         current_blocker</span>
<a name="l01658"></a>01658     Index current_blocker(<a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>);
<a name="l01659"></a>01659     current_blocker.prev_bit_in(all_blockers());        
<a name="l01660"></a>01660 
<a name="l01661"></a>01661     <span class="comment">// Calculate all squares that become/are hidden from &#39;blocked_piece&#39; by the piece in index.</span>
<a name="l01662"></a>01662 
<a name="l01663"></a>01663     <span class="comment">// All squares south of index.</span>
<a name="l01664"></a>01664     BitBoard blocked_squares(opposite_line);
<a name="l01665"></a>01665     <span class="comment">// Minus all squares south of current blocker.</span>
<a name="l01666"></a>01666     <span class="comment">//   Q R . r . R k .</span>
<a name="l01667"></a>01667     <span class="comment">//   0 0 0 0 1 1 1 0 &lt;-- blocked_squares</span>
<a name="l01668"></a>01668     <span class="keywordflow">if</span> (current_blocker != <a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a>)
<a name="l01669"></a>01669       blocked_squares.reset(south.from(current_blocker));
<a name="l01670"></a>01670 
<a name="l01671"></a>01671     <span class="comment">// Is there anything to update?</span>
<a name="l01672"></a>01672     <span class="keywordflow">if</span> (blocked_squares)                                                
<a name="l01673"></a>01673     {
<a name="l01674"></a>01674       <span class="comment">// The update of M_defended is delayed. Instead, collect all results (seperated by color).</span>
<a name="l01675"></a>01675       result[blocked_piece_color] |= blocked_squares;
<a name="l01676"></a>01676 
<a name="l01677"></a>01677       <span class="comment">// If the current_blocker is a king of opposite color of blocked_piece,</span>
<a name="l01678"></a>01678       <span class="comment">// then we are dealing with an attack on the king and M_king_battery_attack_count</span>
<a name="l01679"></a>01679       <span class="comment">// might need to be updated too.</span>
<a name="l01680"></a>01680       Code king_code(blocked_piece_color.opposite(), <a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>);
<a name="l01681"></a>01681       <span class="keywordtype">bool</span> king_attack = M_bitboards[king_code].test(blocked_squares);
<a name="l01682"></a>01682       <span class="keywordflow">if</span> (__builtin_expect(king_attack &amp;&amp; blocked_squares.test(rookmovers_of_same_color), <span class="keyword">false</span>))
<a name="l01683"></a>01683       {
<a name="l01684"></a>01684         <span class="keywordflow">if</span> (add)
<a name="l01685"></a>01685           ++M_king_battery_attack_count[blocked_piece_color];
<a name="l01686"></a>01686         <span class="keywordflow">else</span>
<a name="l01687"></a>01687           --M_king_battery_attack_count[blocked_piece_color];
<a name="l01688"></a>01688       } 
<a name="l01689"></a>01689 
<a name="l01690"></a>01690       <span class="comment">// Call call_back_battery for each additional piece that is blocked:</span>
<a name="l01691"></a>01691       <span class="comment">// that is north of &#39;blocked_piece&#39; but &#39;looks through&#39; the piece on index.</span>
<a name="l01692"></a>01692       <span class="comment">//</span>
<a name="l01693"></a>01693       <span class="comment">// At this point we have:</span>
<a name="l01694"></a>01694       <span class="comment">//   Q R . r . R k .</span>
<a name="l01695"></a>01695       <span class="comment">//   1 1 0 0 0 0 0 0 &lt;-- line</span>
<a name="l01696"></a>01696       <span class="comment">//     ^</span>
<a name="l01697"></a>01697       <span class="comment">// blocked_piece</span>
<a name="l01698"></a>01698       <span class="comment">//</span>
<a name="l01699"></a>01699       <span class="comment">// So, it will find the &#39;Q&#39; next and call call_back_battery once.</span>
<a name="l01700"></a>01700 
<a name="l01701"></a>01701       <span class="keywordflow">for</span> (blocked_piece.next_bit_in(line());
<a name="l01702"></a>01702            blocked_piece != <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a> &amp;&amp; rookmovers_of_same_color.test(blocked_piece);
<a name="l01703"></a>01703            blocked_piece.next_bit_in(line()))
<a name="l01704"></a>01704       {
<a name="l01705"></a>01705         <span class="keywordflow">if</span> (add)
<a name="l01706"></a>01706           M_defended[blocked_piece_color].add(blocked_squares);
<a name="l01707"></a>01707         <span class="keywordflow">else</span>
<a name="l01708"></a>01708           M_defended[blocked_piece_color].sub(blocked_squares);
<a name="l01709"></a>01709         <span class="keywordflow">if</span> (king_attack)
<a name="l01710"></a>01710         {
<a name="l01711"></a>01711           <span class="keywordflow">if</span> (add)
<a name="l01712"></a>01712             ++M_king_battery_attack_count[blocked_piece_color];
<a name="l01713"></a>01713           <span class="keywordflow">else</span>
<a name="l01714"></a>01714             --M_king_battery_attack_count[blocked_piece_color];
<a name="l01715"></a>01715         }
<a name="l01716"></a>01716       }
<a name="l01717"></a>01717     }
<a name="l01718"></a>01718   }
<a name="l01719"></a>01719 
<a name="l01720"></a>01720   <span class="comment">// Find the first piece below this piece.</span>
<a name="l01721"></a>01721   line = south.from(index);
<a name="l01722"></a>01722   line&amp; = all_pieces;
<a name="l01723"></a>01723   blocked_piece = <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>;
<a name="l01724"></a>01724   blocked_piece.prev_bit_in(line());
<a name="l01725"></a>01725   <span class="keywordflow">if</span> (__builtin_expect(blocked_piece != <a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a> &amp;&amp; blocked_rookmovers.test(blocked_piece), <span class="keyword">false</span>))
<a name="l01726"></a>01726   {
<a name="l01727"></a>01727     <span class="comment">// The piece is blocked.</span>
<a name="l01728"></a>01728     Color blocked_piece_color(M_pieces[blocked_piece].color());
<a name="l01729"></a>01729     Code rook_code(blocked_piece_color, <a class="code" href="namespacecwchess.html#a4ff984a16c54b56749db5209e31b29f9" title="A constant representing a rook.">rook</a>);
<a name="l01730"></a>01730     Code queen_code(blocked_piece_color, <a class="code" href="namespacecwchess.html#ad3a2fc51450ffe511826ea0ddc6781ec" title="A constant representing a queen.">queen</a>);
<a name="l01731"></a>01731     BitBoard rookmovers_of_same_color(M_bitboards[rook_code] | M_bitboards[queen_code]);
<a name="l01732"></a>01732     <span class="comment">// Find the current blocker.</span>
<a name="l01733"></a>01733     BitBoard all_blockers(all_pieces);
<a name="l01734"></a>01734     all_blockers.reset(rookmovers_of_same_color);
<a name="l01735"></a>01735     BitBoard opposite_line(north.from(index));
<a name="l01736"></a>01736     all_blockers&amp; = opposite_line;
<a name="l01737"></a>01737     Index current_blocker(<a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a>);
<a name="l01738"></a>01738     current_blocker.next_bit_in(all_blockers());
<a name="l01739"></a>01739     BitBoard blocked_squares(opposite_line);
<a name="l01740"></a>01740     <span class="keywordflow">if</span> (current_blocker != <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>)
<a name="l01741"></a>01741       blocked_squares.reset(north.from(current_blocker));
<a name="l01742"></a>01742 
<a name="l01743"></a>01743     <span class="comment">// Call it multiple times if there is a battery.</span>
<a name="l01744"></a>01744     <span class="keywordflow">if</span> (blocked_squares)
<a name="l01745"></a>01745     {
<a name="l01746"></a>01746       result[blocked_piece_color] |= blocked_squares;
<a name="l01747"></a>01747       Code king_code(blocked_piece_color.opposite(), <a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>);
<a name="l01748"></a>01748       <span class="keywordtype">bool</span> king_attack = M_bitboards[king_code].test(blocked_squares);
<a name="l01749"></a>01749       <span class="keywordflow">if</span> (__builtin_expect(king_attack &amp;&amp; blocked_squares.test(rookmovers_of_same_color), <span class="keyword">false</span>))
<a name="l01750"></a>01750       {
<a name="l01751"></a>01751         <span class="keywordflow">if</span> (add)
<a name="l01752"></a>01752           ++M_king_battery_attack_count[blocked_piece_color];
<a name="l01753"></a>01753         <span class="keywordflow">else</span>
<a name="l01754"></a>01754           --M_king_battery_attack_count[blocked_piece_color];
<a name="l01755"></a>01755       }
<a name="l01756"></a>01756       <span class="keywordflow">if</span> (blocked_piece != <a class="code" href="namespacecwchess.html#a5f575bff9af84d4cddda44acd6e6bf0d" title="A constant representing the&amp; #39;first&amp;#39; index.">index_begin</a>)
<a name="l01757"></a>01757       {
<a name="l01758"></a>01758         <span class="keywordflow">for</span> (blocked_piece.prev_bit_in(line()); blocked_piece != <a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a> &amp;&amp; rookmovers_of_same_color.test(blocked_piece); blocked_piece.prev_bit_in(line()))
<a name="l01759"></a>01759         {
<a name="l01760"></a>01760           <span class="keywordflow">if</span> (add)
<a name="l01761"></a>01761             M_defended[blocked_piece_color].add(blocked_squares);
<a name="l01762"></a>01762           <span class="keywordflow">else</span>
<a name="l01763"></a>01763             M_defended[blocked_piece_color].sub(blocked_squares);
<a name="l01764"></a>01764           <span class="keywordflow">if</span> (king_attack)
<a name="l01765"></a>01765           {
<a name="l01766"></a>01766             <span class="keywordflow">if</span> (add)
<a name="l01767"></a>01767               ++M_king_battery_attack_count[blocked_piece_color];
<a name="l01768"></a>01768             <span class="keywordflow">else</span>
<a name="l01769"></a>01769               --M_king_battery_attack_count[blocked_piece_color];
<a name="l01770"></a>01770           }
<a name="l01771"></a>01771           <span class="keywordflow">if</span> (blocked_piece == <a class="code" href="namespacecwchess.html#a5f575bff9af84d4cddda44acd6e6bf0d" title="A constant representing the&amp; #39;first&amp;#39; index.">index_begin</a>)
<a name="l01772"></a>01772             <span class="keywordflow">break</span>;
<a name="l01773"></a>01773         }
<a name="l01774"></a>01774       }
<a name="l01775"></a>01775     }
<a name="l01776"></a>01776   }
<a name="l01777"></a>01777 
<a name="l01778"></a>01778   <span class="comment">// Find the first piece right of this piece.</span>
<a name="l01779"></a>01779   line = east.from(index);
<a name="l01780"></a>01780   line&amp; = all_pieces;
<a name="l01781"></a>01781   blocked_piece = <a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a>;
<a name="l01782"></a>01782   blocked_piece.next_bit_in(line());
<a name="l01783"></a>01783   <span class="keywordflow">if</span> (__builtin_expect(blocked_piece != <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a> &amp;&amp; blocked_rookmovers.test(blocked_piece), <span class="keyword">false</span>))
<a name="l01784"></a>01784   {
<a name="l01785"></a>01785     <span class="comment">// The piece is blocked.</span>
<a name="l01786"></a>01786     Color blocked_piece_color(M_pieces[blocked_piece].color());
<a name="l01787"></a>01787     Code rook_code(blocked_piece_color, <a class="code" href="namespacecwchess.html#a4ff984a16c54b56749db5209e31b29f9" title="A constant representing a rook.">rook</a>);
<a name="l01788"></a>01788     Code queen_code(blocked_piece_color, <a class="code" href="namespacecwchess.html#ad3a2fc51450ffe511826ea0ddc6781ec" title="A constant representing a queen.">queen</a>);
<a name="l01789"></a>01789     BitBoard rookmovers_of_same_color(M_bitboards[rook_code] | M_bitboards[queen_code]);
<a name="l01790"></a>01790     <span class="comment">// Find the current blocker.</span>
<a name="l01791"></a>01791     BitBoard all_blockers(all_pieces);
<a name="l01792"></a>01792     all_blockers.reset(rookmovers_of_same_color);
<a name="l01793"></a>01793     BitBoard opposite_line(west.from(index));
<a name="l01794"></a>01794     all_blockers&amp; = opposite_line;
<a name="l01795"></a>01795     Index current_blocker(<a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>);
<a name="l01796"></a>01796     current_blocker.prev_bit_in(all_blockers());
<a name="l01797"></a>01797     BitBoard blocked_squares(opposite_line);
<a name="l01798"></a>01798     <span class="keywordflow">if</span> (current_blocker != <a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a>)
<a name="l01799"></a>01799       blocked_squares.reset(west.from(current_blocker));
<a name="l01800"></a>01800     <span class="comment">// Call it multiple times if there is a battery.</span>
<a name="l01801"></a>01801     <span class="keywordflow">if</span> (blocked_squares)
<a name="l01802"></a>01802     {
<a name="l01803"></a>01803       result[blocked_piece_color] |= blocked_squares;
<a name="l01804"></a>01804       Code king_code(blocked_piece_color.opposite(), <a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>);
<a name="l01805"></a>01805       <span class="keywordtype">bool</span> king_attack = M_bitboards[king_code].test(blocked_squares);
<a name="l01806"></a>01806       <span class="keywordflow">if</span> (__builtin_expect(king_attack &amp;&amp; blocked_squares.test(rookmovers_of_same_color), <span class="keyword">false</span>))
<a name="l01807"></a>01807       {
<a name="l01808"></a>01808         <span class="keywordflow">if</span> (add)
<a name="l01809"></a>01809           ++M_king_battery_attack_count[blocked_piece_color];
<a name="l01810"></a>01810         <span class="keywordflow">else</span>
<a name="l01811"></a>01811           --M_king_battery_attack_count[blocked_piece_color];
<a name="l01812"></a>01812       }
<a name="l01813"></a>01813       <span class="keywordflow">for</span> (blocked_piece.next_bit_in(line()); blocked_piece != <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a> &amp;&amp; rookmovers_of_same_color.test(blocked_piece); blocked_piece.next_bit_in(line()))
<a name="l01814"></a>01814       {
<a name="l01815"></a>01815         <span class="keywordflow">if</span> (add)
<a name="l01816"></a>01816           M_defended[blocked_piece_color].add(blocked_squares);
<a name="l01817"></a>01817         <span class="keywordflow">else</span>
<a name="l01818"></a>01818           M_defended[blocked_piece_color].sub(blocked_squares);
<a name="l01819"></a>01819         <span class="keywordflow">if</span> (king_attack)
<a name="l01820"></a>01820         {
<a name="l01821"></a>01821           <span class="keywordflow">if</span> (add)
<a name="l01822"></a>01822             ++M_king_battery_attack_count[blocked_piece_color];
<a name="l01823"></a>01823           <span class="keywordflow">else</span>
<a name="l01824"></a>01824             --M_king_battery_attack_count[blocked_piece_color];
<a name="l01825"></a>01825         }
<a name="l01826"></a>01826       }
<a name="l01827"></a>01827     }
<a name="l01828"></a>01828   }
<a name="l01829"></a>01829 
<a name="l01830"></a>01830   <span class="comment">// Find the first piece left of this piece.</span>
<a name="l01831"></a>01831   line = west.from(index);
<a name="l01832"></a>01832   line&amp; = all_pieces;
<a name="l01833"></a>01833   blocked_piece = <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>;
<a name="l01834"></a>01834   blocked_piece.prev_bit_in(line());
<a name="l01835"></a>01835   <span class="keywordflow">if</span> (__builtin_expect(blocked_piece != <a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a> &amp;&amp; blocked_rookmovers.test(blocked_piece), <span class="keyword">false</span>))
<a name="l01836"></a>01836   {
<a name="l01837"></a>01837     <span class="comment">// The piece is blocked.</span>
<a name="l01838"></a>01838     Color blocked_piece_color(M_pieces[blocked_piece].color());
<a name="l01839"></a>01839     Code rook_code(blocked_piece_color, <a class="code" href="namespacecwchess.html#a4ff984a16c54b56749db5209e31b29f9" title="A constant representing a rook.">rook</a>);
<a name="l01840"></a>01840     Code queen_code(blocked_piece_color, <a class="code" href="namespacecwchess.html#ad3a2fc51450ffe511826ea0ddc6781ec" title="A constant representing a queen.">queen</a>);
<a name="l01841"></a>01841     BitBoard rookmovers_of_same_color(M_bitboards[rook_code] | M_bitboards[queen_code]);
<a name="l01842"></a>01842     <span class="comment">// Find the current blocker.</span>
<a name="l01843"></a>01843     BitBoard all_blockers(all_pieces);
<a name="l01844"></a>01844     all_blockers.reset(rookmovers_of_same_color);
<a name="l01845"></a>01845     BitBoard opposite_line(east.from(index));
<a name="l01846"></a>01846     all_blockers&amp; = opposite_line;
<a name="l01847"></a>01847     Index current_blocker(<a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a>);
<a name="l01848"></a>01848     current_blocker.next_bit_in(all_blockers());
<a name="l01849"></a>01849     BitBoard blocked_squares(opposite_line);
<a name="l01850"></a>01850     <span class="keywordflow">if</span> (current_blocker != <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>)
<a name="l01851"></a>01851       blocked_squares.reset(east.from(current_blocker));
<a name="l01852"></a>01852     <span class="comment">// Call it multiple times if there is a battery.</span>
<a name="l01853"></a>01853     <span class="keywordflow">if</span> (blocked_squares)
<a name="l01854"></a>01854     {
<a name="l01855"></a>01855       result[blocked_piece_color] |= blocked_squares;
<a name="l01856"></a>01856       Code king_code(blocked_piece_color.opposite(), <a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>);
<a name="l01857"></a>01857       <span class="keywordtype">bool</span> king_attack = M_bitboards[king_code].test(blocked_squares);
<a name="l01858"></a>01858       <span class="keywordflow">if</span> (__builtin_expect(king_attack &amp;&amp; blocked_squares.test(rookmovers_of_same_color), <span class="keyword">false</span>))
<a name="l01859"></a>01859       {
<a name="l01860"></a>01860         <span class="keywordflow">if</span> (add)
<a name="l01861"></a>01861           ++M_king_battery_attack_count[blocked_piece_color];
<a name="l01862"></a>01862         <span class="keywordflow">else</span>
<a name="l01863"></a>01863           --M_king_battery_attack_count[blocked_piece_color];
<a name="l01864"></a>01864       }
<a name="l01865"></a>01865       <span class="keywordflow">if</span> (blocked_piece != <a class="code" href="namespacecwchess.html#a5f575bff9af84d4cddda44acd6e6bf0d" title="A constant representing the&amp; #39;first&amp;#39; index.">index_begin</a>)
<a name="l01866"></a>01866       {
<a name="l01867"></a>01867         <span class="keywordflow">for</span> (blocked_piece.prev_bit_in(line()); blocked_piece != <a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a> &amp;&amp; rookmovers_of_same_color.test(blocked_piece); blocked_piece.prev_bit_in(line()))
<a name="l01868"></a>01868         {
<a name="l01869"></a>01869           <span class="keywordflow">if</span> (add)
<a name="l01870"></a>01870             M_defended[blocked_piece_color].add(blocked_squares);
<a name="l01871"></a>01871           <span class="keywordflow">else</span>
<a name="l01872"></a>01872             M_defended[blocked_piece_color].sub(blocked_squares);
<a name="l01873"></a>01873           <span class="keywordflow">if</span> (king_attack)
<a name="l01874"></a>01874           {
<a name="l01875"></a>01875             <span class="keywordflow">if</span> (add)
<a name="l01876"></a>01876               ++M_king_battery_attack_count[blocked_piece_color];
<a name="l01877"></a>01877             <span class="keywordflow">else</span>
<a name="l01878"></a>01878               --M_king_battery_attack_count[blocked_piece_color];
<a name="l01879"></a>01879           }
<a name="l01880"></a>01880           <span class="keywordflow">if</span> (blocked_piece == <a class="code" href="namespacecwchess.html#a5f575bff9af84d4cddda44acd6e6bf0d" title="A constant representing the&amp; #39;first&amp;#39; index.">index_begin</a>)
<a name="l01881"></a>01881             <span class="keywordflow">break</span>;
<a name="l01882"></a>01882         }
<a name="l01883"></a>01883       }
<a name="l01884"></a>01884     }
<a name="l01885"></a>01885   }
<a name="l01886"></a>01886 
<a name="l01887"></a>01887   <span class="comment">// Find the first piece north-west of this piece.</span>
<a name="l01888"></a>01888   line = north_west.from(index);
<a name="l01889"></a>01889   line&amp; = all_pieces;
<a name="l01890"></a>01890   blocked_piece = <a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a>;
<a name="l01891"></a>01891   blocked_piece.next_bit_in(line());
<a name="l01892"></a>01892   <span class="keywordflow">if</span> (__builtin_expect(blocked_piece != <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a> &amp;&amp; blocked_bishopmovers.test(blocked_piece), <span class="keyword">false</span>))
<a name="l01893"></a>01893   {
<a name="l01894"></a>01894     <span class="comment">// The piece is blocked.</span>
<a name="l01895"></a>01895     Color blocked_piece_color(M_pieces[blocked_piece].color());
<a name="l01896"></a>01896     Code bishop_code(blocked_piece_color, <a class="code" href="namespacecwchess.html#a3f166611f4301dafd492316030d6ecab" title="A constant representing a bishop.">bishop</a>);
<a name="l01897"></a>01897     Code queen_code(blocked_piece_color, <a class="code" href="namespacecwchess.html#ad3a2fc51450ffe511826ea0ddc6781ec" title="A constant representing a queen.">queen</a>);
<a name="l01898"></a>01898     BitBoard bishopmovers_of_same_color(M_bitboards[bishop_code] | M_bitboards[queen_code]);
<a name="l01899"></a>01899     <span class="comment">// Find the current blocker.</span>
<a name="l01900"></a>01900     BitBoard all_blockers(all_pieces);
<a name="l01901"></a>01901     all_blockers.reset(bishopmovers_of_same_color);
<a name="l01902"></a>01902     BitBoard opposite_line(south_east.from(index));
<a name="l01903"></a>01903     all_blockers&amp; = opposite_line;
<a name="l01904"></a>01904     Index current_blocker(<a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>);
<a name="l01905"></a>01905     current_blocker.prev_bit_in(all_blockers());
<a name="l01906"></a>01906     BitBoard blocked_squares(opposite_line);
<a name="l01907"></a>01907     <span class="keywordflow">if</span> (current_blocker != <a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a>)
<a name="l01908"></a>01908       blocked_squares.reset(south_east.from(current_blocker));
<a name="l01909"></a>01909     <span class="comment">// Call it multiple times if there is a battery.</span>
<a name="l01910"></a>01910     <span class="keywordflow">if</span> (blocked_squares)
<a name="l01911"></a>01911     {
<a name="l01912"></a>01912       <span class="keywordflow">if</span> (__builtin_expect(code == <a class="code" href="namespacecwchess.html#acd891cc1843e2bce6978c194647c928a" title="A constant representing a black pawn.">black_pawn</a>, <span class="keyword">false</span>) &amp;&amp; blocked_piece_color == <a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>)
<a name="l01913"></a>01913         blocked_squares.reset(index + south_east.offset);
<a name="l01914"></a>01914       result[blocked_piece_color] |= blocked_squares;
<a name="l01915"></a>01915       Code king_code(blocked_piece_color.opposite(), <a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>);
<a name="l01916"></a>01916       <span class="keywordtype">bool</span> king_attack = M_bitboards[king_code].test(blocked_squares);
<a name="l01917"></a>01917       <span class="keywordflow">if</span> (__builtin_expect(king_attack &amp;&amp; blocked_squares.test(bishopmovers_of_same_color), <span class="keyword">false</span>))
<a name="l01918"></a>01918       {
<a name="l01919"></a>01919         <span class="keywordflow">if</span> (add)
<a name="l01920"></a>01920           ++M_king_battery_attack_count[blocked_piece_color];
<a name="l01921"></a>01921         <span class="keywordflow">else</span>
<a name="l01922"></a>01922           --M_king_battery_attack_count[blocked_piece_color];
<a name="l01923"></a>01923       }
<a name="l01924"></a>01924       <span class="keywordflow">for</span> (blocked_piece.next_bit_in(line()); blocked_piece != <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a> &amp;&amp; bishopmovers_of_same_color.test(blocked_piece); blocked_piece.next_bit_in(line()))
<a name="l01925"></a>01925       {
<a name="l01926"></a>01926         <span class="keywordflow">if</span> (add)
<a name="l01927"></a>01927           M_defended[blocked_piece_color].add(blocked_squares);
<a name="l01928"></a>01928         <span class="keywordflow">else</span>
<a name="l01929"></a>01929           M_defended[blocked_piece_color].sub(blocked_squares);
<a name="l01930"></a>01930         <span class="keywordflow">if</span> (king_attack)
<a name="l01931"></a>01931         {
<a name="l01932"></a>01932           <span class="keywordflow">if</span> (add)
<a name="l01933"></a>01933             ++M_king_battery_attack_count[blocked_piece_color];
<a name="l01934"></a>01934           <span class="keywordflow">else</span>
<a name="l01935"></a>01935             --M_king_battery_attack_count[blocked_piece_color];
<a name="l01936"></a>01936         }
<a name="l01937"></a>01937       }
<a name="l01938"></a>01938     }
<a name="l01939"></a>01939   }
<a name="l01940"></a>01940 
<a name="l01941"></a>01941   <span class="comment">// Find the first piece south-east this piece.</span>
<a name="l01942"></a>01942   line = south_east.from(index);
<a name="l01943"></a>01943   line&amp; = all_pieces;
<a name="l01944"></a>01944   blocked_piece = <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>;
<a name="l01945"></a>01945   blocked_piece.prev_bit_in(line());
<a name="l01946"></a>01946   <span class="keywordflow">if</span> (__builtin_expect(blocked_piece != <a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a> &amp;&amp; blocked_bishopmovers.test(blocked_piece), <span class="keyword">false</span>))
<a name="l01947"></a>01947   {
<a name="l01948"></a>01948     <span class="comment">// The piece is blocked.</span>
<a name="l01949"></a>01949     Color blocked_piece_color(M_pieces[blocked_piece].color());
<a name="l01950"></a>01950     Code bishop_code(blocked_piece_color, <a class="code" href="namespacecwchess.html#a3f166611f4301dafd492316030d6ecab" title="A constant representing a bishop.">bishop</a>);
<a name="l01951"></a>01951     Code queen_code(blocked_piece_color, <a class="code" href="namespacecwchess.html#ad3a2fc51450ffe511826ea0ddc6781ec" title="A constant representing a queen.">queen</a>);
<a name="l01952"></a>01952     BitBoard bishopmovers_of_same_color(M_bitboards[bishop_code] | M_bitboards[queen_code]);
<a name="l01953"></a>01953     <span class="comment">// Find the current blocker.</span>
<a name="l01954"></a>01954     BitBoard all_blockers(all_pieces);
<a name="l01955"></a>01955     all_blockers.reset(bishopmovers_of_same_color);
<a name="l01956"></a>01956     BitBoard opposite_line(north_west.from(index));
<a name="l01957"></a>01957     all_blockers&amp; = opposite_line;
<a name="l01958"></a>01958     Index current_blocker(<a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a>);
<a name="l01959"></a>01959     current_blocker.next_bit_in(all_blockers());
<a name="l01960"></a>01960     BitBoard blocked_squares(opposite_line);
<a name="l01961"></a>01961     <span class="keywordflow">if</span> (current_blocker != <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>)
<a name="l01962"></a>01962       blocked_squares.reset(north_west.from(current_blocker));
<a name="l01963"></a>01963     <span class="comment">// Call it multiple times if there is a battery.</span>
<a name="l01964"></a>01964     <span class="keywordflow">if</span> (blocked_squares)
<a name="l01965"></a>01965     {
<a name="l01966"></a>01966       <span class="keywordflow">if</span> (__builtin_expect(code == <a class="code" href="namespacecwchess.html#acbefae1953a03a417fcf2b5c9e3b55a6" title="A constant representing a white pawn.">white_pawn</a>, <span class="keyword">false</span>) &amp;&amp; blocked_piece_color == <a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>)
<a name="l01967"></a>01967         blocked_squares.reset(index + north_west.offset);
<a name="l01968"></a>01968       result[blocked_piece_color] |= blocked_squares;
<a name="l01969"></a>01969       Code king_code(blocked_piece_color.opposite(), <a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>);
<a name="l01970"></a>01970       <span class="keywordtype">bool</span> king_attack = M_bitboards[king_code].test(blocked_squares);
<a name="l01971"></a>01971       <span class="keywordflow">if</span> (__builtin_expect(king_attack &amp;&amp; blocked_squares.test(bishopmovers_of_same_color), <span class="keyword">false</span>))
<a name="l01972"></a>01972       {
<a name="l01973"></a>01973         <span class="keywordflow">if</span> (add)
<a name="l01974"></a>01974           ++M_king_battery_attack_count[blocked_piece_color];
<a name="l01975"></a>01975         <span class="keywordflow">else</span>
<a name="l01976"></a>01976           --M_king_battery_attack_count[blocked_piece_color];
<a name="l01977"></a>01977       }
<a name="l01978"></a>01978       <span class="keywordflow">if</span> (blocked_piece != <a class="code" href="namespacecwchess.html#a5f575bff9af84d4cddda44acd6e6bf0d" title="A constant representing the&amp; #39;first&amp;#39; index.">index_begin</a>)
<a name="l01979"></a>01979       {
<a name="l01980"></a>01980         <span class="keywordflow">for</span> (blocked_piece.prev_bit_in(line()); blocked_piece != <a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a> &amp;&amp; bishopmovers_of_same_color.test(blocked_piece); blocked_piece.prev_bit_in(line()))
<a name="l01981"></a>01981         {
<a name="l01982"></a>01982           <span class="keywordflow">if</span> (add)
<a name="l01983"></a>01983             M_defended[blocked_piece_color].add(blocked_squares);
<a name="l01984"></a>01984           <span class="keywordflow">else</span>
<a name="l01985"></a>01985             M_defended[blocked_piece_color].sub(blocked_squares);
<a name="l01986"></a>01986           <span class="keywordflow">if</span> (king_attack)
<a name="l01987"></a>01987           {
<a name="l01988"></a>01988             <span class="keywordflow">if</span> (add)
<a name="l01989"></a>01989               ++M_king_battery_attack_count[blocked_piece_color];
<a name="l01990"></a>01990             <span class="keywordflow">else</span>
<a name="l01991"></a>01991               --M_king_battery_attack_count[blocked_piece_color];
<a name="l01992"></a>01992           }
<a name="l01993"></a>01993           <span class="keywordflow">if</span> (blocked_piece == <a class="code" href="namespacecwchess.html#a5f575bff9af84d4cddda44acd6e6bf0d" title="A constant representing the&amp; #39;first&amp;#39; index.">index_begin</a>)
<a name="l01994"></a>01994             <span class="keywordflow">break</span>;
<a name="l01995"></a>01995         }
<a name="l01996"></a>01996       }
<a name="l01997"></a>01997     }
<a name="l01998"></a>01998   }
<a name="l01999"></a>01999 
<a name="l02000"></a>02000   <span class="comment">// Find the first piece north-east of this piece.</span>
<a name="l02001"></a>02001   line = north_east.from(index);
<a name="l02002"></a>02002   line&amp; = all_pieces;
<a name="l02003"></a>02003   blocked_piece = <a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a>;
<a name="l02004"></a>02004   blocked_piece.next_bit_in(line());
<a name="l02005"></a>02005   <span class="keywordflow">if</span> (__builtin_expect(blocked_piece != <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a> &amp;&amp; blocked_bishopmovers.test(blocked_piece), <span class="keyword">false</span>))
<a name="l02006"></a>02006   {
<a name="l02007"></a>02007     <span class="comment">// The piece is blocked.</span>
<a name="l02008"></a>02008     Color blocked_piece_color(M_pieces[blocked_piece].color());
<a name="l02009"></a>02009     Code bishop_code(blocked_piece_color, <a class="code" href="namespacecwchess.html#a3f166611f4301dafd492316030d6ecab" title="A constant representing a bishop.">bishop</a>);
<a name="l02010"></a>02010     Code queen_code(blocked_piece_color, <a class="code" href="namespacecwchess.html#ad3a2fc51450ffe511826ea0ddc6781ec" title="A constant representing a queen.">queen</a>);
<a name="l02011"></a>02011     BitBoard bishopmovers_of_same_color(M_bitboards[bishop_code] | M_bitboards[queen_code]);
<a name="l02012"></a>02012     <span class="comment">// Find the current blocker.</span>
<a name="l02013"></a>02013     BitBoard all_blockers(all_pieces);
<a name="l02014"></a>02014     all_blockers.reset(bishopmovers_of_same_color);
<a name="l02015"></a>02015     BitBoard opposite_line(south_west.from(index));
<a name="l02016"></a>02016     all_blockers&amp; = opposite_line;
<a name="l02017"></a>02017     Index current_blocker(<a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>);
<a name="l02018"></a>02018     current_blocker.prev_bit_in(all_blockers());
<a name="l02019"></a>02019     BitBoard blocked_squares(opposite_line);
<a name="l02020"></a>02020     <span class="keywordflow">if</span> (current_blocker != <a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a>)
<a name="l02021"></a>02021       blocked_squares.reset(south_west.from(current_blocker));
<a name="l02022"></a>02022     <span class="comment">// Call it multiple times if there is a battery.</span>
<a name="l02023"></a>02023     <span class="keywordflow">if</span> (blocked_squares)
<a name="l02024"></a>02024     {
<a name="l02025"></a>02025       <span class="keywordflow">if</span> (__builtin_expect(code == <a class="code" href="namespacecwchess.html#acd891cc1843e2bce6978c194647c928a" title="A constant representing a black pawn.">black_pawn</a>, <span class="keyword">false</span>) &amp;&amp; blocked_piece_color == <a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>)
<a name="l02026"></a>02026         blocked_squares.reset(index + south_west.offset);
<a name="l02027"></a>02027       result[blocked_piece_color] |= blocked_squares;
<a name="l02028"></a>02028       Code king_code(blocked_piece_color.opposite(), <a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>);
<a name="l02029"></a>02029       <span class="keywordtype">bool</span> king_attack = M_bitboards[king_code].test(blocked_squares);
<a name="l02030"></a>02030       <span class="keywordflow">if</span> (__builtin_expect(king_attack &amp;&amp; blocked_squares.test(bishopmovers_of_same_color), <span class="keyword">false</span>))
<a name="l02031"></a>02031       {
<a name="l02032"></a>02032         <span class="keywordflow">if</span> (add)
<a name="l02033"></a>02033           ++M_king_battery_attack_count[blocked_piece_color];
<a name="l02034"></a>02034         <span class="keywordflow">else</span>
<a name="l02035"></a>02035           --M_king_battery_attack_count[blocked_piece_color];
<a name="l02036"></a>02036       }
<a name="l02037"></a>02037       <span class="keywordflow">for</span> (blocked_piece.next_bit_in(line()); blocked_piece != <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a> &amp;&amp; bishopmovers_of_same_color.test(blocked_piece); blocked_piece.next_bit_in(line()))
<a name="l02038"></a>02038       {
<a name="l02039"></a>02039         <span class="keywordflow">if</span> (add)
<a name="l02040"></a>02040           M_defended[blocked_piece_color].add(blocked_squares);
<a name="l02041"></a>02041         <span class="keywordflow">else</span>
<a name="l02042"></a>02042           M_defended[blocked_piece_color].sub(blocked_squares);
<a name="l02043"></a>02043         <span class="keywordflow">if</span> (king_attack)
<a name="l02044"></a>02044         {
<a name="l02045"></a>02045           <span class="keywordflow">if</span> (add)
<a name="l02046"></a>02046             ++M_king_battery_attack_count[blocked_piece_color];
<a name="l02047"></a>02047           <span class="keywordflow">else</span>
<a name="l02048"></a>02048             --M_king_battery_attack_count[blocked_piece_color];
<a name="l02049"></a>02049         }
<a name="l02050"></a>02050       }
<a name="l02051"></a>02051     }
<a name="l02052"></a>02052   }
<a name="l02053"></a>02053 
<a name="l02054"></a>02054   <span class="comment">// Find the first piece south-west of this piece.</span>
<a name="l02055"></a>02055   line = south_west.from(index);
<a name="l02056"></a>02056   line&amp; = all_pieces;
<a name="l02057"></a>02057   blocked_piece = <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>;
<a name="l02058"></a>02058   blocked_piece.prev_bit_in(line());
<a name="l02059"></a>02059   <span class="keywordflow">if</span> (__builtin_expect(blocked_piece != <a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a> &amp;&amp; blocked_bishopmovers.test(blocked_piece), <span class="keyword">false</span>))
<a name="l02060"></a>02060   {
<a name="l02061"></a>02061     <span class="comment">// The piece is blocked.</span>
<a name="l02062"></a>02062     Color blocked_piece_color(M_pieces[blocked_piece].color());
<a name="l02063"></a>02063     Code bishop_code(blocked_piece_color, <a class="code" href="namespacecwchess.html#a3f166611f4301dafd492316030d6ecab" title="A constant representing a bishop.">bishop</a>);
<a name="l02064"></a>02064     Code queen_code(blocked_piece_color, <a class="code" href="namespacecwchess.html#ad3a2fc51450ffe511826ea0ddc6781ec" title="A constant representing a queen.">queen</a>);
<a name="l02065"></a>02065     BitBoard bishopmovers_of_same_color(M_bitboards[bishop_code] | M_bitboards[queen_code]);
<a name="l02066"></a>02066     <span class="comment">// Find the current blocker.</span>
<a name="l02067"></a>02067     BitBoard all_blockers(all_pieces);
<a name="l02068"></a>02068     all_blockers.reset(bishopmovers_of_same_color);
<a name="l02069"></a>02069     BitBoard opposite_line(north_east.from(index));
<a name="l02070"></a>02070     all_blockers&amp; = opposite_line;
<a name="l02071"></a>02071     Index current_blocker(<a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a>);
<a name="l02072"></a>02072     current_blocker.next_bit_in(all_blockers());
<a name="l02073"></a>02073     BitBoard blocked_squares(opposite_line);
<a name="l02074"></a>02074     <span class="keywordflow">if</span> (current_blocker != <a class="code" href="namespacecwchess.html#aefccdeb9385ba2d999d518561465de66" title="A constant representing&amp; #39;one past the end&amp;#39;.">index_end</a>)
<a name="l02075"></a>02075       blocked_squares.reset(north_east.from(current_blocker));
<a name="l02076"></a>02076     <span class="comment">// Call it multiple times if there is a battery.</span>
<a name="l02077"></a>02077     <span class="keywordflow">if</span> (blocked_squares)
<a name="l02078"></a>02078     {
<a name="l02079"></a>02079       <span class="keywordflow">if</span> (__builtin_expect(code == <a class="code" href="namespacecwchess.html#acbefae1953a03a417fcf2b5c9e3b55a6" title="A constant representing a white pawn.">white_pawn</a>, <span class="keyword">false</span>) &amp;&amp; blocked_piece_color == <a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>)
<a name="l02080"></a>02080         blocked_squares.reset(index + north_east.offset);
<a name="l02081"></a>02081       result[blocked_piece_color] |= blocked_squares;
<a name="l02082"></a>02082       Code king_code(blocked_piece_color.opposite(), <a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>);
<a name="l02083"></a>02083       <span class="keywordtype">bool</span> king_attack = M_bitboards[king_code].test(blocked_squares);
<a name="l02084"></a>02084       <span class="keywordflow">if</span> (__builtin_expect(king_attack &amp;&amp; blocked_squares.test(bishopmovers_of_same_color), <span class="keyword">false</span>))
<a name="l02085"></a>02085       {
<a name="l02086"></a>02086         <span class="keywordflow">if</span> (add)
<a name="l02087"></a>02087           ++M_king_battery_attack_count[blocked_piece_color];
<a name="l02088"></a>02088         <span class="keywordflow">else</span>
<a name="l02089"></a>02089           --M_king_battery_attack_count[blocked_piece_color];
<a name="l02090"></a>02090       }
<a name="l02091"></a>02091       <span class="keywordflow">if</span> (blocked_piece != <a class="code" href="namespacecwchess.html#a5f575bff9af84d4cddda44acd6e6bf0d" title="A constant representing the&amp; #39;first&amp;#39; index.">index_begin</a>)
<a name="l02092"></a>02092       {
<a name="l02093"></a>02093         <span class="keywordflow">for</span> (blocked_piece.prev_bit_in(line()); blocked_piece != <a class="code" href="namespacecwchess.html#a9a0a383d679c173848220f294a2aa16b" title="A constant representing&amp; #39;one before the start&amp;#39;.">index_pre_begin</a> &amp;&amp; bishopmovers_of_same_color.test(blocked_piece); blocked_piece.prev_bit_in(line()))
<a name="l02094"></a>02094         {
<a name="l02095"></a>02095           <span class="keywordflow">if</span> (add)
<a name="l02096"></a>02096             M_defended[blocked_piece_color].add(blocked_squares);
<a name="l02097"></a>02097           <span class="keywordflow">else</span>
<a name="l02098"></a>02098             M_defended[blocked_piece_color].sub(blocked_squares);
<a name="l02099"></a>02099           <span class="keywordflow">if</span> (king_attack)
<a name="l02100"></a>02100           {
<a name="l02101"></a>02101             <span class="keywordflow">if</span> (add)
<a name="l02102"></a>02102               ++M_king_battery_attack_count[blocked_piece_color];
<a name="l02103"></a>02103             <span class="keywordflow">else</span>
<a name="l02104"></a>02104               --M_king_battery_attack_count[blocked_piece_color];
<a name="l02105"></a>02105           }
<a name="l02106"></a>02106           <span class="keywordflow">if</span> (blocked_piece == <a class="code" href="namespacecwchess.html#a5f575bff9af84d4cddda44acd6e6bf0d" title="A constant representing the&amp; #39;first&amp;#39; index.">index_begin</a>)
<a name="l02107"></a>02107             <span class="keywordflow">break</span>;
<a name="l02108"></a>02108         }
<a name="l02109"></a>02109       }
<a name="l02110"></a>02110     }
<a name="l02111"></a>02111   }
<a name="l02112"></a>02112 
<a name="l02113"></a>02113   <span class="comment">// Update M_defended with the collected results.</span>
<a name="l02114"></a>02114   <span class="keywordflow">if</span> (BitBoard black_result = result[<a class="code" href="namespacecwchess.html#a9edd86c3609c3393232c628d5b718c42" title="A constant representing the color black.">black</a>])
<a name="l02115"></a>02115   {
<a name="l02116"></a>02116     <span class="keywordflow">if</span> (add)
<a name="l02117"></a>02117       M_defended[black].add(black_result);
<a name="l02118"></a>02118     <span class="keywordflow">else</span>
<a name="l02119"></a>02119       M_defended[black].sub(black_result);
<a name="l02120"></a>02120   }
<a name="l02121"></a>02121   <span class="keywordflow">if</span> (BitBoard white_result = result[<a class="code" href="namespacecwchess.html#abfd6f16d8dad461f71e0458a668dd39c" title="A constant representing the color white.">white</a>])
<a name="l02122"></a>02122   {
<a name="l02123"></a>02123     <span class="keywordflow">if</span> (add)
<a name="l02124"></a>02124       M_defended[white].add(white_result);
<a name="l02125"></a>02125     <span class="keywordflow">else</span>
<a name="l02126"></a>02126       M_defended[white].sub(white_result);
<a name="l02127"></a>02127   }
<a name="l02128"></a>02128 }
<a name="l02129"></a>02129 
<a name="l02130"></a><a class="code" href="classcwchess_1_1ChessPosition.html#aee80b4a992db9fbbb10c380d7d1dc612">02130</a> <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> <a class="code" href="classcwchess_1_1ChessPosition.html#aee80b4a992db9fbbb10c380d7d1dc612" title="Return a BitBoard with bits set for each square that a piece can reach in one move.">ChessPosition::reachables</a>(<a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> <span class="keyword">const</span>&amp; index, <span class="keywordtype">bool</span> attacked_squares)<span class="keyword"> const</span>
<a name="l02131"></a>02131 <span class="keyword"></span>{
<a name="l02132"></a>02132   <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> all_pieces(M_bitboards[white] | M_bitboards[black]);         <span class="comment">// A bitboard with bits set on every square where there is any piece.</span>
<a name="l02133"></a>02133   <a class="code" href="classcwchess_1_1Piece.html" title="A particular piece on the board.">Piece</a> piece(M_pieces[index]);                                         <span class="comment">// The piece that we want to find the reachables for.</span>
<a name="l02134"></a>02134   <a class="code" href="classcwchess_1_1Color.html" title="A color (black or white).">Color</a> color = piece.<a class="code" href="classcwchess_1_1Piece.html#a4f0beda5729eff7633ace66348f35ae6" title="Return the color of the piece.">color</a>();                                          <span class="comment">// The color of the piece.</span>
<a name="l02135"></a>02135   <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> pos = <a class="code" href="namespacecwchess.html#a61b5311c7bc3b89a4c252d76dcfdbd40" title="Convert Index to a mask_t.">index2mask</a>(index);                                       <span class="comment">// The current position of the piece.</span>
<a name="l02136"></a>02136   <span class="keywordflow">switch</span>(piece.<a class="code" href="classcwchess_1_1Piece.html#a3d6165df18ed00128d8bda18e8754812" title="The type of this piece.">type</a>()())
<a name="l02137"></a>02137   {
<a name="l02138"></a>02138     <span class="keywordflow">case</span> <a class="code" href="namespacecwchess.html#a31acd5f9f24ccda6aff23704083e2648" title="The underlaying integral value of type&amp; #39;nothing&amp;#39;.">nothing_bits</a>:          <span class="comment">// This should never be called, but return an empty bitboard anyway.</span>
<a name="l02139"></a>02139     {
<a name="l02140"></a>02140       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> result;
<a name="l02141"></a>02141       result.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>();
<a name="l02142"></a>02142       <span class="keywordflow">return</span> result;
<a name="l02143"></a>02143     }
<a name="l02144"></a>02144     <span class="keywordflow">case</span> <a class="code" href="namespacecwchess.html#aa1d2a1c03b6f090d8f03a8e0abf47149" title="The underlaying integral value of type&amp; #39;pawn&amp;#39;.">pawn_bits</a>:
<a name="l02145"></a>02145     {
<a name="l02146"></a>02146       <span class="keywordflow">if</span> (attacked_squares)     <span class="comment">// Show attacked squares instead of move candidates?</span>
<a name="l02147"></a>02147       {
<a name="l02148"></a>02148         <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> result((color == white) ? (pos &lt;&lt; 7) | (pos &lt;&lt; 9) : (pos &gt;&gt; 9) | (pos &gt;&gt; 7));
<a name="l02149"></a>02149         result.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>(M_bitboards[color]);
<a name="l02150"></a>02150         <span class="keywordtype">int</span> col = index.col();
<a name="l02151"></a>02151         <span class="keywordflow">if</span> (__builtin_expect(col == 0, <span class="keyword">false</span>))
<a name="l02152"></a>02152           result.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>(<a class="code" href="namespacecwchess.html#adfb6784a238922e3b2a2e2c01269deb9" title="The h-file.">file_h</a>);
<a name="l02153"></a>02153         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (__builtin_expect(col == 7, <span class="keyword">false</span>))
<a name="l02154"></a>02154           result.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>(<a class="code" href="namespacecwchess.html#a3d47283c624760531b65ae0e88e40be9" title="The a-file.">file_a</a>);
<a name="l02155"></a>02155         <span class="keywordflow">return</span> result;
<a name="l02156"></a>02156       }
<a name="l02157"></a>02157       <span class="keywordflow">return</span> <a class="code" href="classcwchess_1_1ChessPosition.html#a6371880cfda1b2457152fd2a7b998d4b" title="Return a BitBoard with bits set for all squares that are candidates to move to.">candidates</a>(index); <span class="comment">// The candidates are the reachables in the case of pawns.</span>
<a name="l02158"></a>02158     }
<a name="l02159"></a>02159     <span class="keywordflow">case</span> <a class="code" href="namespacecwchess.html#aee3e5ab23dff55cc72e79bc2a7af1f27" title="The underlaying integral value of type&amp; #39;rook&amp;#39;.">rook_bits</a>:
<a name="l02160"></a>02160     {
<a name="l02161"></a>02161       <span class="comment">// Find reachable squares above the rook.</span>
<a name="l02162"></a>02162       <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> block = all_pieces();
<a name="l02163"></a>02163       <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> probe = pos;
<a name="l02164"></a>02164       <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> <a class="code" href="classcwchess_1_1ChessPosition.html#aee80b4a992db9fbbb10c380d7d1dc612" title="Return a BitBoard with bits set for each square that a piece can reach in one move.">reachables</a> = 0;
<a name="l02165"></a>02165       <span class="keywordflow">do</span>
<a name="l02166"></a>02166       {
<a name="l02167"></a>02167         move(probe, up);
<a name="l02168"></a>02168         reachables |= probe;
<a name="l02169"></a>02169       }
<a name="l02170"></a>02170       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l02171"></a>02171 
<a name="l02172"></a>02172       <span class="comment">// Find reachable squares below the rook.</span>
<a name="l02173"></a>02173       probe = pos;
<a name="l02174"></a>02174       <span class="keywordflow">do</span>
<a name="l02175"></a>02175       {
<a name="l02176"></a>02176         move(probe, down);
<a name="l02177"></a>02177         reachables |= probe;
<a name="l02178"></a>02178       }
<a name="l02179"></a>02179       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l02180"></a>02180 
<a name="l02181"></a>02181       <span class="comment">// Result so far.</span>
<a name="l02182"></a>02182       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> result(reachables);
<a name="l02183"></a>02183 
<a name="l02184"></a>02184       <span class="comment">// Find reachable squares left of the rook.</span>
<a name="l02185"></a>02185       block |= <a class="code" href="namespacecwchess.html#adfb6784a238922e3b2a2e2c01269deb9" title="The h-file.">file_h</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l02186"></a>02186       probe = pos;
<a name="l02187"></a>02187       <span class="keywordflow">do</span>
<a name="l02188"></a>02188       {
<a name="l02189"></a>02189         move(probe, left);
<a name="l02190"></a>02190         reachables |= probe;
<a name="l02191"></a>02191       }
<a name="l02192"></a>02192       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l02193"></a>02193       reachables&amp; = ~<a class="code" href="namespacecwchess.html#adfb6784a238922e3b2a2e2c01269deb9" title="The h-file.">file_h</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l02194"></a>02194 
<a name="l02195"></a>02195       <span class="comment">// Update result.</span>
<a name="l02196"></a>02196       result |= reachables;
<a name="l02197"></a>02197 
<a name="l02198"></a>02198       <span class="comment">// Find reachable squares right of the rook.</span>
<a name="l02199"></a>02199       block = all_pieces() | <a class="code" href="namespacecwchess.html#a3d47283c624760531b65ae0e88e40be9" title="The a-file.">file_a</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l02200"></a>02200       probe = pos;
<a name="l02201"></a>02201       <span class="keywordflow">do</span>
<a name="l02202"></a>02202       {
<a name="l02203"></a>02203         move(probe, right);
<a name="l02204"></a>02204         reachables |= probe;
<a name="l02205"></a>02205       }
<a name="l02206"></a>02206       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l02207"></a>02207       reachables&amp; = ~<a class="code" href="namespacecwchess.html#a3d47283c624760531b65ae0e88e40be9" title="The a-file.">file_a</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l02208"></a>02208 
<a name="l02209"></a>02209       result |= reachables;
<a name="l02210"></a>02210       result.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>(M_bitboards[color]);                         <span class="comment">// We cannot take our own pieces.</span>
<a name="l02211"></a>02211       <span class="keywordflow">return</span> result;
<a name="l02212"></a>02212     }
<a name="l02213"></a>02213     <span class="keywordflow">case</span> <a class="code" href="namespacecwchess.html#a7924988a8664b174aed31ec9c5641b8d" title="The underlaying integral value of type&amp; #39;knight&amp;#39;.">knight_bits</a>:
<a name="l02214"></a>02214     {
<a name="l02215"></a>02215       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> result(candidates_table[<a class="code" href="classcwchess_1_1ChessPosition.html#a3a4bfb81ed0560b839522ccda16476d9" title="Return the offset into the candidates_table for type type.">candidates_table_offset</a>(<a class="code" href="namespacecwchess.html#abf2c4ea392fe31bf861f9eb143ca299a" title="A constant representing a knight.">knight</a>) + index()]);
<a name="l02216"></a>02216       result.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>(M_bitboards[color]);
<a name="l02217"></a>02217       <span class="keywordflow">return</span> result;
<a name="l02218"></a>02218     }
<a name="l02219"></a>02219     <span class="keywordflow">case</span> <a class="code" href="namespacecwchess.html#a552144ab0ca73853eeaf4db7eb1752a3" title="The underlaying integral value of type&amp; #39;bishop&amp;#39;.">bishop_bits</a>:
<a name="l02220"></a>02220     {
<a name="l02221"></a>02221       <span class="comment">// Find reachable squares left below the bishop.</span>
<a name="l02222"></a>02222       <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> block = all_pieces() | <a class="code" href="namespacecwchess.html#adfb6784a238922e3b2a2e2c01269deb9" title="The h-file.">file_h</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l02223"></a>02223       <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> probe = pos;
<a name="l02224"></a>02224       <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> <a class="code" href="classcwchess_1_1ChessPosition.html#aee80b4a992db9fbbb10c380d7d1dc612" title="Return a BitBoard with bits set for each square that a piece can reach in one move.">reachables</a> = 0;
<a name="l02225"></a>02225       <span class="keywordflow">do</span>
<a name="l02226"></a>02226       {
<a name="l02227"></a>02227         move(probe, down_left);
<a name="l02228"></a>02228         reachables |= probe;
<a name="l02229"></a>02229       }
<a name="l02230"></a>02230       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l02231"></a>02231 
<a name="l02232"></a>02232       <span class="comment">// Find reachable squares left above the bishop.</span>
<a name="l02233"></a>02233       probe = pos;
<a name="l02234"></a>02234       <span class="keywordflow">do</span>
<a name="l02235"></a>02235       {
<a name="l02236"></a>02236         move(probe, up_left);
<a name="l02237"></a>02237         reachables |= probe;
<a name="l02238"></a>02238       }
<a name="l02239"></a>02239       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l02240"></a>02240       reachables&amp; = ~<a class="code" href="namespacecwchess.html#adfb6784a238922e3b2a2e2c01269deb9" title="The h-file.">file_h</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l02241"></a>02241 
<a name="l02242"></a>02242       <span class="comment">// Result so far.</span>
<a name="l02243"></a>02243       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> result(reachables);
<a name="l02244"></a>02244 
<a name="l02245"></a>02245       <span class="comment">// Find reachable squares right above the bishop;</span>
<a name="l02246"></a>02246       block = all_pieces() | <a class="code" href="namespacecwchess.html#a3d47283c624760531b65ae0e88e40be9" title="The a-file.">file_a</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l02247"></a>02247       probe = pos;
<a name="l02248"></a>02248       <span class="keywordflow">do</span>
<a name="l02249"></a>02249       {
<a name="l02250"></a>02250         move(probe, up_right);
<a name="l02251"></a>02251         reachables |= probe;
<a name="l02252"></a>02252       }
<a name="l02253"></a>02253       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l02254"></a>02254 
<a name="l02255"></a>02255       <span class="comment">// Find reachable squares right below the bishop;</span>
<a name="l02256"></a>02256       probe = pos;
<a name="l02257"></a>02257       <span class="keywordflow">do</span>
<a name="l02258"></a>02258       {
<a name="l02259"></a>02259         move(probe, down_right);
<a name="l02260"></a>02260         reachables |= probe;
<a name="l02261"></a>02261       }
<a name="l02262"></a>02262       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l02263"></a>02263       reachables&amp; = ~<a class="code" href="namespacecwchess.html#a3d47283c624760531b65ae0e88e40be9" title="The a-file.">file_a</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l02264"></a>02264 
<a name="l02265"></a>02265       result |= reachables;
<a name="l02266"></a>02266       result.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>(M_bitboards[color]);
<a name="l02267"></a>02267       <span class="keywordflow">return</span> result;
<a name="l02268"></a>02268     }
<a name="l02269"></a>02269     <span class="keywordflow">case</span> <a class="code" href="namespacecwchess.html#adab49cfc55425a26aff6958a85ce1ff6" title="The underlaying integral value of type&amp; #39;queen&amp;#39;.">queen_bits</a>:
<a name="l02270"></a>02270     {
<a name="l02271"></a>02271       <span class="comment">// Find reachable squares above the queen.</span>
<a name="l02272"></a>02272       <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> block = all_pieces();
<a name="l02273"></a>02273       <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> probe = pos;
<a name="l02274"></a>02274       <a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a> <a class="code" href="classcwchess_1_1ChessPosition.html#aee80b4a992db9fbbb10c380d7d1dc612" title="Return a BitBoard with bits set for each square that a piece can reach in one move.">reachables</a> = 0;
<a name="l02275"></a>02275       <span class="keywordflow">do</span>
<a name="l02276"></a>02276       {
<a name="l02277"></a>02277         move(probe, up);
<a name="l02278"></a>02278         reachables |= probe;
<a name="l02279"></a>02279       }
<a name="l02280"></a>02280       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l02281"></a>02281 
<a name="l02282"></a>02282       <span class="comment">// Find reachable squares below the queen.</span>
<a name="l02283"></a>02283       probe = pos;
<a name="l02284"></a>02284       <span class="keywordflow">do</span>
<a name="l02285"></a>02285       {
<a name="l02286"></a>02286         move(probe, down);
<a name="l02287"></a>02287         reachables |= probe;
<a name="l02288"></a>02288       }
<a name="l02289"></a>02289       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l02290"></a>02290 
<a name="l02291"></a>02291       <span class="comment">// Result so far.</span>
<a name="l02292"></a>02292       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> result(reachables);
<a name="l02293"></a>02293 
<a name="l02294"></a>02294       <span class="comment">// Find reachable squares left of the queen.</span>
<a name="l02295"></a>02295       block |= <a class="code" href="namespacecwchess.html#adfb6784a238922e3b2a2e2c01269deb9" title="The h-file.">file_h</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l02296"></a>02296       probe = pos;
<a name="l02297"></a>02297       <span class="keywordflow">do</span>
<a name="l02298"></a>02298       {
<a name="l02299"></a>02299         move(probe, left);
<a name="l02300"></a>02300         reachables |= probe;
<a name="l02301"></a>02301       }
<a name="l02302"></a>02302       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l02303"></a>02303 
<a name="l02304"></a>02304       <span class="comment">// Find reachable squares left below the queen.</span>
<a name="l02305"></a>02305       probe = pos;
<a name="l02306"></a>02306       <span class="keywordflow">do</span>
<a name="l02307"></a>02307       {
<a name="l02308"></a>02308         move(probe, down_left);
<a name="l02309"></a>02309         reachables |= probe;
<a name="l02310"></a>02310       }
<a name="l02311"></a>02311       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l02312"></a>02312 
<a name="l02313"></a>02313       <span class="comment">// Find reachable squares left above the bishop.</span>
<a name="l02314"></a>02314       probe = pos;
<a name="l02315"></a>02315       <span class="keywordflow">do</span>
<a name="l02316"></a>02316       {
<a name="l02317"></a>02317         move(probe, up_left);
<a name="l02318"></a>02318         reachables |= probe;
<a name="l02319"></a>02319       }
<a name="l02320"></a>02320       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l02321"></a>02321       reachables&amp; = ~<a class="code" href="namespacecwchess.html#adfb6784a238922e3b2a2e2c01269deb9" title="The h-file.">file_h</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l02322"></a>02322 
<a name="l02323"></a>02323       <span class="comment">// Update result.</span>
<a name="l02324"></a>02324       result |= reachables;
<a name="l02325"></a>02325 
<a name="l02326"></a>02326       <span class="comment">// Find reachable squares right of the queen.</span>
<a name="l02327"></a>02327       block = all_pieces() | <a class="code" href="namespacecwchess.html#a3d47283c624760531b65ae0e88e40be9" title="The a-file.">file_a</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l02328"></a>02328       probe = pos;
<a name="l02329"></a>02329       <span class="keywordflow">do</span>
<a name="l02330"></a>02330       {
<a name="l02331"></a>02331         move(probe, right);
<a name="l02332"></a>02332         reachables |= probe;
<a name="l02333"></a>02333       }
<a name="l02334"></a>02334       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l02335"></a>02335 
<a name="l02336"></a>02336       <span class="comment">// Find reachable squares right above the queen;</span>
<a name="l02337"></a>02337       probe = pos;
<a name="l02338"></a>02338       <span class="keywordflow">do</span>
<a name="l02339"></a>02339       {
<a name="l02340"></a>02340         move(probe, up_right);
<a name="l02341"></a>02341         reachables |= probe;
<a name="l02342"></a>02342       }
<a name="l02343"></a>02343       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l02344"></a>02344 
<a name="l02345"></a>02345       <span class="comment">// Find reachable squares right below the queen;</span>
<a name="l02346"></a>02346       probe = pos;
<a name="l02347"></a>02347       <span class="keywordflow">do</span>
<a name="l02348"></a>02348       {
<a name="l02349"></a>02349         move(probe, down_right);
<a name="l02350"></a>02350         reachables |= probe;
<a name="l02351"></a>02351       }
<a name="l02352"></a>02352       <span class="keywordflow">while</span>((block &amp; probe) != probe);
<a name="l02353"></a>02353       reachables&amp; = ~<a class="code" href="namespacecwchess.html#a3d47283c624760531b65ae0e88e40be9" title="The a-file.">file_a</a>.<a class="code" href="structcwchess_1_1BitBoardData.html#abe143f30c7296af18eea3225bbaf98e2" title="A one-bit-per-square chessboard mask.">M_bitmask</a>;
<a name="l02354"></a>02354 
<a name="l02355"></a>02355       result |= reachables;
<a name="l02356"></a>02356       result.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>(M_bitboards[color]);
<a name="l02357"></a>02357       <span class="keywordflow">return</span> result;
<a name="l02358"></a>02358     }
<a name="l02359"></a>02359     <span class="keywordflow">case</span> <a class="code" href="namespacecwchess.html#a2029e96ee5e55a229499d823a87590d5" title="The underlaying integral value of type&amp; #39;king&amp;#39;.">king_bits</a>:
<a name="l02360"></a>02360     {
<a name="l02361"></a>02361       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> result(candidates_table[<a class="code" href="classcwchess_1_1ChessPosition.html#a3a4bfb81ed0560b839522ccda16476d9" title="Return the offset into the candidates_table for type type.">candidates_table_offset</a>(<a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>) + index()]);
<a name="l02362"></a>02362       result.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>(M_bitboards[color]);
<a name="l02363"></a>02363       <span class="keywordflow">if</span> (attacked_squares || !M_castle_flags.<a class="code" href="classcwchess_1_1CastleFlags.html#a80c674a9f946728449e6e98ea04de286" title="Return TRUE if color is still allowed to castle at all (not taking into account checks).">can_castle</a>(color))
<a name="l02364"></a>02364         <span class="keywordflow">return</span> result;
<a name="l02365"></a>02365       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> long_castle_squares(0), short_castle_squares(0);
<a name="l02366"></a>02366       <span class="keywordtype">bool</span> can_castle_long = <span class="keyword">false</span>, can_castle_short = <span class="keyword">false</span>;
<a name="l02367"></a>02367       <span class="keywordflow">if</span> (M_castle_flags.<a class="code" href="classcwchess_1_1CastleFlags.html#ad33ef250470fc5c29301e00fe3e4fef1" title="Return TRUE if color is still allowed to castle short (not taking into account checks).">can_castle_short</a>(color))
<a name="l02368"></a>02368       {
<a name="l02369"></a>02369         short_castle_squares = <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a>((color == white) ? <a class="code" href="namespacecwchess.html#a23fadaf58dcb16fc0bc0395f039de249" title="The square f1.">f1</a>|<a class="code" href="namespacecwchess.html#a02e72925cbba35b84a57098937038a82" title="The square g1.">g1</a> : <a class="code" href="namespacecwchess.html#aff288bfff8981db16f26af3a65101753" title="The square f8.">f8</a>|<a class="code" href="namespacecwchess.html#a75454d74f1871d782d4e17e3fb3c4c3c" title="The square g8.">g8</a>);
<a name="l02370"></a>02370         <span class="keywordflow">if</span> (!(all_pieces &amp; short_castle_squares))
<a name="l02371"></a>02371         {
<a name="l02372"></a>02372           can_castle_short = <span class="keyword">true</span>;
<a name="l02373"></a>02373           short_castle_squares.reset(<a class="code" href="namespacecwchess.html#a23fadaf58dcb16fc0bc0395f039de249" title="The square f1.">f1</a>|<a class="code" href="namespacecwchess.html#aff288bfff8981db16f26af3a65101753" title="The square f8.">f8</a>);
<a name="l02374"></a>02374         }
<a name="l02375"></a>02375       }
<a name="l02376"></a>02376       <span class="keywordflow">if</span> (M_castle_flags.<a class="code" href="classcwchess_1_1CastleFlags.html#a3f4986eb202c3bff8c02aedff97b437f" title="Return TRUE if color is still allowed to castle long (not taking into account checks).">can_castle_long</a>(color))
<a name="l02377"></a>02377       {
<a name="l02378"></a>02378         long_castle_squares = <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a>((color == white) ? <a class="code" href="namespacecwchess.html#acf2e1e72df379cedeac4df261d796493" title="The square b1.">b1</a>|<a class="code" href="namespacecwchess.html#a0896a3a8029e53e586f05ec9eb21bffd" title="The square c1.">c1</a>|<a class="code" href="namespacecwchess.html#aa5a841f9848acab6459785599ff1d432" title="The square d1.">d1</a> : <a class="code" href="namespacecwchess.html#ade82b7f9987d4dc681fa950680d27858" title="The square b8.">b8</a>|<a class="code" href="namespacecwchess.html#ad5b79e9361734b940e757b59df4e15d6" title="The square c8.">c8</a>|<a class="code" href="namespacecwchess.html#a2d5ee4c05f3a3f4649a81094ec972338" title="The square d8.">d8</a>);
<a name="l02379"></a>02379         <span class="keywordflow">if</span> (!(all_pieces &amp; long_castle_squares))
<a name="l02380"></a>02380         {
<a name="l02381"></a>02381           can_castle_long = <span class="keyword">true</span>;
<a name="l02382"></a>02382           long_castle_squares.reset(<a class="code" href="namespacecwchess.html#acf2e1e72df379cedeac4df261d796493" title="The square b1.">b1</a>|<a class="code" href="namespacecwchess.html#ade82b7f9987d4dc681fa950680d27858" title="The square b8.">b8</a>|<a class="code" href="namespacecwchess.html#aa5a841f9848acab6459785599ff1d432" title="The square d1.">d1</a>|<a class="code" href="namespacecwchess.html#a2d5ee4c05f3a3f4649a81094ec972338" title="The square d8.">d8</a>);
<a name="l02383"></a>02383         }
<a name="l02384"></a>02384       }
<a name="l02385"></a>02385       <span class="keywordflow">if</span> (can_castle_short || can_castle_long)
<a name="l02386"></a>02386       {
<a name="l02387"></a>02387         <span class="comment">// Check if the king or any of the squares involved in the castling is in check.</span>
<a name="l02388"></a>02388         <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> attacked_squares;
<a name="l02389"></a>02389         attacked_squares.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>();
<a name="l02390"></a>02390         <span class="keywordflow">for</span> (PieceIterator iter = <a class="code" href="classcwchess_1_1ChessPosition.html#a25644a18e4c41d8f8620474fd34159e7" title="Return an iterator to the first piece of color color.">piece_begin</a>(color.opposite()); iter != <a class="code" href="classcwchess_1_1ChessPosition.html#ae3c2f52411c85422dff0d0689cd7249a" title="Return an iterator one beyond the last piece.">piece_end</a>(); ++iter)
<a name="l02391"></a>02391           attacked_squares |= <a class="code" href="classcwchess_1_1ChessPosition.html#aee80b4a992db9fbbb10c380d7d1dc612" title="Return a BitBoard with bits set for each square that a piece can reach in one move.">reachables</a>(iter.index(), <span class="keyword">true</span>);
<a name="l02392"></a>02392         <span class="keywordflow">if</span> (can_castle_short &amp;&amp; !(attacked_squares &amp; ((color == white) ? (<a class="code" href="namespacecwchess.html#aed12efb4dd96e683489cfdb1b4400185" title="The square e1.">e1</a>|<a class="code" href="namespacecwchess.html#a23fadaf58dcb16fc0bc0395f039de249" title="The square f1.">f1</a>|<a class="code" href="namespacecwchess.html#a02e72925cbba35b84a57098937038a82" title="The square g1.">g1</a>) : (<a class="code" href="namespacecwchess.html#ae448d6728ae79154c7f71546b29bdde3" title="The square e8.">e8</a>|<a class="code" href="namespacecwchess.html#aff288bfff8981db16f26af3a65101753" title="The square f8.">f8</a>|<a class="code" href="namespacecwchess.html#a75454d74f1871d782d4e17e3fb3c4c3c" title="The square g8.">g8</a>))))
<a name="l02393"></a>02393           result |= short_castle_squares;
<a name="l02394"></a>02394         <span class="keywordflow">if</span> (can_castle_long &amp;&amp; !(attacked_squares &amp; ((color == white) ? (<a class="code" href="namespacecwchess.html#a0896a3a8029e53e586f05ec9eb21bffd" title="The square c1.">c1</a>|<a class="code" href="namespacecwchess.html#aa5a841f9848acab6459785599ff1d432" title="The square d1.">d1</a>|<a class="code" href="namespacecwchess.html#aed12efb4dd96e683489cfdb1b4400185" title="The square e1.">e1</a>) : (<a class="code" href="namespacecwchess.html#ad5b79e9361734b940e757b59df4e15d6" title="The square c8.">c8</a>|<a class="code" href="namespacecwchess.html#a2d5ee4c05f3a3f4649a81094ec972338" title="The square d8.">d8</a>|<a class="code" href="namespacecwchess.html#ae448d6728ae79154c7f71546b29bdde3" title="The square e8.">e8</a>))))
<a name="l02395"></a>02395           result |= long_castle_squares;
<a name="l02396"></a>02396       }
<a name="l02397"></a>02397       <span class="keywordflow">return</span> result;
<a name="l02398"></a>02398     }
<a name="l02399"></a>02399   }
<a name="l02400"></a>02400   <span class="keywordflow">return</span> <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a>();    <span class="comment">// Never reached.</span>
<a name="l02401"></a>02401 }
<a name="l02402"></a>02402 
<a name="l02403"></a><a class="code" href="classcwchess_1_1ChessPosition.html#a0e1f2bd6c23841b7f9afbc10cd2b4548">02403</a> <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> <a class="code" href="classcwchess_1_1ChessPosition.html#a0e1f2bd6c23841b7f9afbc10cd2b4548" title="Return a BitBoard with bits set for each square the piece at index can legally go to...">ChessPosition::moves</a>(<a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> <span class="keyword">const</span>&amp; index)<span class="keyword"> const</span>
<a name="l02404"></a>02404 <span class="keyword"></span>{
<a name="l02405"></a>02405   <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> code(M_pieces[index].code());
<a name="l02406"></a>02406   <a class="code" href="classcwchess_1_1Color.html" title="A color (black or white).">Color</a> color(code.<a class="code" href="classcwchess_1_1Code.html#a2b9dbbd896e9440d88fc894e4c9c79ef" title="Return the Color of this Code.">color</a>());
<a name="l02407"></a>02407 
<a name="l02408"></a>02408   <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> <a class="code" href="classcwchess_1_1ChessPosition.html#aee80b4a992db9fbbb10c380d7d1dc612" title="Return a BitBoard with bits set for each square that a piece can reach in one move.">reachables</a>(this-&gt;<a class="code" href="classcwchess_1_1ChessPosition.html#aee80b4a992db9fbbb10c380d7d1dc612" title="Return a BitBoard with bits set for each square that a piece can reach in one move.">reachables</a>(index));
<a name="l02409"></a>02409 
<a name="l02410"></a>02410   <span class="comment">// If it is NOT this colors turn then it is not in check (that would be impossible in a legal position).</span>
<a name="l02411"></a>02411   <span class="comment">// Are we in check?</span>
<a name="l02412"></a>02412   <span class="keywordflow">if</span> (__builtin_expect(color == M_to_move &amp;&amp; M_castle_flags.in_check(M_to_move), <span class="keyword">false</span>))
<a name="l02413"></a>02413   {
<a name="l02414"></a>02414     <span class="keywordtype">bool</span> is_king = code.<a class="code" href="classcwchess_1_1Code.html#a7e9e51ca2eb4c4fb0147e2373ec7dfcb" title="Returns TRUE if the type is equal.">is_a</a>(<a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>);
<a name="l02415"></a>02415     <span class="comment">// If we are in double check, then we can only move with the king.</span>
<a name="l02416"></a>02416     <span class="keywordflow">if</span> (__builtin_expect(M_double_check &amp;&amp; !is_king, <span class="keyword">false</span>))
<a name="l02417"></a>02417       <span class="keywordflow">return</span> <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a>((<a class="code" href="namespacecwchess.html#ab1d6a64ceb5543fa19fab14a4fd7a1fb" title="The type of an internal BitBoard mask.">mask_t</a>)0);
<a name="l02418"></a>02418     <span class="comment">// We can only move a non-king if we can take the piece that</span>
<a name="l02419"></a>02419     <span class="comment">// gives check, or place something in front of it.</span>
<a name="l02420"></a>02420     <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> attacker_squares;
<a name="l02421"></a>02421     attacker_squares.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>();
<a name="l02422"></a>02422     <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> king_code(color, <a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>);
<a name="l02423"></a>02423     <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> king_pos(M_bitboards[king_code]);
<a name="l02424"></a>02424     <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> king_index(<a class="code" href="namespacecwchess.html#a556a7930206c9c994411661cd2896dd1" title="Convert a single bit mask into it&amp;#39;s Index.">mask2index</a>(king_pos()));
<a name="l02425"></a>02425     <span class="keywordflow">if</span> (__builtin_expect(!M_double_check &amp;&amp; !is_king, <span class="keyword">true</span>))
<a name="l02426"></a>02426     {
<a name="l02427"></a>02427       <span class="keywordflow">if</span> (color == black)
<a name="l02428"></a>02428       {
<a name="l02429"></a>02429         <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> queenside_pawn(king_pos() &gt;&gt; 9);
<a name="l02430"></a>02430         <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> kingside_pawn(king_pos() &gt;&gt; 7);
<a name="l02431"></a>02431         queenside_pawn.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>(<a class="code" href="namespacecwchess.html#adfb6784a238922e3b2a2e2c01269deb9" title="The h-file.">file_h</a>);
<a name="l02432"></a>02432         kingside_pawn.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>(<a class="code" href="namespacecwchess.html#a3d47283c624760531b65ae0e88e40be9" title="The a-file.">file_a</a>);
<a name="l02433"></a>02433         attacker_squares = (queenside_pawn | kingside_pawn) &amp; M_bitboards[<a class="code" href="namespacecwchess.html#acbefae1953a03a417fcf2b5c9e3b55a6" title="A constant representing a white pawn.">white_pawn</a>];
<a name="l02434"></a>02434         attacker_squares |= candidates_table[<a class="code" href="classcwchess_1_1ChessPosition.html#a3a4bfb81ed0560b839522ccda16476d9" title="Return the offset into the candidates_table for type type.">candidates_table_offset</a>(<a class="code" href="namespacecwchess.html#abf2c4ea392fe31bf861f9eb143ca299a" title="A constant representing a knight.">knight</a>) + king_index()] &amp; M_bitboards[<a class="code" href="namespacecwchess.html#ac5d3fa3f8d7a0079402d1aa4e929e899" title="A constant representing a white knight.">white_knight</a>];
<a name="l02435"></a>02435       }
<a name="l02436"></a>02436       <span class="keywordflow">else</span>
<a name="l02437"></a>02437       {
<a name="l02438"></a>02438         <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> queenside_pawn(king_pos() &lt;&lt; 7);
<a name="l02439"></a>02439         <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> kingside_pawn(king_pos() &lt;&lt; 9);
<a name="l02440"></a>02440         queenside_pawn.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>(<a class="code" href="namespacecwchess.html#adfb6784a238922e3b2a2e2c01269deb9" title="The h-file.">file_h</a>);
<a name="l02441"></a>02441         kingside_pawn.<a class="code" href="classcwchess_1_1BitBoard.html#a469f67066f6268c3c309ced1bdbd0f30" title="Set all values to FALSE.">reset</a>(<a class="code" href="namespacecwchess.html#a3d47283c624760531b65ae0e88e40be9" title="The a-file.">file_a</a>);
<a name="l02442"></a>02442         attacker_squares = (queenside_pawn | kingside_pawn) &amp; M_bitboards[<a class="code" href="namespacecwchess.html#acd891cc1843e2bce6978c194647c928a" title="A constant representing a black pawn.">black_pawn</a>];
<a name="l02443"></a>02443         attacker_squares |= candidates_table[<a class="code" href="classcwchess_1_1ChessPosition.html#a3a4bfb81ed0560b839522ccda16476d9" title="Return the offset into the candidates_table for type type.">candidates_table_offset</a>(<a class="code" href="namespacecwchess.html#abf2c4ea392fe31bf861f9eb143ca299a" title="A constant representing a knight.">knight</a>) + king_index()] &amp; M_bitboards[<a class="code" href="namespacecwchess.html#a6c981700ed6a1f49ec1230fa8c57b320" title="A constant representing a black knight;.">black_knight</a>];
<a name="l02444"></a>02444       }
<a name="l02445"></a>02445     }
<a name="l02446"></a>02446     <span class="comment">// If attacker_squares were found then we&#39;re not in double check and we already found a check by a pawn or knight,</span>
<a name="l02447"></a>02447     <span class="comment">// so there is no need to look for checks by sliding pieces.</span>
<a name="l02448"></a>02448     <span class="keywordflow">if</span> (!attacker_squares)
<a name="l02449"></a>02449     {
<a name="l02450"></a>02450       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> <span class="keyword">const</span> all_pieces(M_bitboards[white] | M_bitboards[black]);
<a name="l02451"></a>02451       <a class="code" href="classcwchess_1_1Color.html" title="A color (black or white).">Color</a> opposite_color(color.opposite());
<a name="l02452"></a>02452       <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> rook_code(opposite_color, <a class="code" href="namespacecwchess.html#a4ff984a16c54b56749db5209e31b29f9" title="A constant representing a rook.">rook</a>);
<a name="l02453"></a>02453       <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> queen_code(opposite_color, <a class="code" href="namespacecwchess.html#ad3a2fc51450ffe511826ea0ddc6781ec" title="A constant representing a queen.">queen</a>);
<a name="l02454"></a>02454       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> rookmovers(candidates_table[<a class="code" href="classcwchess_1_1ChessPosition.html#a3a4bfb81ed0560b839522ccda16476d9" title="Return the offset into the candidates_table for type type.">candidates_table_offset</a>(<a class="code" href="namespacecwchess.html#a4ff984a16c54b56749db5209e31b29f9" title="A constant representing a rook.">rook</a>) + king_index()] &amp; (M_bitboards[rook_code] | M_bitboards[queen_code]));
<a name="l02455"></a>02455       <span class="keywordflow">for</span> (PieceIterator piece_iter(<span class="keyword">this</span>, rookmovers); piece_iter != <a class="code" href="classcwchess_1_1ChessPosition.html#ae3c2f52411c85422dff0d0689cd7249a" title="Return an iterator one beyond the last piece.">piece_end</a>(); ++piece_iter)
<a name="l02456"></a>02456       {
<a name="l02457"></a>02457         <a class="code" href="structcwchess_1_1Direction.html">Direction</a> <span class="keyword">const</span>&amp; direction(direction_from_to(king_index, piece_iter.index()));
<a name="l02458"></a>02458         <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> line(squares_from_to(piece_iter.index(), king_index));
<a name="l02459"></a>02459         <span class="keywordflow">if</span> ((line &amp; all_pieces) == <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a>(piece_iter.index()))
<a name="l02460"></a>02460         {
<a name="l02461"></a>02461           <span class="comment">// We found the rookmover that gives check.</span>
<a name="l02462"></a>02462           <span class="keywordflow">if</span> (is_king)
<a name="l02463"></a>02463           {
<a name="l02464"></a>02464             <span class="comment">// If this wraps around from a-file to h-file or visa versa then that is not a problem: it will be far away from the king.</span>
<a name="l02465"></a>02465             <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> one_step_away_from_attacker(king_index - direction);
<a name="l02466"></a>02466             <span class="comment">// However, we can&#39;t rely on reset() to work for indexes outside the board.</span>
<a name="l02467"></a>02467             <span class="keywordflow">if</span> (one_step_away_from_attacker() &lt; 64)
<a name="l02468"></a>02468               reachables.reset(one_step_away_from_attacker);
<a name="l02469"></a>02469           }
<a name="l02470"></a>02470           <span class="keywordflow">else</span>
<a name="l02471"></a>02471             attacker_squares |= line;
<a name="l02472"></a>02472           <span class="keywordflow">break</span>;
<a name="l02473"></a>02473         }
<a name="l02474"></a>02474       }
<a name="l02475"></a>02475       <span class="keywordflow">if</span> (M_double_check || !attacker_squares)
<a name="l02476"></a>02476       {
<a name="l02477"></a>02477         <a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a> bishop_code(opposite_color, <a class="code" href="namespacecwchess.html#a3f166611f4301dafd492316030d6ecab" title="A constant representing a bishop.">bishop</a>);
<a name="l02478"></a>02478         <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> bishopmovers(candidates_table[<a class="code" href="classcwchess_1_1ChessPosition.html#a3a4bfb81ed0560b839522ccda16476d9" title="Return the offset into the candidates_table for type type.">candidates_table_offset</a>(<a class="code" href="namespacecwchess.html#a3f166611f4301dafd492316030d6ecab" title="A constant representing a bishop.">bishop</a>) + king_index()] &amp; (M_bitboards[bishop_code] | M_bitboards[queen_code]));
<a name="l02479"></a>02479         <span class="keywordflow">for</span> (PieceIterator piece_iter(<span class="keyword">this</span>, bishopmovers); piece_iter != <a class="code" href="classcwchess_1_1ChessPosition.html#ae3c2f52411c85422dff0d0689cd7249a" title="Return an iterator one beyond the last piece.">piece_end</a>(); ++piece_iter)
<a name="l02480"></a>02480         {
<a name="l02481"></a>02481           <a class="code" href="structcwchess_1_1Direction.html">Direction</a> <span class="keyword">const</span>&amp; direction(direction_from_to(king_index, piece_iter.index()));
<a name="l02482"></a>02482           <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> line(squares_from_to(piece_iter.index(), king_index));
<a name="l02483"></a>02483           <span class="keywordflow">if</span> ((line &amp; all_pieces) == piece_iter.index())
<a name="l02484"></a>02484           {
<a name="l02485"></a>02485             <span class="comment">// We found the bishopmover that gives check.</span>
<a name="l02486"></a>02486             <span class="keywordflow">if</span> (is_king)
<a name="l02487"></a>02487             {
<a name="l02488"></a>02488               <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> one_step_away_from_attacker(king_index - direction);
<a name="l02489"></a>02489               <span class="keywordflow">if</span> (one_step_away_from_attacker() &lt; 64)
<a name="l02490"></a>02490                 reachables.reset(one_step_away_from_attacker);
<a name="l02491"></a>02491             }
<a name="l02492"></a>02492             <span class="keywordflow">else</span>
<a name="l02493"></a>02493               attacker_squares |= line;
<a name="l02494"></a>02494             <span class="keywordflow">break</span>;
<a name="l02495"></a>02495           }
<a name="l02496"></a>02496         }
<a name="l02497"></a>02497       }
<a name="l02498"></a>02498     }
<a name="l02499"></a>02499     <span class="keywordflow">if</span> (!is_king)
<a name="l02500"></a>02500     {
<a name="l02501"></a>02501       <span class="comment">// The only possible move is taking the attacker, or placing something in front of it.</span>
<a name="l02502"></a>02502       reachables&amp; = attacker_squares;
<a name="l02503"></a>02503     }
<a name="l02504"></a>02504   }
<a name="l02505"></a>02505   <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> pinning(M_pinning[color]);
<a name="l02506"></a>02506   <span class="keywordflow">if</span> (__builtin_expect(pinning.<a class="code" href="classcwchess_1_1BitBoard.html#acdb49d61eb3a825048c17627d1bc8f10" title="Test if any bit is set at all.">test</a>(index), <span class="keyword">false</span>))
<a name="l02507"></a>02507   {
<a name="l02508"></a>02508     <span class="comment">// Remove squares that would result in a check.</span>
<a name="l02509"></a>02509     <span class="keywordflow">if</span> (code.<a class="code" href="classcwchess_1_1Code.html#a7e9e51ca2eb4c4fb0147e2373ec7dfcb" title="Returns TRUE if the type is equal.">is_a</a>(<a class="code" href="namespacecwchess.html#a6c67ba2364b136bfc37bab16576ff289" title="A constant representing a pawn.">pawn</a>))
<a name="l02510"></a>02510       reachables&amp; = pinning;
<a name="l02511"></a>02511     <span class="keywordflow">else</span>
<a name="l02512"></a>02512     {
<a name="l02513"></a>02513       <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> king_index(<a class="code" href="classcwchess_1_1ChessPosition.html#a2fc4b1d4354a36dbdee3f5bc45f7341b" title="Return the index of the king with color color.">index_of_king</a>(color));
<a name="l02514"></a>02514       <a class="code" href="structcwchess_1_1Direction.html">Direction</a> direction(direction_from_to(king_index, index));
<a name="l02515"></a>02515       <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> line(direction.<a class="code" href="structcwchess_1_1Direction.html#ac774c9ba1cc29045849a85fd7fdd89f8" title="Return a BitBoard with all squares in this direction.">from</a>(king_index));
<a name="l02516"></a>02516       reachables&amp; = line;
<a name="l02517"></a>02517     }
<a name="l02518"></a>02518   }
<a name="l02519"></a>02519   <span class="keywordflow">if</span> (__builtin_expect(M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#a4d2a5402133c3f3c8d001a44786ac02d" title="Return TRUE if the last move was a pawn advancing two squares.">exists</a>() &amp;&amp; M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#ab5c1e1628195e80aef815440a0c8e2b9" title="Return TRUE if taking en passant is not allowed due to horizontal pinning.">pinned</a>() &amp;&amp; code.<a class="code" href="classcwchess_1_1Code.html#a7e9e51ca2eb4c4fb0147e2373ec7dfcb" title="Returns TRUE if the type is equal.">is_a</a>(<a class="code" href="namespacecwchess.html#a6c67ba2364b136bfc37bab16576ff289" title="A constant representing a pawn.">pawn</a>), <span class="keyword">false</span>))
<a name="l02520"></a>02520       reachables.reset(M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#a877e86f096b677f19ddd52a55d29a216" title="Return the index of the square that was passed.">index</a>());           <span class="comment">// Taking en passant is prohibitted.</span>
<a name="l02521"></a>02521   <span class="keywordflow">if</span> (__builtin_expect(code.<a class="code" href="classcwchess_1_1Code.html#a7e9e51ca2eb4c4fb0147e2373ec7dfcb" title="Returns TRUE if the type is equal.">is_a</a>(<a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>), <span class="keyword">false</span>))
<a name="l02522"></a>02522     reachables.reset(M_defended[color.opposite()].any());       <span class="comment">// The king can&#39;t go a square where it puts itself in check.</span>
<a name="l02523"></a>02523 
<a name="l02524"></a>02524   <span class="keywordflow">return</span> reachables;
<a name="l02525"></a>02525 }
<a name="l02526"></a>02526 
<a name="l02527"></a><a class="code" href="classcwchess_1_1ChessPosition.html#aed5a666c172646ccbba6551bf6c1a904">02527</a> <span class="keywordtype">bool</span> <a class="code" href="classcwchess_1_1ChessPosition.html#aed5a666c172646ccbba6551bf6c1a904" title="Return true if the move is a legal move.">ChessPosition::legal</a>(<a class="code" href="classcwchess_1_1Move.html" title="A chess move in a particular chess position.">Move</a> <span class="keyword">const</span>&amp; move)<span class="keyword"> const</span>
<a name="l02528"></a>02528 <span class="keyword"></span>{
<a name="l02529"></a>02529   <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> from(move.<a class="code" href="classcwchess_1_1Move.html#a0789021fb66425b34304eff939767888" title="Return the square the piece moves from.">from</a>());
<a name="l02530"></a>02530   <a class="code" href="classcwchess_1_1Index.html" title="The index of a chess square.">Index</a> to(move.<a class="code" href="classcwchess_1_1Move.html#a0c77b8ba7d99c2a70202781581e41bab" title="Return the square the piece moves to.">to</a>());
<a name="l02531"></a>02531   <span class="comment">// Lets play on the board.</span>
<a name="l02532"></a>02532   <span class="keywordflow">if</span> (to() &gt; 63 || from() &gt; 63)
<a name="l02533"></a>02533     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02534"></a>02534   <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> from_pos(from);
<a name="l02535"></a>02535   <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> to_pos(to);
<a name="l02536"></a>02536   <a class="code" href="classcwchess_1_1Piece.html" title="A particular piece on the board.">Piece</a> <span class="keyword">const</span>&amp; piece(M_pieces[from]);
<a name="l02537"></a>02537   <span class="comment">// Only touch your own pieces.</span>
<a name="l02538"></a>02538   <span class="keywordflow">if</span> (piece.<a class="code" href="classcwchess_1_1Piece.html#aa47a3271f62a9a5fb3a883016509e25d" title="The code of this piece.">code</a>().<a class="code" href="classcwchess_1_1Code.html#ac9bd2b012eda487a8dea719dfae925d3" title="Returns TRUE if the code represents&amp; #39;nothing&amp;#39;.">is_nothing</a>() || piece.<a class="code" href="classcwchess_1_1Piece.html#a4f0beda5729eff7633ace66348f35ae6" title="Return the color of the piece.">color</a>() != M_to_move)
<a name="l02539"></a>02539     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02540"></a>02540   <span class="keywordtype">bool</span> is_pawn_promotion = piece.<a class="code" href="classcwchess_1_1Piece.html#aa47a3271f62a9a5fb3a883016509e25d" title="The code of this piece.">code</a>().<a class="code" href="classcwchess_1_1Code.html#a7e9e51ca2eb4c4fb0147e2373ec7dfcb" title="Returns TRUE if the type is equal.">is_a</a>(<a class="code" href="namespacecwchess.html#a6c67ba2364b136bfc37bab16576ff289" title="A constant representing a pawn.">pawn</a>) &amp;&amp; (to.row() == 0 || to.row() == 7);
<a name="l02541"></a>02541   <span class="comment">// Only allow promotion of pawns.</span>
<a name="l02542"></a>02542   <span class="keywordflow">if</span> (is_pawn_promotion)
<a name="l02543"></a>02543   {
<a name="l02544"></a>02544     <a class="code" href="classcwchess_1_1Type.html" title="A chess piece type.">Type</a> promotion_type(move.<a class="code" href="classcwchess_1_1Move.html#a2fc443d018fa73a07e1e0f611a655768" title="Return the promotion type. Returns empty if this isn&amp;#39;t a promotion.">promotion_type</a>());
<a name="l02545"></a>02545     <span class="keywordflow">if</span> (promotion_type != <a class="code" href="namespacecwchess.html#a4ff984a16c54b56749db5209e31b29f9" title="A constant representing a rook.">rook</a> &amp;&amp; promotion_type != <a class="code" href="namespacecwchess.html#abf2c4ea392fe31bf861f9eb143ca299a" title="A constant representing a knight.">knight</a> &amp;&amp; promotion_type != <a class="code" href="namespacecwchess.html#a3f166611f4301dafd492316030d6ecab" title="A constant representing a bishop.">bishop</a> &amp;&amp; promotion_type != <a class="code" href="namespacecwchess.html#ad3a2fc51450ffe511826ea0ddc6781ec" title="A constant representing a queen.">queen</a>)
<a name="l02546"></a>02546       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02547"></a>02547   }
<a name="l02548"></a>02548   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (move.<a class="code" href="classcwchess_1_1Move.html#a2fc443d018fa73a07e1e0f611a655768" title="Return the promotion type. Returns empty if this isn&amp;#39;t a promotion.">promotion_type</a>() != <a class="code" href="namespacecwchess.html#ada2c41d3cd72288d05e31c3efbd42c12" title="A constant representing the absence of a piece.">nothing</a>)
<a name="l02549"></a>02549     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02550"></a>02550   <span class="comment">// Get all legal squares to move to for this piece and test if we try to go one of them.</span>
<a name="l02551"></a>02551   <span class="keywordflow">return</span> <a class="code" href="classcwchess_1_1ChessPosition.html#a0e1f2bd6c23841b7f9afbc10cd2b4548" title="Return a BitBoard with bits set for each square the piece at index can legally go to...">moves</a>(from).<a class="code" href="classcwchess_1_1BitBoard.html#acdb49d61eb3a825048c17627d1bc8f10" title="Test if any bit is set at all.">test</a>(to_pos);
<a name="l02552"></a>02552 }
<a name="l02553"></a>02553 
<a name="l02554"></a><a class="code" href="classcwchess_1_1ChessPosition.html#a9ed4f387fff81ac293f8fd6a3a929e87">02554</a> <span class="keywordtype">bool</span> <a class="code" href="classcwchess_1_1ChessPosition.html#a9ed4f387fff81ac293f8fd6a3a929e87" title="Execute move move.">ChessPosition::execute</a>(<a class="code" href="classcwchess_1_1Move.html" title="A chess move in a particular chess position.">Move</a> <span class="keyword">const</span>&amp; move)
<a name="l02555"></a>02555 {
<a name="l02556"></a>02556   <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> from_pos(move.<a class="code" href="classcwchess_1_1Move.html#a0789021fb66425b34304eff939767888" title="Return the square the piece moves from.">from</a>());
<a name="l02557"></a>02557   <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> to_pos(move.<a class="code" href="classcwchess_1_1Move.html#a0c77b8ba7d99c2a70202781581e41bab" title="Return the square the piece moves to.">to</a>());
<a name="l02558"></a>02558   <a class="code" href="classcwchess_1_1BitBoard.html" title="A one-boolean-per-square chessboard.">BitBoard</a> all_pieces(M_bitboards[black] | M_bitboards[white]);
<a name="l02559"></a>02559   <span class="keywordtype">bool</span> pawn_move = (from_pos &amp; M_bitboards[<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(M_to_move, <a class="code" href="namespacecwchess.html#a6c67ba2364b136bfc37bab16576ff289" title="A constant representing a pawn.">pawn</a>)]);
<a name="l02560"></a>02560   <span class="keywordtype">bool</span> pawn_advance_or_capture = pawn_move | !!(to_pos &amp; all_pieces);
<a name="l02561"></a>02561   <span class="comment">// Handle en passant.</span>
<a name="l02562"></a>02562   <span class="keywordflow">if</span> (__builtin_expect(M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#a4d2a5402133c3f3c8d001a44786ac02d" title="Return TRUE if the last move was a pawn advancing two squares.">exists</a>(), <span class="keyword">false</span>))
<a name="l02563"></a>02563   {
<a name="l02564"></a>02564     <span class="keywordflow">if</span> (pawn_move &amp;&amp; M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#a877e86f096b677f19ddd52a55d29a216" title="Return the index of the square that was passed.">index</a>() == move.<a class="code" href="classcwchess_1_1Move.html#a0c77b8ba7d99c2a70202781581e41bab" title="Return the square the piece moves to.">to</a>())
<a name="l02565"></a>02565     {
<a name="l02566"></a>02566       <span class="comment">// A pawn was taken en passant, remove it.</span>
<a name="l02567"></a>02567       <span class="comment">// This resets M_en_passant.</span>
<a name="l02568"></a>02568       <a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">place</a>(<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(), M_en_passant.<a class="code" href="classcwchess_1_1EnPassant.html#a9211a09a94a79cddf6030f522c20daae" title="Return the index of the pawn that just advanced two squares.">pawn_index</a>());
<a name="l02569"></a>02569     }
<a name="l02570"></a>02570     <span class="keywordflow">else</span>
<a name="l02571"></a>02571     {
<a name="l02572"></a>02572       <span class="comment">// Clear the right to take en passant.</span>
<a name="l02573"></a>02573       clear_en_passant();
<a name="l02574"></a>02574     }
<a name="l02575"></a>02575   }
<a name="l02576"></a>02576   <span class="comment">// Set en passant flags, if applicable.</span>
<a name="l02577"></a>02577   <span class="keywordflow">if</span> (pawn_move)
<a name="l02578"></a>02578   {
<a name="l02579"></a>02579     uint8_t offset = move.<a class="code" href="classcwchess_1_1Move.html#a0c77b8ba7d99c2a70202781581e41bab" title="Return the square the piece moves to.">to</a>()() - move.<a class="code" href="classcwchess_1_1Move.html#a0789021fb66425b34304eff939767888" title="Return the square the piece moves from.">from</a>()();       <span class="comment">// -16, -9, -8, -7, 7, 8, 9 or 16.</span>
<a name="l02580"></a>02580     <span class="keywordtype">bool</span> pawn_advanced_two_squares = !(offset &amp; 0xf);   <span class="comment">// Only -16 and 16 have the last four bits clear.</span>
<a name="l02581"></a>02581     <span class="keywordflow">if</span> (pawn_advanced_two_squares)
<a name="l02582"></a>02582     {
<a name="l02583"></a>02583       <span class="comment">// Mark that we can take this pawn en passant.</span>
<a name="l02584"></a>02584       <span class="comment">// Toggling the third bit finds the passed square: row 3 becomes row 2, and row 4 becomes row 5.</span>
<a name="l02585"></a>02585       <a class="code" href="structcwchess_1_1IndexData.html" title="The POD base type of class Index.">IndexData</a> passed_square = { move.<a class="code" href="classcwchess_1_1Move.html#a0c77b8ba7d99c2a70202781581e41bab" title="Return the square the piece moves to.">to</a>()() ^ 8 };
<a name="l02586"></a>02586       <a class="code" href="classcwchess_1_1ChessPosition.html#aa5893a55201a592bb4e5ff7fa00fdb26" title="Explicity set the en passant information.">set_en_passant</a>(passed_square);
<a name="l02587"></a>02587       <span class="comment">// set_en_passant toggles the move, toggle it back because we&#39;ll toggle it again below.</span>
<a name="l02588"></a>02588       M_to_move.<a class="code" href="classcwchess_1_1Color.html#a0dac16b632d96296732cbc4f3c2573b4" title="Change the color from black to white or vica versa.">toggle</a>();
<a name="l02589"></a>02589     }
<a name="l02590"></a>02590   }
<a name="l02591"></a>02591 
<a name="l02592"></a>02592   <span class="comment">// FIXME. For now, use place() to execute the move.</span>
<a name="l02593"></a>02593   <a class="code" href="classcwchess_1_1CastleFlags.html" title="A class to keep track of castling rights.">CastleFlags</a> <a class="code" href="classcwchess_1_1ChessPosition.html#a69a0fda7ab90e3b0118292adf1fba81b" title="Return the castle flag object.">castle_flags</a>(M_castle_flags);
<a name="l02594"></a>02594   <a class="code" href="classcwchess_1_1Piece.html" title="A particular piece on the board.">Piece</a> piece(M_pieces[move.<a class="code" href="classcwchess_1_1Move.html#a0789021fb66425b34304eff939767888" title="Return the square the piece moves from.">from</a>()]);
<a name="l02595"></a>02595   <a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">place</a>(<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(), move.<a class="code" href="classcwchess_1_1Move.html#a0789021fb66425b34304eff939767888" title="Return the square the piece moves from.">from</a>());                   <span class="comment">// 160 ns.</span>
<a name="l02596"></a>02596   <span class="keywordflow">if</span> (move.<a class="code" href="classcwchess_1_1Move.html#a6d2d6bf43ade3de4655dc266b763f6eb" title="Return TRUE if this move is a pawn promotion.">is_promotion</a>())
<a name="l02597"></a>02597     <a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">place</a>(<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(M_to_move, move.<a class="code" href="classcwchess_1_1Move.html#a2fc443d018fa73a07e1e0f611a655768" title="Return the promotion type. Returns empty if this isn&amp;#39;t a promotion.">promotion_type</a>()), move.<a class="code" href="classcwchess_1_1Move.html#a0c77b8ba7d99c2a70202781581e41bab" title="Return the square the piece moves to.">to</a>());
<a name="l02598"></a>02598   <span class="keywordflow">else</span>
<a name="l02599"></a>02599   {
<a name="l02600"></a>02600     <a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">place</a>(piece.<a class="code" href="classcwchess_1_1Piece.html#aa47a3271f62a9a5fb3a883016509e25d" title="The code of this piece.">code</a>(), move.<a class="code" href="classcwchess_1_1Move.html#a0c77b8ba7d99c2a70202781581e41bab" title="Return the square the piece moves to.">to</a>());             <span class="comment">// 110 ns.</span>
<a name="l02601"></a>02601     <span class="comment">// Is this a castling?</span>
<a name="l02602"></a>02602     uint8_t col_diff = move.<a class="code" href="classcwchess_1_1Move.html#a0c77b8ba7d99c2a70202781581e41bab" title="Return the square the piece moves to.">to</a>().<a class="code" href="classcwchess_1_1Index.html#aeeeece4a4238c83b806ea83a45db322c" title="Returns the column.">col</a>() - move.<a class="code" href="classcwchess_1_1Move.html#a0789021fb66425b34304eff939767888" title="Return the square the piece moves from.">from</a>().<a class="code" href="classcwchess_1_1Index.html#aeeeece4a4238c83b806ea83a45db322c" title="Returns the column.">col</a>();
<a name="l02603"></a>02603     <span class="keywordflow">if</span> (__builtin_expect(piece.<a class="code" href="classcwchess_1_1Piece.html#aa47a3271f62a9a5fb3a883016509e25d" title="The code of this piece.">code</a>().<a class="code" href="classcwchess_1_1Code.html#a7e9e51ca2eb4c4fb0147e2373ec7dfcb" title="Returns TRUE if the type is equal.">is_a</a>(<a class="code" href="namespacecwchess.html#ae4ab8d0431c04e46a956090ddbadece4" title="A constant representing a king.">king</a>), <span class="keyword">false</span>) &amp;&amp; __builtin_expect(col_diff &amp;&amp; !(col_diff &amp; 1), <span class="keyword">false</span>))
<a name="l02604"></a>02604     {
<a name="l02605"></a>02605       <a class="code" href="structcwchess_1_1IndexData.html" title="The POD base type of class Index.">IndexData</a> rook_from = { move.<a class="code" href="classcwchess_1_1Move.html#a0789021fb66425b34304eff939767888" title="Return the square the piece moves from.">from</a>()() - 4 + 7 * (2 + move.<a class="code" href="classcwchess_1_1Move.html#a0c77b8ba7d99c2a70202781581e41bab" title="Return the square the piece moves to.">to</a>()() - move.<a class="code" href="classcwchess_1_1Move.html#a0789021fb66425b34304eff939767888" title="Return the square the piece moves from.">from</a>()()) / 4 };
<a name="l02606"></a>02606       <a class="code" href="structcwchess_1_1IndexData.html" title="The POD base type of class Index.">IndexData</a> rook_to = { move.<a class="code" href="classcwchess_1_1Move.html#a0789021fb66425b34304eff939767888" title="Return the square the piece moves from.">from</a>()() + (move.<a class="code" href="classcwchess_1_1Move.html#a0c77b8ba7d99c2a70202781581e41bab" title="Return the square the piece moves to.">to</a>()() - move.<a class="code" href="classcwchess_1_1Move.html#a0789021fb66425b34304eff939767888" title="Return the square the piece moves from.">from</a>()()) / 2 };
<a name="l02607"></a>02607       <a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">place</a>(<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(), rook_from);
<a name="l02608"></a>02608       <a class="code" href="classcwchess_1_1ChessPosition.html#af8fed0cf2a596cdcc879e3b23461a65a" title="Place a piece on the board.">place</a>(<a class="code" href="classcwchess_1_1Code.html" title="A chess piece type including color.">Code</a>(M_to_move, <a class="code" href="namespacecwchess.html#a4ff984a16c54b56749db5209e31b29f9" title="A constant representing a rook.">rook</a>), rook_to);
<a name="l02609"></a>02609     }
<a name="l02610"></a>02610   }
<a name="l02611"></a>02611 
<a name="l02612"></a>02612   <span class="comment">// Change whose turn it is.</span>
<a name="l02613"></a>02613   M_to_move.<a class="code" href="classcwchess_1_1Color.html#a0dac16b632d96296732cbc4f3c2573b4" title="Change the color from black to white or vica versa.">toggle</a>();
<a name="l02614"></a>02614 
<a name="l02615"></a>02615   <span class="comment">// FIXME. Correct M_castle_flags again.</span>
<a name="l02616"></a>02616   <span class="keywordtype">bool</span> in_check = M_castle_flags.in_check(M_to_move);
<a name="l02617"></a>02617   M_castle_flags = castle_flags;
<a name="l02618"></a>02618   M_castle_flags.set_check(M_to_move, in_check);
<a name="l02619"></a>02619   M_castle_flags.piece_moved_from(piece, move.<a class="code" href="classcwchess_1_1Move.html#a0789021fb66425b34304eff939767888" title="Return the square the piece moves from.">from</a>());
<a name="l02620"></a>02620 
<a name="l02621"></a>02621   <span class="comment">// Cache whether or not we gave a double check.</span>
<a name="l02622"></a>02622   M_double_check = M_castle_flags.in_check(M_to_move) ? <a class="code" href="classcwchess_1_1ChessPosition.html#a787c6d8859c8e06fe3c95b5464af2ea6" title="Return true if the king of color color is in double check.">double_check</a>(M_to_move) : <span class="keyword">false</span>;
<a name="l02623"></a>02623   <span class="comment">// Increment the counters and return whether or not it&#39;s a draw by the 50 move rule.</span>
<a name="l02624"></a>02624   <span class="keywordflow">return</span> increment_counters(pawn_advance_or_capture);
<a name="l02625"></a>02625 }
<a name="l02626"></a>02626 
<a name="l02627"></a>02627 <a class="code" href="structcwchess_1_1BitBoardData.html" title="The POD base type of class BitBoard.">BitBoardData</a> ChessPosition::candidates_table[5 * 64] = {
<a name="l02628"></a>02628   <span class="comment">// Knight</span>
<a name="l02629"></a>02629   { CW_MASK_T_CONST(0x0000000000020400)}, { CW_MASK_T_CONST(0x0000000000050800)}, { CW_MASK_T_CONST(0x00000000000a1100)}, { CW_MASK_T_CONST(0x0000000000142200)}, 
<a name="l02630"></a>02630   { CW_MASK_T_CONST(0x0000000000284400)}, { CW_MASK_T_CONST(0x0000000000508800)}, { CW_MASK_T_CONST(0x0000000000a01000)}, { CW_MASK_T_CONST(0x0000000000402000)}, 
<a name="l02631"></a>02631   { CW_MASK_T_CONST(0x0000000002040004)}, { CW_MASK_T_CONST(0x0000000005080008)}, { CW_MASK_T_CONST(0x000000000a110011)}, { CW_MASK_T_CONST(0x0000000014220022)}, 
<a name="l02632"></a>02632   { CW_MASK_T_CONST(0x0000000028440044)}, { CW_MASK_T_CONST(0x0000000050880088)}, { CW_MASK_T_CONST(0x00000000a0100010)}, { CW_MASK_T_CONST(0x0000000040200020)}, 
<a name="l02633"></a>02633   { CW_MASK_T_CONST(0x0000000204000402)}, { CW_MASK_T_CONST(0x0000000508000805)}, { CW_MASK_T_CONST(0x0000000a1100110a)}, { CW_MASK_T_CONST(0x0000001422002214)}, 
<a name="l02634"></a>02634   { CW_MASK_T_CONST(0x0000002844004428)}, { CW_MASK_T_CONST(0x0000005088008850)}, { CW_MASK_T_CONST(0x000000a0100010a0)}, { CW_MASK_T_CONST(0x0000004020002040)}, 
<a name="l02635"></a>02635   { CW_MASK_T_CONST(0x0000020400040200)}, { CW_MASK_T_CONST(0x0000050800080500)}, { CW_MASK_T_CONST(0x00000a1100110a00)}, { CW_MASK_T_CONST(0x0000142200221400)}, 
<a name="l02636"></a>02636   { CW_MASK_T_CONST(0x0000284400442800)}, { CW_MASK_T_CONST(0x0000508800885000)}, { CW_MASK_T_CONST(0x0000a0100010a000)}, { CW_MASK_T_CONST(0x0000402000204000)}, 
<a name="l02637"></a>02637   { CW_MASK_T_CONST(0x0002040004020000)}, { CW_MASK_T_CONST(0x0005080008050000)}, { CW_MASK_T_CONST(0x000a1100110a0000)}, { CW_MASK_T_CONST(0x0014220022140000)}, 
<a name="l02638"></a>02638   { CW_MASK_T_CONST(0x0028440044280000)}, { CW_MASK_T_CONST(0x0050880088500000)}, { CW_MASK_T_CONST(0x00a0100010a00000)}, { CW_MASK_T_CONST(0x0040200020400000)}, 
<a name="l02639"></a>02639   { CW_MASK_T_CONST(0x0204000402000000)}, { CW_MASK_T_CONST(0x0508000805000000)}, { CW_MASK_T_CONST(0x0a1100110a000000)}, { CW_MASK_T_CONST(0x1422002214000000)}, 
<a name="l02640"></a>02640   { CW_MASK_T_CONST(0x2844004428000000)}, { CW_MASK_T_CONST(0x5088008850000000)}, { CW_MASK_T_CONST(0xa0100010a0000000)}, { CW_MASK_T_CONST(0x4020002040000000)}, 
<a name="l02641"></a>02641   { CW_MASK_T_CONST(0x0400040200000000)}, { CW_MASK_T_CONST(0x0800080500000000)}, { CW_MASK_T_CONST(0x1100110a00000000)}, { CW_MASK_T_CONST(0x2200221400000000)}, 
<a name="l02642"></a>02642   { CW_MASK_T_CONST(0x4400442800000000)}, { CW_MASK_T_CONST(0x8800885000000000)}, { CW_MASK_T_CONST(0x100010a000000000)}, { CW_MASK_T_CONST(0x2000204000000000)}, 
<a name="l02643"></a>02643   { CW_MASK_T_CONST(0x0004020000000000)}, { CW_MASK_T_CONST(0x0008050000000000)}, { CW_MASK_T_CONST(0x00110a0000000000)}, { CW_MASK_T_CONST(0x0022140000000000)}, 
<a name="l02644"></a>02644   { CW_MASK_T_CONST(0x0044280000000000)}, { CW_MASK_T_CONST(0x0088500000000000)}, { CW_MASK_T_CONST(0x0010a00000000000)}, { CW_MASK_T_CONST(0x0020400000000000)}, 
<a name="l02645"></a>02645   <span class="comment">// King</span>
<a name="l02646"></a>02646   { CW_MASK_T_CONST(0x0000000000000302)}, { CW_MASK_T_CONST(0x0000000000000705)}, { CW_MASK_T_CONST(0x0000000000000e0a)}, { CW_MASK_T_CONST(0x0000000000001c14)}, 
<a name="l02647"></a>02647   { CW_MASK_T_CONST(0x0000000000003828)}, { CW_MASK_T_CONST(0x0000000000007050)}, { CW_MASK_T_CONST(0x000000000000e0a0)}, { CW_MASK_T_CONST(0x000000000000c040)}, 
<a name="l02648"></a>02648   { CW_MASK_T_CONST(0x0000000000030203)}, { CW_MASK_T_CONST(0x0000000000070507)}, { CW_MASK_T_CONST(0x00000000000e0a0e)}, { CW_MASK_T_CONST(0x00000000001c141c)}, 
<a name="l02649"></a>02649   { CW_MASK_T_CONST(0x0000000000382838)}, { CW_MASK_T_CONST(0x0000000000705070)}, { CW_MASK_T_CONST(0x0000000000e0a0e0)}, { CW_MASK_T_CONST(0x0000000000c040c0)}, 
<a name="l02650"></a>02650   { CW_MASK_T_CONST(0x0000000003020300)}, { CW_MASK_T_CONST(0x0000000007050700)}, { CW_MASK_T_CONST(0x000000000e0a0e00)}, { CW_MASK_T_CONST(0x000000001c141c00)}, 
<a name="l02651"></a>02651   { CW_MASK_T_CONST(0x0000000038283800)}, { CW_MASK_T_CONST(0x0000000070507000)}, { CW_MASK_T_CONST(0x00000000e0a0e000)}, { CW_MASK_T_CONST(0x00000000c040c000)}, 
<a name="l02652"></a>02652   { CW_MASK_T_CONST(0x0000000302030000)}, { CW_MASK_T_CONST(0x0000000705070000)}, { CW_MASK_T_CONST(0x0000000e0a0e0000)}, { CW_MASK_T_CONST(0x0000001c141c0000)}, 
<a name="l02653"></a>02653   { CW_MASK_T_CONST(0x0000003828380000)}, { CW_MASK_T_CONST(0x0000007050700000)}, { CW_MASK_T_CONST(0x000000e0a0e00000)}, { CW_MASK_T_CONST(0x000000c040c00000)}, 
<a name="l02654"></a>02654   { CW_MASK_T_CONST(0x0000030203000000)}, { CW_MASK_T_CONST(0x0000070507000000)}, { CW_MASK_T_CONST(0x00000e0a0e000000)}, { CW_MASK_T_CONST(0x00001c141c000000)}, 
<a name="l02655"></a>02655   { CW_MASK_T_CONST(0x0000382838000000)}, { CW_MASK_T_CONST(0x0000705070000000)}, { CW_MASK_T_CONST(0x0000e0a0e0000000)}, { CW_MASK_T_CONST(0x0000c040c0000000)}, 
<a name="l02656"></a>02656   { CW_MASK_T_CONST(0x0003020300000000)}, { CW_MASK_T_CONST(0x0007050700000000)}, { CW_MASK_T_CONST(0x000e0a0e00000000)}, { CW_MASK_T_CONST(0x001c141c00000000)}, 
<a name="l02657"></a>02657   { CW_MASK_T_CONST(0x0038283800000000)}, { CW_MASK_T_CONST(0x0070507000000000)}, { CW_MASK_T_CONST(0x00e0a0e000000000)}, { CW_MASK_T_CONST(0x00c040c000000000)}, 
<a name="l02658"></a>02658   { CW_MASK_T_CONST(0x0302030000000000)}, { CW_MASK_T_CONST(0x0705070000000000)}, { CW_MASK_T_CONST(0x0e0a0e0000000000)}, { CW_MASK_T_CONST(0x1c141c0000000000)}, 
<a name="l02659"></a>02659   { CW_MASK_T_CONST(0x3828380000000000)}, { CW_MASK_T_CONST(0x7050700000000000)}, { CW_MASK_T_CONST(0xe0a0e00000000000)}, { CW_MASK_T_CONST(0xc040c00000000000)}, 
<a name="l02660"></a>02660   { CW_MASK_T_CONST(0x0203000000000000)}, { CW_MASK_T_CONST(0x0507000000000000)}, { CW_MASK_T_CONST(0x0a0e000000000000)}, { CW_MASK_T_CONST(0x141c000000000000)}, 
<a name="l02661"></a>02661   { CW_MASK_T_CONST(0x2838000000000000)}, { CW_MASK_T_CONST(0x5070000000000000)}, { CW_MASK_T_CONST(0xa0e0000000000000)}, { CW_MASK_T_CONST(0x40c0000000000000)}, 
<a name="l02662"></a>02662   <span class="comment">// Bishop</span>
<a name="l02663"></a>02663   { CW_MASK_T_CONST(0x8040201008040200)}, { CW_MASK_T_CONST(0x0080402010080500)}, { CW_MASK_T_CONST(0x0000804020110a00)}, { CW_MASK_T_CONST(0x0000008041221400)}, 
<a name="l02664"></a>02664   { CW_MASK_T_CONST(0x0000000182442800)}, { CW_MASK_T_CONST(0x0000010204885000)}, { CW_MASK_T_CONST(0x000102040810a000)}, { CW_MASK_T_CONST(0x0102040810204000)}, 
<a name="l02665"></a>02665   { CW_MASK_T_CONST(0x4020100804020002)}, { CW_MASK_T_CONST(0x8040201008050005)}, { CW_MASK_T_CONST(0x00804020110a000a)}, { CW_MASK_T_CONST(0x0000804122140014)}, 
<a name="l02666"></a>02666   { CW_MASK_T_CONST(0x0000018244280028)}, { CW_MASK_T_CONST(0x0001020488500050)}, { CW_MASK_T_CONST(0x0102040810a000a0)}, { CW_MASK_T_CONST(0x0204081020400040)}, 
<a name="l02667"></a>02667   { CW_MASK_T_CONST(0x2010080402000204)}, { CW_MASK_T_CONST(0x4020100805000508)}, { CW_MASK_T_CONST(0x804020110a000a11)}, { CW_MASK_T_CONST(0x0080412214001422)}, 
<a name="l02668"></a>02668   { CW_MASK_T_CONST(0x0001824428002844)}, { CW_MASK_T_CONST(0x0102048850005088)}, { CW_MASK_T_CONST(0x02040810a000a010)}, { CW_MASK_T_CONST(0x0408102040004020)}, 
<a name="l02669"></a>02669   { CW_MASK_T_CONST(0x1008040200020408)}, { CW_MASK_T_CONST(0x2010080500050810)}, { CW_MASK_T_CONST(0x4020110a000a1120)}, { CW_MASK_T_CONST(0x8041221400142241)}, 
<a name="l02670"></a>02670   { CW_MASK_T_CONST(0x0182442800284482)}, { CW_MASK_T_CONST(0x0204885000508804)}, { CW_MASK_T_CONST(0x040810a000a01008)}, { CW_MASK_T_CONST(0x0810204000402010)}, 
<a name="l02671"></a>02671   { CW_MASK_T_CONST(0x0804020002040810)}, { CW_MASK_T_CONST(0x1008050005081020)}, { CW_MASK_T_CONST(0x20110a000a112040)}, { CW_MASK_T_CONST(0x4122140014224180)}, 
<a name="l02672"></a>02672   { CW_MASK_T_CONST(0x8244280028448201)}, { CW_MASK_T_CONST(0x0488500050880402)}, { CW_MASK_T_CONST(0x0810a000a0100804)}, { CW_MASK_T_CONST(0x1020400040201008)}, 
<a name="l02673"></a>02673   { CW_MASK_T_CONST(0x0402000204081020)}, { CW_MASK_T_CONST(0x0805000508102040)}, { CW_MASK_T_CONST(0x110a000a11204080)}, { CW_MASK_T_CONST(0x2214001422418000)}, 
<a name="l02674"></a>02674   { CW_MASK_T_CONST(0x4428002844820100)}, { CW_MASK_T_CONST(0x8850005088040201)}, { CW_MASK_T_CONST(0x10a000a010080402)}, { CW_MASK_T_CONST(0x2040004020100804)}, 
<a name="l02675"></a>02675   { CW_MASK_T_CONST(0x0200020408102040)}, { CW_MASK_T_CONST(0x0500050810204080)}, { CW_MASK_T_CONST(0x0a000a1120408000)}, { CW_MASK_T_CONST(0x1400142241800000)}, 
<a name="l02676"></a>02676   { CW_MASK_T_CONST(0x2800284482010000)}, { CW_MASK_T_CONST(0x5000508804020100)}, { CW_MASK_T_CONST(0xa000a01008040201)}, { CW_MASK_T_CONST(0x4000402010080402)}, 
<a name="l02677"></a>02677   { CW_MASK_T_CONST(0x0002040810204080)}, { CW_MASK_T_CONST(0x0005081020408000)}, { CW_MASK_T_CONST(0x000a112040800000)}, { CW_MASK_T_CONST(0x0014224180000000)}, 
<a name="l02678"></a>02678   { CW_MASK_T_CONST(0x0028448201000000)}, { CW_MASK_T_CONST(0x0050880402010000)}, { CW_MASK_T_CONST(0x00a0100804020100)}, { CW_MASK_T_CONST(0x0040201008040201)}, 
<a name="l02679"></a>02679   <span class="comment">// Rook</span>
<a name="l02680"></a>02680   { CW_MASK_T_CONST(0x01010101010101fe)}, { CW_MASK_T_CONST(0x02020202020202fd)}, { CW_MASK_T_CONST(0x04040404040404fb)}, { CW_MASK_T_CONST(0x08080808080808f7)}, 
<a name="l02681"></a>02681   { CW_MASK_T_CONST(0x10101010101010ef)}, { CW_MASK_T_CONST(0x20202020202020df)}, { CW_MASK_T_CONST(0x40404040404040bf)}, { CW_MASK_T_CONST(0x808080808080807f)}, 
<a name="l02682"></a>02682   { CW_MASK_T_CONST(0x010101010101fe01)}, { CW_MASK_T_CONST(0x020202020202fd02)}, { CW_MASK_T_CONST(0x040404040404fb04)}, { CW_MASK_T_CONST(0x080808080808f708)}, 
<a name="l02683"></a>02683   { CW_MASK_T_CONST(0x101010101010ef10)}, { CW_MASK_T_CONST(0x202020202020df20)}, { CW_MASK_T_CONST(0x404040404040bf40)}, { CW_MASK_T_CONST(0x8080808080807f80)}, 
<a name="l02684"></a>02684   { CW_MASK_T_CONST(0x0101010101fe0101)}, { CW_MASK_T_CONST(0x0202020202fd0202)}, { CW_MASK_T_CONST(0x0404040404fb0404)}, { CW_MASK_T_CONST(0x0808080808f70808)}, 
<a name="l02685"></a>02685   { CW_MASK_T_CONST(0x1010101010ef1010)}, { CW_MASK_T_CONST(0x2020202020df2020)}, { CW_MASK_T_CONST(0x4040404040bf4040)}, { CW_MASK_T_CONST(0x80808080807f8080)}, 
<a name="l02686"></a>02686   { CW_MASK_T_CONST(0x01010101fe010101)}, { CW_MASK_T_CONST(0x02020202fd020202)}, { CW_MASK_T_CONST(0x04040404fb040404)}, { CW_MASK_T_CONST(0x08080808f7080808)}, 
<a name="l02687"></a>02687   { CW_MASK_T_CONST(0x10101010ef101010)}, { CW_MASK_T_CONST(0x20202020df202020)}, { CW_MASK_T_CONST(0x40404040bf404040)}, { CW_MASK_T_CONST(0x808080807f808080)}, 
<a name="l02688"></a>02688   { CW_MASK_T_CONST(0x010101fe01010101)}, { CW_MASK_T_CONST(0x020202fd02020202)}, { CW_MASK_T_CONST(0x040404fb04040404)}, { CW_MASK_T_CONST(0x080808f708080808)}, 
<a name="l02689"></a>02689   { CW_MASK_T_CONST(0x101010ef10101010)}, { CW_MASK_T_CONST(0x202020df20202020)}, { CW_MASK_T_CONST(0x404040bf40404040)}, { CW_MASK_T_CONST(0x8080807f80808080)}, 
<a name="l02690"></a>02690   { CW_MASK_T_CONST(0x0101fe0101010101)}, { CW_MASK_T_CONST(0x0202fd0202020202)}, { CW_MASK_T_CONST(0x0404fb0404040404)}, { CW_MASK_T_CONST(0x0808f70808080808)}, 
<a name="l02691"></a>02691   { CW_MASK_T_CONST(0x1010ef1010101010)}, { CW_MASK_T_CONST(0x2020df2020202020)}, { CW_MASK_T_CONST(0x4040bf4040404040)}, { CW_MASK_T_CONST(0x80807f8080808080)}, 
<a name="l02692"></a>02692   { CW_MASK_T_CONST(0x01fe010101010101)}, { CW_MASK_T_CONST(0x02fd020202020202)}, { CW_MASK_T_CONST(0x04fb040404040404)}, { CW_MASK_T_CONST(0x08f7080808080808)}, 
<a name="l02693"></a>02693   { CW_MASK_T_CONST(0x10ef101010101010)}, { CW_MASK_T_CONST(0x20df202020202020)}, { CW_MASK_T_CONST(0x40bf404040404040)}, { CW_MASK_T_CONST(0x807f808080808080)}, 
<a name="l02694"></a>02694   { CW_MASK_T_CONST(0xfe01010101010101)}, { CW_MASK_T_CONST(0xfd02020202020202)}, { CW_MASK_T_CONST(0xfb04040404040404)}, { CW_MASK_T_CONST(0xf708080808080808)}, 
<a name="l02695"></a>02695   { CW_MASK_T_CONST(0xef10101010101010)}, { CW_MASK_T_CONST(0xdf20202020202020)}, { CW_MASK_T_CONST(0xbf40404040404040)}, { CW_MASK_T_CONST(0x7f80808080808080)}, 
<a name="l02696"></a>02696   <span class="comment">// Queen</span>
<a name="l02697"></a>02697   { CW_MASK_T_CONST(0x81412111090503fe)}, { CW_MASK_T_CONST(0x02824222120a07fd)}, { CW_MASK_T_CONST(0x0404844424150efb)}, { CW_MASK_T_CONST(0x08080888492a1cf7)}, 
<a name="l02698"></a>02698   { CW_MASK_T_CONST(0x10101011925438ef)}, { CW_MASK_T_CONST(0x2020212224a870df)}, { CW_MASK_T_CONST(0x404142444850e0bf)}, { CW_MASK_T_CONST(0x8182848890a0c07f)}, 
<a name="l02699"></a>02699   { CW_MASK_T_CONST(0x412111090503fe03)}, { CW_MASK_T_CONST(0x824222120a07fd07)}, { CW_MASK_T_CONST(0x04844424150efb0e)}, { CW_MASK_T_CONST(0x080888492a1cf71c)}, 
<a name="l02700"></a>02700   { CW_MASK_T_CONST(0x101011925438ef38)}, { CW_MASK_T_CONST(0x20212224a870df70)}, { CW_MASK_T_CONST(0x4142444850e0bfe0)}, { CW_MASK_T_CONST(0x82848890a0c07fc0)}, 
<a name="l02701"></a>02701   { CW_MASK_T_CONST(0x2111090503fe0305)}, { CW_MASK_T_CONST(0x4222120a07fd070a)}, { CW_MASK_T_CONST(0x844424150efb0e15)}, { CW_MASK_T_CONST(0x0888492a1cf71c2a)}, 
<a name="l02702"></a>02702   { CW_MASK_T_CONST(0x1011925438ef3854)}, { CW_MASK_T_CONST(0x212224a870df70a8)}, { CW_MASK_T_CONST(0x42444850e0bfe050)}, { CW_MASK_T_CONST(0x848890a0c07fc0a0)}, 
<a name="l02703"></a>02703   { CW_MASK_T_CONST(0x11090503fe030509)}, { CW_MASK_T_CONST(0x22120a07fd070a12)}, { CW_MASK_T_CONST(0x4424150efb0e1524)}, { CW_MASK_T_CONST(0x88492a1cf71c2a49)}, 
<a name="l02704"></a>02704   { CW_MASK_T_CONST(0x11925438ef385492)}, { CW_MASK_T_CONST(0x2224a870df70a824)}, { CW_MASK_T_CONST(0x444850e0bfe05048)}, { CW_MASK_T_CONST(0x8890a0c07fc0a090)}, 
<a name="l02705"></a>02705   { CW_MASK_T_CONST(0x090503fe03050911)}, { CW_MASK_T_CONST(0x120a07fd070a1222)}, { CW_MASK_T_CONST(0x24150efb0e152444)}, { CW_MASK_T_CONST(0x492a1cf71c2a4988)}, 
<a name="l02706"></a>02706   { CW_MASK_T_CONST(0x925438ef38549211)}, { CW_MASK_T_CONST(0x24a870df70a82422)}, { CW_MASK_T_CONST(0x4850e0bfe0504844)}, { CW_MASK_T_CONST(0x90a0c07fc0a09088)}, 
<a name="l02707"></a>02707   { CW_MASK_T_CONST(0x0503fe0305091121)}, { CW_MASK_T_CONST(0x0a07fd070a122242)}, { CW_MASK_T_CONST(0x150efb0e15244484)}, { CW_MASK_T_CONST(0x2a1cf71c2a498808)}, 
<a name="l02708"></a>02708   { CW_MASK_T_CONST(0x5438ef3854921110)}, { CW_MASK_T_CONST(0xa870df70a8242221)}, { CW_MASK_T_CONST(0x50e0bfe050484442)}, { CW_MASK_T_CONST(0xa0c07fc0a0908884)}, 
<a name="l02709"></a>02709   { CW_MASK_T_CONST(0x03fe030509112141)}, { CW_MASK_T_CONST(0x07fd070a12224282)}, { CW_MASK_T_CONST(0x0efb0e1524448404)}, { CW_MASK_T_CONST(0x1cf71c2a49880808)}, 
<a name="l02710"></a>02710   { CW_MASK_T_CONST(0x38ef385492111010)}, { CW_MASK_T_CONST(0x70df70a824222120)}, { CW_MASK_T_CONST(0xe0bfe05048444241)}, { CW_MASK_T_CONST(0xc07fc0a090888482)}, 
<a name="l02711"></a>02711   { CW_MASK_T_CONST(0xfe03050911214181)}, { CW_MASK_T_CONST(0xfd070a1222428202)}, { CW_MASK_T_CONST(0xfb0e152444840404)}, { CW_MASK_T_CONST(0xf71c2a4988080808)}, 
<a name="l02712"></a>02712   { CW_MASK_T_CONST(0xef38549211101010)}, { CW_MASK_T_CONST(0xdf70a82422212020)}, { CW_MASK_T_CONST(0xbfe0504844424140)}, { CW_MASK_T_CONST(0x7fc0a09088848281)}, 
<a name="l02713"></a>02713 };
<a name="l02714"></a>02714 
<a name="l02715"></a>02715 } <span class="comment">// namespace cwchess</span>
</pre></div></div>
</div>
<hr>

<address>Copyright &copy; 2006 - 2010 Carlo Wood.&nbsp; All rights reserved.</address>

</div>
</body>
</html>

