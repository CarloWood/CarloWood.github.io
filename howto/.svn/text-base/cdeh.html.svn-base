<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html LANG="en_US">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="author" content="Carlo Wood">
<meta name="keywords" content="history, environment, directory, directory dependend, bash, cd, pwd, cdeh, linux">
<title>HOWTO </title>
<link href="../css/common.css" rel="stylesheet" type="text/css">
<link href="howto.css" rel="stylesheet" type="text/css">
</head>

<body>

<div id="content" class="cdeh">

<h1>Directory dependent history and environment</h1>

<div id="date">Carlo Wood, Apr 2007</div>

<h2>Table of contents</h2>

<ul>
<li><a href="#introduction">Introduction</a>
<li><a href="#how">How does it work?</a>
<li><a href="#download">Downloading and setting up cdeh</a>
<li><a href="#details">Detailed description</a>
<li><a href="#env.source">Example: A system for environment switching</a>
</ul>

<a name="introduction">
<h2>Introduction</h2>

<p>This page describes how to set up <em>cdeh</em>, a set of
scripts to automatically switch history and environment
(environment variables and aliases) as function of the directory (tree)
that you are in.</p>

<p>If, like me, you like working from the command line, and you
are using <code>bash</code> as your SHELL, then this is for you.</p>

<p>The type of commands someone gives often depend on the
current working directory. Going up through the command line
history, it is annoying having to search for the last time
you gave that particular command when, in fact, it was probably
the last command you gave in a terminal window on that prompt.
Also, if you close a terminal, open a new one and change directory
back to where you were - you don't want to suddenly have your
command history cluttered with unrelated commands.</p>

<p>Especially when you are a developer who works from the command line,
like me, it turns out to be very productive to automatically switch
environment variables and aliases as function of the project directory
that you are in. This makes it possible to create simple aliases for
repetive commands that are nearly the same in every project.
For example, I configure <em>every</em> project by typing
<code>configure</code>; the real command that is executed then depends
on the directory I am in. If I am in
<code>~/projects/edragon/edragon-objdir</code> then the actual command is
<code>../edragon/configure --enable-maintainer-mode --enable-debug --prefix=/usr/local/install/4.1.2-20061115 --disable-pch</code>,
while if I am in <code>~/projects/libecc/libecc-objdir</code> then
the actual command is
<code>../libecc/configure --enable-maintainer-mode --enable-optimization --enable-debug --prefix=/usr/local/install/4.1.2-20061115</code>.
Because these commands seldom change while in the same directory, it is
convenient to have a simple alias for them that is a function of the
directory that I am in.</p>

<a name="how">
<h2>How does it work?</h2>

<p>The switching is linked to the command prompt: whenever a command line
prompt is displayed, the current directory is checked and history/environment
switching is performed when necessary. This is achieved through the
use of the bash environment variable <code>PROMPT_COMMAND</code>.</p>

<p>The actual history switching is done by changing the bash environment
variable that controls the history: <code>HISTFILE</code>.
You are free to use the other <code>HIST*</code>
environment variables (<code>man bash</code>). The environment variables
<code>HISTSIZE</code> and <code>HISTFILESIZE</code> are also used, but
if you set them prior to initialization of cdeh, then their values are
used.</p>

<p>The environment is changed by sourcing any files in your directory tree
that have the name <code>env.source</code>.
These files may contain whatever you want.
Personally, I use a system to facilitate different C++ projects in different
directories, dictating some mandatory content of <code>env.source</code>,
but that is basically independent of how <em>cdeh</em> works and is therefore
described seperately at the end of this document.</p>

<a name="download">
<h2>Downloading and setting up cdeh</h2>

<p>The <em>cdeh</em> system consists of three system wide files, although
it is possible to install them in your home directory if you don't
have root.</p>

<p>There are three system wide files. Normally, the environment variable
<code>CDEHROOT</code> should be set system wide, and the two
files <a href="do_prompt">do_prompt</a> and <a href="env.bashrc">env.bashrc</a>
should be installed in <code>CDEHROOT</code>.
I also have <code>addhistory</code> (see below) installed in
<code>CDEHROOT</code>, and keep a symbolic link from
<code>/usr/local/bin</code> to it.
The directory <code>$CDEHROOT/history</code> should exist,
be owned by root and mode 1777. If you don't have root, then
it should exist, be owned by you and be mode 700.
For example,

<pre>
&gt; cd $CDEHROOT
&gt; ls -l
-rwxr-xr-x 1 root staff   93 2007-04-18 17:04 <a href="addhistory">addhistory</a>*
-rwxr-xr-x 1 root staff 3058 2007-04-18 16:31 <a href="do_prompt">do_prompt</a>*
-rw-r--r-- 1 root staff 2200 2007-04-18 17:24 <a href="env.bashrc">env.bashrc</a>
drwxrwxrwt 4 root root  4096 2007-04-18 15:52 history/
</pre>

<p>The latter needs to be sourced from, for example,
your <code>~/.bashrc</code> file. You can do this by adding the following
line at the bottom of your <code>~/.bashrc</code> file:</p>

<pre>
HISTSIZE=1200                   # Example, the default is 1000.
CDEHROOT=/encrypted/cdeh        # Or define this globally.
. $CDEHROOT/env.bashrc
</pre>

<p>Note the leading dot (.).</p>

<p>By picking an encrypted partition for <code>CDEHROOT</code>,
all history files will be encrypted. This is the reason that the
history files aren't stored in the users home directory by default
(which might not be encrypted).</p>

<p>The script <code>do_prompt</code> sources <code>env.source</code>
files in the highest directory that one is in. Thus, in any case
you will need such a file in the root: <code>/env.source</code>.
For now you can just touch it to create an empty file. See below
for a practical example.</p>

<p>The small script <a href="addhistory">addhistory</a> should be installed
somewhere in your <code>PATH</code> or in <code>CDEHROOT</code>
(to keep everything together), using for example a symlink from
<code>/usr/local/bin</code>.</p>

<p>Running <code>addhistory</code> inside any
directory will start a new history file for that directory and all
of it's subdirectories (that do not already have their own history file).</p>

<a name="details">
<h2>Detailed description</h2>

<h3>env.bashrc</h3>

<p>The following environment variables are set:
<ul>
<li><code><b>CDEHHISTSIZE</b></code> is set to <code>HISTSIZE</code> or,
if that wasn't defined, to 1000.
Subsequentially, <code><b>HISTSIZE</b></code> is reset to
<code>CDEHHISTSIZE</code> every time <code>PROMPT_COMMAND</code> is
executed. Thus, if you wish to use a particular <code>HISTSIZE</code>,
you have to set it <em>before</em> sourcing
<code>env.bashrc</code> &mdash;
or, you can change <code>CDEHHISTSIZE</code> afterwards.
<li>If <code><b>HISTFILESIZE</b></code> isn't already set at the moment that
<code>env.bashrc</code> is sourced, or when its
value is less than <code>CDEHHISTSIZE</code>, then it is set to the
same value as <code>CDEHHISTSIZE</code>.
<li><code><b>CDEHUSER</b></code> is set to <code>"`/usr/bin/whoami`"</code>.
It should be possible to use this as a directory name. It is used
in the path of other files in order to allow the use of this
system by more than one user. The reason that those files aren't stored
in the users home directories is that I want to allow the use of
an encrypted partition for the history files, and the users home directory
doesn't need to be encrypted.
<li><code><b>CDEHHISTROOT</b></code> is set to the base path for the history
files of this user: <code>$CDEHROOT/history/$CDEHUSER</code>.
<li><code><b>CDEHTMP</b></code> is set to a uniq path in /tmp for temporary
files.
<li><code><b>PROMPT_COMMAND</b></code> is initialized.
<li>A <code>function</code> <code><b>exit</b></code> is defined, overriding
the normal 'exit'. This is done to assure that the history is written
when you exit the shell, and to cleanup temporary files from <code>/tmp</code>.
</ul>
</p>

<h3>do_prompt</h3>

<p>This is the main script, executed from <code>PROMPT_COMMAND</code>.
There is little to edit in this file, although you might need to be
aware of the fact that it starts with setting <code>CDEHTMP</code>
again. This should be the <em>same</em> path as is being used in
<code>env.bashrc</code> of course.</p>

<p>Nevertheless, the following points probably need your attention:
<ul>
<li>In case the directory <code>CDEHHISTROOT</code> doesn't exist,
the script will print (every prompt) a warning. Since cdeh only runs
every prompt and doesn't keep a record of what warnings it sent before,
you might get error or warning messages <em>every</em> prompt. Don't
let that scare you off; just fix the problem.
<li>This script also tries to change the title of the current terminal
window into something that reflects both, the current working directory
as well as the history root path.
It does this by calling <code>xtermset</code>, so you want to have
that installed (it is probably part of the package <em>xtermset</em>.
On debian: <code>apt-get install xtermset</code>).
<li>In order not to be confused by symbolic links, the script uses
the inodes of directories to know if it changed directory or not.
These inodes are retieved by called <code>stat</code> (package: coreuitls)
and <code>awk</code> (package: gawk), both of which need to be in your
<code>PATH</code>.
</ul>
</p>

<a name="env.source">
<h2>Example: A system for environment switching</h2>

<p>Whenever you change directory, <a href="#download">CDEH</a> will
descent the directories of the current working directory looking for
the first <code>env.source</code> file and source it. For example,
if there exists <code>/env.source</code>,
<code>/home/carlo/env.source</code> and
<code>/home/carlo/projects/libecc/env.source</code>, then
changing directory to <code>/home/carlo</code> will source
<code>/home/carlo/env.source</code> while changing directory to
<code>/home/carlo/projects/libecc/libecc/src</code> will
source <code>/home/carlo/projects/libecc/env.source</code>, instead.</p>

<p>Personally, I use the following system for my different C++ projects.
<ul>
<li>In the root (/) I keep <a href="root-env.source">this <code>env.source</code></a>,
needed to <em>undo</em> the effects of any other <code>env.source</code> that
I use. After all, when you leave a directory then you want
specific environment settings for that directory to disappear again!
<b>Don't forget to set <code>DEFAULTPATH</code></b>, see the next item,
or your <code>PATH</code> will become empty and you cannot execute any commands
anymore without giving the full path (hint: /usr/bin/vim ~/.bashrc):</p>
<li>In my <code>.bashrc</code> file I set <code>DEFAULTPATH</code> to whatever
I want to use when I am in an arbitrary directory that doesn't set it's own
<code>PATH</code>:
<pre>
export DEFAULTPATH="$HOME/bin:/usr/local/bin:/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/X11R6/bin:/usr/X11R6/bin:$PROTODIR/scripts:/usr/games"
export PATH="$DEFAULTPATH"
</pre>
I also set <code>DEFAULT_TOPPROJECT</code> to the project directory that I
want to be the default project when I open a new terminal window
(<code>TOPPROJECT</code> is the current project that I am working on and
determines the compiler version to use for library projects),
<pre>
export DEFAULT_TOPPROJECT=/home/carlo/projects/ircproxy
</pre>
<li>In project directories (like <code>/home/carlo/projects/ircproxy</code>)
I then have the project specific <code>env.source</code> file, and a
<code>env.compiler</code> file. The latter determines which compiler to use
when this project is the current/main project. Even library project
directories have their own <code>env.compiler</code> file, because I can
be working on them, without having a relationship with any other particular
project. The <code>env.compiler</code> file defines the environment variables
<code>CC</code>, <code>CXX</code>, <code>CPP</code> and <code>CXXCPP</code>.
For example (to use the default compilers),
<pre>
CC="gcc"
CXX="g++"

export CC CXX
</pre>
while in another project I use a more complex definition that uses two PCs,
doing distributed compilation (which, unfortunately doesn't really speed
up the compilation process with only two PC's):
<pre>
CC="pcc"
CXX="pc++"
CC0="/usr/bin/gcc"
CXX0="/usr/bin/g++"
CC1="/home/carlo/bin/ansset-gcc"
CXX1="/home/carlo/bin/ansset-g++"
CC2="/usr/bin/gcc"
CXX2="/usr/bin/g++"
CC3="/home/carlo/bin/ansset-gcc"
CXX3="/home/carlo/bin/ansset-g++"

export CC CXX CC0 CXX0 CC1 CXX1 CC2 CXX2 CC3 CXX3
</pre>
<p>Note that <code>ansset-gcc</code> and <code>ansset-g++</code> are
scripts that further do work to actually use the compiler on another
machine (but that is not relevant for this document).</p>
<p>I have a lot of different compiler versions installed in
<code>/usr/local</code>.
Some projects use a particular version (for example for testing libraries),
which could need a <code>env.compiler</code> with the following content:</p>
<pre>
CC=gcc-4.0.3
CXX=g++-4.0.3
CPP="/usr/local/$CC/bin/cpp"
CXXCPP="/usr/local/$CC/bin/cpp -x c++"

export CC CXX
export CPP CXXCPP
</pre>
<li>Each project (root) directory gets an <code>env.source</code>
that defines several "standard" environment variables and aliases.
<ul>
<li>TOPPROJECT &mdash; This environment variable is only set
for standalone projects. Library projects usually don't define this.
<li>CFLAGS, CXXFLAGS, CPPFLAGS, LDFLAGS &mdash; Whatever is appropriate
to use for this project. These environment variables are usually used
by <em>configure</em> and/or the Makefile.
<li>CCACHE_DIR &mdash; All my non-standard compilers (installed with
<code>--prefix=/usr/local/gcc-$COMPILER_VERSION</code>) are <em>actually</em>
<a href="gcc_or_g++-version">scripts</a>,
which use ccache when this environment variable is set.
<li>INSTALL_PREFIX &mdash; The install prefix used to configure the project.
This is dependend on the compiler version, so that libraries and applications
compiled with a specific compiler versions will only use eachother (and
whatever is installed as part of the Operating System when the library is
not available in <code>INSTALL_PREFIX</code>).
<li>PKG_CONFIG_PATH &mdash; Used by <code>pkg-config(1)</code>, used in
many <code>./configure</code> scripts.
<li>PATH &mdash; Updated to include the <code>INSTALL_PREFIX</code>.
<li>LD_LIBRARY_PATH &mdash; Updated to include the <code>INSTALL_PREFIX</code>.
<li>CONFIGURE_OPTIONS &mdash; The default configure options to use for
this project.
<li>OUTPUT_DIRECTORY &mdash; Where <code>doxygen</code> has to write the
documentation to.
<li>CTAGS_ROOT_SRCDIRS &mdash; Additions source dirs for ctags that this
project should use. This is being used by some (standarized) entry in my
Makefiles.
</ul>
<p>The following aliases are defined:
<ul>
<li>s &mdash; This should print all source files of the project. It is
mainly used from the command line to <code>grep</code> all sources.
For example, to list all source files that use some class name
<code>ServerSession</code>, I'd type: <code>grep -l ServerSession `s`</code>
without being bothered by where all the source files of this particular
project are.
<li>vi &mdash; This alias is redefined in order to tell vim where the tag
files for this particular project can be found
(as generated with <code>ctags(1)</code>).
<li>configure &mdash; As explained before, I use this alias to configure
a project. It has to be executed from the object directory.
<li>syncwww &mdash; Whenever a project contains documentation, the alias
<code>syncwww</code> is defined to whatever command needs to be executed
to export this documentation, synchronizing the documentation of the
current project with the external (public) web pages. Again,
not bothering me anymore with project specific details.
</ul>
</p>
<p>As an example, the following is my <code>env.source</code> file
as used for my cwchessboard project:</p>
<pre>
export TOPPROJECT=/home/carlo/projects/cwchessboard
source /env.source
source $TOPPROJECT/env.compiler

CPPFLAGS=
LDFLAGS=
CFLAGS=-g3
CXXFLAGS=-g3

export CPPFLAGS LDFLAGS CFLAGS CXXFLAGS

# These two are helper variables.
GCCVER=`$CXX -v 2&gt;&amp;1 | grep '^gcc[ -][Vv]ersion' | sed -e 's/gcc[ -][Vv]ersion //' -e 's/ (.*//' -e 's/ /-/g'`
INSTALL_PREFIX="/usr/local/install/$GCCVER"

PKG_CONFIG_PATH="$INSTALL_PREFIX/lib/pkgconfig"
del_path .
pre_path "$INSTALL_PREFIX/bin"
pre_path .
pre_path "$INSTALL_PREFIX/lib" LD_LIBRARY_PATH

export PKG_CONFIG_PATH PATH LD_LIBRARY_PATH INSTALL_PREFIX

alias s='ls /home/carlo/projects/cwchessboard/cwchessboard/*.cc /home/carlo/projects/cwchessboard/cwchessboard/*.h'
alias vi='vim -c "set tags=/home/carlo/projects/cwchessboard/cwchessboard-objdir/tags"'

export CONFIGURE_OPTIONS="--enable-maintainer-mode --enable-debug --prefix=$INSTALL_PREFIX"
alias configure='../cwchessboard/configure $CONFIGURE_OPTIONS'

export OUTPUT_DIRECTORY=/home/carlo/www

export CTAGS_ROOT_SRCDIRS="/usr/src/gtk/glib-current /usr/src/gtk/gtk+-current"
</pre>
<p>While a C++ <em>library</em> project, like <code>libcwd</code>,
does not set <code>TOPPROJECT</code>, it can
<em>use</em> <code>TOPPROJECT</code> to change, for instance, the
configure options.
This project also defines the alias <code>syncwww</code>:</p>
<pre>
source /env.source
source $TOPPROJECT/env.compiler

# These two are helper variables.
GCCVER=`$CXX -v 2&gt;&amp;1 | grep '^gcc[ -][Vv]ersion' | sed -e 's/gcc[ -][Vv]ersion //' -e 's/ (.*//' -e 's/ /-/g'`
INSTALL_PREFIX="/usr/local/install/$GCCVER"

CPPFLAGS=
LDFLAGS=
CFLAGS=
CXXFLAGS=

export CPPFLAGS LDFLAGS CFLAGS CXXFLAGS

PKG_CONFIG_PATH="$INSTALL_PREFIX/lib/pkgconfig"
pre_path "$INSTALL_PREFIX/bin"
pre_path "$INSTALL_PREFIX/lib" LD_LIBRARY_PATH

export PKG_CONFIG_PATH PATH LD_LIBRARY_PATH 
alias s="ls /home/carlo/projects/libcwd/libcwd/*.cc /home/carlo/projects/libcwd/libcwd/include/*.h /home/carlo/projects/libcwd/libcwd/include/libcwd/*.h /home/carlo/projects/libcwd/libcwd/include/libcwd/*.inl /home/carlo/projects/libcwd/libcwd/utils/*.cc"
alias vi='vim -c "set tags=/home/carlo/projects/libcwd/libcwd-objdir/tags,/home/carlo/projects/libcwd/libcwd-objdir/include/tags,/home/carlo/projects/libcwd/libcwd-objdir/include/libcwd/tags,/home/carlo/projects/libcwd/libcwd-objdir/utils/tags"'
alias syncwww='rsync -rltz -e /usr/bin/ssh --delete --exclude-from=/home/carlo/projects/libcwd/libcwd-objdir/documentation/www/exclude --verbose /home/carlo/projects/libcwd/libcwd-objdir/documentation/ libcwd-shell:"~/libcwd.www/htdocs"'

export CONFIGURE_OPTIONS="--enable-maintainer-mode --prefix=$INSTALL_PREFIX"
alias configure='../libcwd/configure $CONFIGURE_OPTIONS'

BASENAME=`basename "$TOPPROJECT"`
if [ "$BASENAME" == ircproxy -o "$BASENAME" == cppgraph ]; then
  CONFIGURE_OPTIONS="$CONFIGURE_OPTIONS --disable-threading"
fi
</pre>
</ul>

Of course, these are just ideas. Use your creativity and write
env.source files that will make <em>your</em> life easier!
</p>

</div> <!-- content -->

<div id="footer">Copyright &copy; 2007 Carlo Wood</div>

</body>
</html>

