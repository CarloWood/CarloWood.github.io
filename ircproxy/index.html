<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML LANG="en-us">
 
<HEAD>
<META name="Author" content="Carlo Wood">
<META name="description" content="IRC proxy">
<META name="keywords" content="IRC, proxy, bnc, security, protection">
<META http-equiv="content-type" content="text/html; charset=iso-8859-1">
<TITLE>ircproxy documentation</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
<LINK HREF="main.css" REL="stylesheet" TYPE="text/css">
</HEAD>

<BODY>

<TABLE class="header" BORDER=0 CELLSPACING=0 CELLPADDING=0>
<TR>
<TD WIDTH=120><IMG SRC="images/ircproxy.png" BORDER=0></TD>
<TD VALIGN=center ALIGN=center BGCOLOR="#0A0607"><FONT size=+4 color="#ffffff"><B>&nbsp;ircproxy</B>&nbsp;</FONT>
<FONT size=+3 color="#ffffff">The&nbsp;Ultimate&nbsp;Cyborg</FONT></TD>
</TR>
</TABLE>

<DIV class="normal">
<hr>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ircproxy API Documentation</h1>
<p>
<h3 align="center">1.0.0 </h3><h2>The Internal Data Structure of IRCproxy</h2>
<p>
<a class="anchor" name="application"></a> <h3>Application</h3>
<p>
The entry point for accessing data is the singleton <a class="el" href="classApplication.html" title="The application singleton.">Application</a>. <p>
This singleton can be accessed through <code>Application::instance()</code>. If this code can be reached before <code>main()</code> then instead <code>Application::instantiate()</code> should be used, but this is not normally the case. <p>
The <a class="el" href="classApplication.html" title="The application singleton.">Application</a> gives access to two lists of objects through the following methods: <ul>
<li>
<a href="#networks">networks</a> (<a class="el" href="classApplication.html#5b13c426798eaacdde278538117efd32">Application::instance().networks() </a>) </li>
<li>
<a href="#identities">identities</a> (<a class="el" href="classApplication.html#a9b9bf832b35be9e91a6e2ff0a6adc52">Application::instance().identities() </a>) </li>
</ul>
<p>
<a class="anchor" name="networks"></a> <h3>Networks</h3>
<p>
All known IRC networks are stored in <a class="el" href="classApplication.html#e2ae50b1c37da20370bd0dbc9282eb87" title="List with all known networks.">Application::M_networks</a>. This list of <a class="el" href="classNetwork.html" title="An IRC network.">Network</a> objects can be accessed through the member function <code>Application::instance().networks()</code>.<p>
A network is determined upon connection to a server by decoding the 001 numeric reply. FIXME: 005 NETWORKS= should be used if available.<p>
The <a class="el" href="classNetwork.html" title="An IRC network.">Network</a> gives access to two lists of objects through the following methods: <ul>
<li>
<a href="#servers">servers</a> (<a class="el" href="classNetwork.html#f015d8808f7f7330419eb53cb989ee7b" title="A const reference to the list of servers associated with this network.">Network::servers</a>) </li>
<li>
<a href="#targets">targets</a> (<a class="el" href="classNetwork.html#414be7a7a657c8bf9d88aa2ff96a147b" title="A const reference to an STL container with all known targets.">Network::targets</a>) </li>
</ul>
<p>
<a class="anchor" name="identities"></a> <h3>Identities</h3>
<p>
An IRCproxy <a class="el" href="classIdentity.html" title="A Nick/Network identity.">Identity</a> represents a unique virtual identity, a different IRC personality, even though the real person behind it could be the same person of course. Information related to a real person is stored in an <a class="el" href="classAccount.html" title="An account.">Account</a>.<p>
All identies are stored in <a class="el" href="classApplication.html#5c3db3bb4e5e9c6e7e318ffe05e50ced" title="Map with all known identities.">Application::M_identities</a>. This <code>std::map</code> stores all <a class="el" href="classIdentity.html" title="A Nick/Network identity.">Identity</a> objects as function of their name (a <code>std::string</code>). The map can be accessed through the member function <code>Application::instance().identities()</code>.<p>
An identity is determined by the first word in the <code>PASS</code> message as received from the client. This string is also used as login to any service (for example X on Undernet). The full format of the <code>PASS</code> message is: <pre>
PASS &lt;login/identity&gt; &lt;ircproxy authentication password&gt; &lt;service password&gt; &lt;server password&gt;
</pre><p>
FIXME: Knowing the <a class="el" href="classIdentity.html" title="A Nick/Network identity.">Identity</a>, one can get the current <a class="el" href="classServerConnection.html" title="Object representing the server-side connection.">ServerConnection</a> by calling <a class="el" href="classIdentity.html#bf3c39a512dcf261dff344aa87d4cceb" title="Return the primary server connection object.">Identity::server_connection</a>. This object is owned by the <a class="el" href="classIdentity.html" title="A Nick/Network identity.">Identity</a> object (and therefore has the same life time). The actual server connection is a <a class="el" href="classServerSession.html" title="A server session, from connect till disconnect.">ServerSession</a> object that is created and managed by this object. The <a class="el" href="classServerSession.html" title="A server session, from connect till disconnect.">ServerSession</a> can be obtained by a call to <a class="el" href="classServerConnection.html#832a5728134205d1bcd2ef367b136c04" title="Return the ServerSession.">ServerConnection::server_session</a> (or the shortcut <a class="el" href="classIdentity.html#befd26ceb307699d1b4a16082fa51860" title="Return the current ClientSession.">Identity::server_session</a>). Administrative information about the specific server itself (name, network, ports etc) is stored in a <a class="el" href="classServer.html" title="An IRC server.">Server</a> object, which can be obtained by a call to <a class="el" href="classServerConnection.html#c31da41babaae4b0f781f6e6f1e177ad" title="Returns the server that we are connected with or connecting to.">ServerConnection::server</a>.<p>
<a class="anchor" name="messages"></a> <h3>Messages</h3>
<p>
Input messages have the type <a class="el" href="classMessageIn.html" title="An IRC message as received from client or server.">MessageIn</a>, while output messages have the type <a class="el" href="classMessageOut.html" title="An output message.">MessageOut</a>.<p>
A raw message often has a prefix (the source), for example, <code>:nick!user@host JOIN #foo</code> or <code>:server.name.org NOTICE nick :This is a notice</code>, where <code>:nick!user@host</code> and <code>:server.name.org</code> are the prefix of these respective messages. A prefix is represented by the <a class="el" href="classPrefix.html" title="A class representing a message prefix.">Prefix</a> class. Use a <a class="el" href="classPrefix.html" title="A class representing a message prefix.">Prefix</a> object whenever you need to deal with a prefix. The <a class="el" href="classPrefix.html" title="A class representing a message prefix.">Prefix</a> class has the notition of an "empty prefix" (no prefix at all), so that in many cases you don't have to treat that as a special case.<p>
A prefix can be extracted from a <a class="el" href="classMessageIn.html" title="An IRC message as received from client or server.">MessageIn</a> with:<p>
<pre class="code">
<a class="el" href="classPrefix.html" title="A class representing a message prefix.">Prefix</a> prefix(msgin);
</pre><p>
The type of the command (or numeric) is an <code>int</code> and can be extracted from the <a class="el" href="classMessageIn.html" title="An IRC message as received from client or server.">MessageIn</a> by calling <a class="el" href="classMessageIn.html#63147fe442cac6236904e034bebfb4b5" title="Numeric representation of command or numeric.">MessageIn::key</a>. Any subsequent token can be retrieved as string with MessageIn::param(n), <code>n</code> starting at 0 for the first parameter after the command or numeric, or with MessageIn::params(n) to obtain parameter <code>n</code> and higher as a single object (<a class="el" href="classMsgPart.html" title="Like MessageIn::Part but with a copy of msg_block_ct to keep the message block alive...">MsgPart</a>).<p>
<a class="anchor" name="sessions"></a> <h3>Sessions</h3>
<p>
There are two types of sessions: <a class="el" href="classClientSession.html" title="A client session, from connect till disconnect.">ClientSession</a> and <a class="el" href="classServerSession.html" title="A server session, from connect till disconnect.">ServerSession</a>. Each represents a TCP/IP connection (a socket) with an IRC client and server respectively. Although it is possible to write directly to these objects (they inherit from <code>std::ostream</code>) you should never do that: all messages to these sockets should go through their respective queues so that ircproxy is able to keep track of how many messages can be bursted before flood control takes effect, do priority ordering in that regard, and last but not least to make sure you never reveal your hostname-- for example by joining a channel-- before your hostname is hidden.<p>
The correct way to send a message is by constructing a <a class="el" href="classMessageOut.html" title="An output message.">MessageOut</a> object and passing that to the session with <code>session.queue_msg(msgout);</code>.<p>
<a class="anchor" name="servers"></a> <h3>Servers</h3>
<p>
An IRC server is a server that the client succesfully connected with in the past and that belongs to some <a class="el" href="classNetwork.html" title="An IRC network.">Network</a>. <a class="el" href="classServer.html#9d36829098a2ea2a3cf846b7f3f70d95" title="The resolvable name of the server, or IP number if there is no hostname available...">Server::M_hostname</a> (returned by <a class="el" href="classServer.html#7f16e82ee6e62acef38c093963f40c81" title="The resolvable name of the server that one can connect to (as passed to the constructor)...">Server::hostname</a>) is the FQDN that the user passed to ircproxy by answering the "What server should I connect to?" question. <a class="el" href="classServer.html#f96de84fa0e0edffdf9136ccb73faa48" title="The IRC name of the server, as received by the proxy during connect.">Server::M_irc_name</a> (returned by <a class="el" href="classServer.html#af5c0e7d9196b346a147e51655b7bcf9" title="IRC name of the server as set with set_irc_name.">Server::get_irc_name</a>) is the server name as received from the server over IRC after a connect (the prefix of the 001 numeric).<p>
Knowing the server, one can find the <a class="el" href="classNetwork.html" title="An IRC network.">Network</a> through <a class="el" href="classServer.html#a5b46fc63911bc170778cc3615a1cd15" title="Return the corresponding network.">Server::network</a>.<p>
<a class="anchor" name="targets"></a> <h3>Targets</h3>
<p>
A <a class="el" href="classTarget.html" title="An IRC message target (ie, channel or nickname), base class.">Target</a> is a base class for different types of targets, currently <a class="el" href="classNick.html" title="A nick name.">Nick</a> and <a class="el" href="classChannel.html" title="An IRC Channel.">Channel</a>, but also the private targets <a class="el" href="classNoticeTarget.html" title="A fake channel that is used for communication between user and ircproxy.">NoticeTarget</a>, <a class="el" href="classPrivateTarget.html" title="A fake channel that is used for communication between user and ircproxy.">PrivateTarget</a> and <a class="el" href="classQuestionTarget.html" title="A fake channel that is used for communication between user and ircproxy.">QuestionTarget</a>. Targets exist solely as floating objects, pointed to by <code>boost::shared_ptr&lt;<a class="el" href="classTarget.html" title="An IRC message target (ie, channel or nickname), base class.">Target</a>&gt;</code> objects. When all shared pointers to a target are deleted, the target is destroyed.<p>
Non-private Targets can have two ID strings: one for the client side and one for the server side. The distinction between client and server side is mainly because it allows translation of target names. Private targets (all of which are channels at the moment) only live on the client side, and therefore only have one ID string. Moreover, they don't change name.<p>
There are two <code>target_hold_map_type</code> maps that store shared pointers to channels: <code><a class="el" href="classServerSession.html#1cdbba5e545c0759814b92d0c578cc02" title="Return reference to map with joined channels.">ServerSession::joined_channels</a></code> and <code>ClientSesssion::joined_channels</code> that store <code>boost::shared_ptr&lt;<a class="el" href="classTarget.html" title="An IRC message target (ie, channel or nickname), base class.">Target</a>&gt;</code> pointers. The targets on those maps are updated to reflect the notion of server and client respectively about what channels the client has joined; whenever a JOIN/PART/KICK is received from the server or client. They are not updated when such a message is sent to the server or client. These maps match keys IRC-case insensitive.<p>
The server side name of channels never changes and is equal to Target::serverside_name. This name is used as key on the server side map. If the channel is using translation, and thus has a different name as seen by the client, then a different key is used on the client side. This name is equal to Target::clientside_name.<p>
Non-private <a class="el" href="classNetwork.html" title="An IRC network.">Network</a> objects maintain a map with type <code>target_lookup_map_type</code> which store <code>boost::weak_ptr&lt;<a class="el" href="classTarget.html" title="An IRC message target (ie, channel or nickname), base class.">Target</a>&gt;</code> pointers. These pointers are automatically removed when the <a class="el" href="classTarget.html" title="An IRC message target (ie, channel or nickname), base class.">Target</a> is destroyed. The key used for this map is the server side name.<p>
<a class="anchor" name="events"></a> <h3>Events</h3>
<p>
By default, ircproxy supports three types of events:<p>
<ul>
<li>
<a href="#timer_events">Timer events</a> </li>
<li>
<a href="#message_events">Events triggered by IRC messages</a> </li>
<li>
<a href="#watched_expression_event">Events triggered by a change of Watched variables/expressions</a> </li>
</ul>
<p>
Independ on the type of event, the class who's member function is used as call back function must have <code>event_client_ct</code> as virtual base class.<p>
<pre class="code">
class Object: public virtual event_client_ct {
 ...
public:
  Object() : event_client_ct() { }
</pre><p>
The destruction of such an object then automatically cancels the event request.<p>
<a class="anchor" name="timer_events"></a> <h4>Timer events</h4>
<p>
It is possible to have ircproxy call a member function of some object after a given time interval has elapsed.<p>
The time to wait is stored in a <code>timeval</code>. For example, in order to wait 1 second before calling <code>Object::call_back_function</code>, one would write,<p>
<pre class="code">
  timeval delay = { 1, 0 };
  timerRequest(delay, object, &amp;Object::call_back_function);
</pre><p>
The member function <code>Object::call_back_function</code> might start something like:<p>
<pre class="code">
void Object::call_back_function(timer_event_type_ct const&amp; LIBCW_UNUSED_UNLESS_DEBUG(expired_at))
{
  DoutEntering(dc::debug, "Object::call_back_function(" &lt;&lt; expired_at.get_expire_time() &lt;&lt; ")");
</pre><p>
<a class="anchor" name="message_events"></a> <h4>Message events</h4>
<p>
It is possible to have ircproxy call a member function of some object if a certain message is received. Construct a <a class="el" href="classMatchRequest.html" title="A match request.">MatchRequest</a> object and pass it to the correct event server. For example,<p>
<pre class="code">
server_session().message_event_server()(match_request, object, &amp;Object::call_back_function);
</pre><p>
would cause <code>object.call_back_function</code> to be called, passing a <a class="el" href="classMatcherEventType.html" title="The type of the argument that is returned with the callback.">MatcherEventType</a> object as argument, as soon as the <code>match_request</code> is fullfilled. See <a href="#match_request">Match requests</a> for information about how to construct a match request.<p>
The member function <code>Object::call_back_function</code> might start something like:<p>
<pre class="code">
void Object::call_back_function(<a class="el" href="classMatcherEventType.html" title="The type of the argument that is returned with the callback.">MatcherEventType</a> const&amp; event_type)
{
  DoutEntering(dc::debug, "Object::call_back_function(" &lt;&lt; event_type &lt;&lt; ")");
</pre><p>
At this point <code>event_type.message()</code> is a reference to the <a class="el" href="classMessageIn.html" title="An IRC message as received from client or server.">MessageIn</a> that did match the request.<p>
<a class="anchor" name="match_request"></a> <h4>Match requests</h4>
<p>
A <a class="el" href="classMatchRequest.html" title="A match request.">MatchRequest</a> is an object representing a match request for some IRC message. The constructor takes the <a class="el" href="classIdentity.html" title="A Nick/Network identity.">Identity</a> that is issuing the request. Subsequently a series of member function can be called to further restrict what message will match. The first member function always must be <code>operator()(int command)</code>, where <code>command</code> is the key or numeric of the message to be matched. For a complete list see the member functions of <a class="el" href="classMatchRequest.html" title="A match request.">MatchRequest</a>.<p>
For example,<p>
<pre class="code">
<a class="el" href="classMatchRequest.html" title="A match request.">MatchRequest</a> match_request(identity);</pre><p>
<pre class="code">match_request(keys::MODE).mynick(0);               // MODE &lt;my nick&gt;</pre><p>
<pre class="code">match_request(396).localserver(prefix).mynick(0).  // &lt;local server&gt; 396 &lt;my nick&gt; &lt;login/identity&gt;[A-Za-z.]* :is now your hidden host
      regexp(M_identity-&gt;key() + "[A-Za-z.]*", 1).
      exactmatch("is now your hidden host", 2);
</pre><p>
<a class="anchor" name="watched_expression_event"></a> <h4>Watched expression events</h4>
<p>
It is possible to have ircproxy call a member function of some object if some boolean expression becomes true. The boolean expression has to consist of <a class="el" href="classWatched.html" title="A wrapper class for arbitrary objects of type T that need to be watched.">Watched</a> variables: variables of type <code><a class="el" href="classWatched.html" title="A wrapper class for arbitrary objects of type T that need to be watched.">Watched</a>&lt;T&gt;</code>. Constants used in the watched boolean expressions must be wrapped too with <code><a class="el" href="classConstExpression.html" title="An expression consisting of a constant.">ConstExpression</a>&lt;T&gt;(value)</code>. You cannot use <code><a class="el" href="classWatched.html" title="A wrapper class for arbitrary objects of type T that need to be watched.">Watched</a>&lt;bool&gt;</code>, instead use the special class <code><a class="el" href="classBool.html" title="A watchable boolean.">Bool</a></code>. The <a class="el" href="classWatched.html" title="A wrapper class for arbitrary objects of type T that need to be watched.">Watched</a> variables can be used as if they are not wrapped, but when using them in an expression that is passed to <code>ON_TRUE</code> you have to use the dereference operator (<code>operator*</code>). The type of the complete expression reflects the entry expression. It is therefore not feasible to store such an expression in a temporary variable. Best practise is to pass the expression immediately, as-is, to the macro <code>ON_TRUE</code>.<p>
For example, to have ircproxy call the member function <code>call_back_function</code> of an Object object, one could do:<p>
<pre class="code">
<a class="el" href="classBool.html" title="A watchable boolean.">Bool</a> var1
Watched&lt;T1&gt; var2;
Watched&lt;T1&gt; var3;
...
T1 const m = 1;
ConstExpression&lt;T1&gt; mask(m);
ON_TRUE(*var2 &amp; *var3 == mask &amp;&amp; *var1, object, &amp;Object::call_back_function);
</pre><p>
which would (re)evaluate the expression each time <code>var1</code>, <code>var2</code> or <code>var3</code> change value. When the expression changes from false to true, then the member function <code>object.call_back_function</code> is called.<p>
The member function <code>Object::call_back_function</code> might start something like:<p>
<pre class="code">
void Object::call_back_function(<a class="el" href="classExpressionEventType.html" title="The EventType for Expression&#39;s.">ExpressionEventType</a> const&amp; LIBCW_UNUSED_UNLESS_DEBUG(event_type))
{
  DoutEntering(dc::notice, "Object::call_back_function(" &lt;&lt; event_type &lt;&lt; ')');
  <a class="el" href="debug_8h.html#ca68c0d4ac8df0838e209fb5300f7be3" title="Assert if debugging is turned on.">ASSERT(event_type)</a>;   // Should be true, of course.
</pre><p>
where <code>event_type</code> is convertible to a boolean and reflects the changed value of the expression.<p>
<a class="anchor" name="persistent"></a> <h3>Persistent data</h3>
<p>
The application keeps certain data over restarts by storing objects in an XML file and rereading them at start up.<p>
The process of tranforming the value of an object into a character stream that can be written to, and read from, a file, is called "serialization". In principle only a single object is serialized: the <a href="#application">Application</a> singleton. Every other object is subsequently serialized as part of the application object.<p>
In order to add support for serialization of a class, a method <code>serialize</code> has to be added. For example in order to add serialization support to a class Foo, one would write:<p>
<pre class="code">
// The header file:
class <a class="el" href="classPersistXML.html" title="A persistent object archiver.">PersistXML</a>;</pre><p>
<pre class="code">class Foo {
  private:
    some_type M_member1;
    some_type M_member2;
...
  public:
    Foo(void);	// Default constructor must exist.
    void serialize(PersistXML&amp; xml);
};</pre><p>
<pre class="code">// The source file:
#include "PersistXML.h"</pre><p>
<pre class="code">void Foo::serialize(PersistXML&amp; xml)
{
  xml.serialize("M_member1", M_member1);
  xml.serialize("M_member2", M_member2);
  ...
}
</pre><p>
Where <code>some_type</code> can be builtin types, or a custom class that also supports serialization through it's own serialize member function. It is not necessary to serialize every member. When reading an object back from file, the object is first constructed with the default constructor and subsequentially each builtin type is assigned the value as read from the XML file.<p>
<code><a class="el" href="classPersistXML.html#5612c3e53fee8ffb21a228536fea9595" title="Serialize object using the xml tag &lt;label&gt;&lt;/label&gt;.">PersistXML::serialize</a></code> is overloaded for certain special types, providing an immediate support for the otherwise complex way of serialization. The special types currently supported are:<p>
<pre class="code">
  boost::shared_ptr&lt;T&gt;&amp;
  std::vector&lt;T&gt;&amp;
  std::list&lt;T&gt;&amp;
  std::map&lt;KEY, INFO, COMPARE&gt;&amp;
</pre> </div>
<hr>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0>
<TR>
<TH ALIGN=left BGCOLOR="#e8feff"><ADDRESS>Copyright &copy; 2005-2007 Carlo Wood.&nbsp; All rights reserved.</ADDRESS></TH>
</TR>
</TABLE>

</DIV>
</BODY>
</HTML>

