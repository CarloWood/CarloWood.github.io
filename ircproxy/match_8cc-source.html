<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML LANG="en-us">
 
<HEAD>
<META name="Author" content="Carlo Wood">
<META name="description" content="IRC proxy">
<META name="keywords" content="IRC, proxy, bnc, security, protection">
<META http-equiv="content-type" content="text/html; charset=iso-8859-1">
<TITLE>ircproxy documentation</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
<LINK HREF="main.css" REL="stylesheet" TYPE="text/css">
</HEAD>

<BODY>

<TABLE class="header" BORDER=0 CELLSPACING=0 CELLPADDING=0>
<TR>
<TD WIDTH=120><IMG SRC="images/ircproxy.png" BORDER=0></TD>
<TD VALIGN=center ALIGN=center BGCOLOR="#0A0607"><FONT size=+4 color="#ffffff"><B>&nbsp;ircproxy</B>&nbsp;</FONT>
<FONT size=+3 color="#ffffff">The&nbsp;Ultimate&nbsp;Cyborg</FONT></TD>
</TR>
</TABLE>

<DIV class="normal">
<hr>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>match.cc</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef USE_PCH</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#include "sys.h"</span>
<a name="l00003"></a>00003 <span class="preprocessor">#endif</span>
<a name="l00004"></a>00004 <span class="preprocessor"></span>
<a name="l00005"></a>00005 <span class="preprocessor">#include "<a class="code" href="match_8h.html" title="This file contains the declaration of match related functions.">match.h</a>"</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include "ircd_chattr.h"</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="comment">/*</span>
<a name="l00009"></a>00009 <span class="comment"> * mmatch()</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> * Written by Run (run@alinoe.com), 25-10-96</span>
<a name="l00012"></a>00012 <span class="comment"> */</span>
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="comment">/*</span>
<a name="l00015"></a>00015 <span class="comment"> * From: Carlo Wood &lt;carlo@runaway.xs4all.nl&gt;</span>
<a name="l00016"></a>00016 <span class="comment"> * Message-Id: &lt;199609021026.MAA02393@runaway.xs4all.nl&gt;</span>
<a name="l00017"></a>00017 <span class="comment"> * Subject: [C-Com] Analysis for `mmatch' (was: gline4 problem)</span>
<a name="l00018"></a>00018 <span class="comment"> * To: coder-com@mail.undernet.org (coder committee)</span>
<a name="l00019"></a>00019 <span class="comment"> * Date: Mon, 2 Sep 1996 12:26:01 +0200 (MET DST)</span>
<a name="l00020"></a>00020 <span class="comment"> *</span>
<a name="l00021"></a>00021 <span class="comment"> * We need a new function `mmatch(char const* old_mask, char const* new_mask)'</span>
<a name="l00022"></a>00022 <span class="comment"> * which returns `true' likewise the current `match' (start with copying it),</span>
<a name="l00023"></a>00023 <span class="comment"> * but which treats '*' and '?' in `new_mask' differently (not "\*" and "\?" !)</span>
<a name="l00024"></a>00024 <span class="comment"> * as follows:  a '*' in `new_mask' does not match a '?' in `old_mask' and</span>
<a name="l00025"></a>00025 <span class="comment"> * a '?' in `new_mask' does not match a '\?' in `old_mask'.</span>
<a name="l00026"></a>00026 <span class="comment"> * And ofcourse... a '*' in `new_mask' does not match a '\*' in `old_mask'...</span>
<a name="l00027"></a>00027 <span class="comment"> * And last but not least, '\?' and '\*' in `new_mask' now become one character.</span>
<a name="l00028"></a>00028 <span class="comment"> */</span>
<a name="l00029"></a>00029 
<a name="l00030"></a><a class="code" href="match_8h.html#29a4fa9144b27383534f64184a0fe76b">00030</a> <span class="keywordtype">int</span> mmatch(<span class="keywordtype">char</span> <span class="keyword">const</span>* old_mask, <span class="keywordtype">char</span> <span class="keyword">const</span>* new_mask)
<a name="l00031"></a>00031 {
<a name="l00032"></a>00032   <span class="keyword">register</span> <span class="keywordtype">char</span> <span class="keyword">const</span>* m = old_mask;
<a name="l00033"></a>00033   <span class="keyword">register</span> <span class="keywordtype">char</span> <span class="keyword">const</span>* n = new_mask;
<a name="l00034"></a>00034   <span class="keywordtype">char</span> <span class="keyword">const</span>* ma = m;
<a name="l00035"></a>00035   <span class="keywordtype">char</span> <span class="keyword">const</span>* na = n;
<a name="l00036"></a>00036   <span class="keywordtype">int</span> wild = 0;
<a name="l00037"></a>00037   <span class="keywordtype">int</span> mq = 0, nq = 0;
<a name="l00038"></a>00038 
<a name="l00039"></a>00039   <span class="keywordflow">while</span> (1)
<a name="l00040"></a>00040   {
<a name="l00041"></a>00041     <span class="keywordflow">if</span> (*m == <span class="charliteral">'*'</span>)
<a name="l00042"></a>00042     {
<a name="l00043"></a>00043       <span class="keywordflow">while</span> (*m == <span class="charliteral">'*'</span>)
<a name="l00044"></a>00044         m++;
<a name="l00045"></a>00045       wild = 1;
<a name="l00046"></a>00046       ma = m;
<a name="l00047"></a>00047       na = n;
<a name="l00048"></a>00048     }
<a name="l00049"></a>00049 
<a name="l00050"></a>00050     <span class="keywordflow">if</span> (!*m)
<a name="l00051"></a>00051     {
<a name="l00052"></a>00052       <span class="keywordflow">if</span> (!*n)
<a name="l00053"></a>00053         <span class="keywordflow">return</span> 0;
<a name="l00054"></a>00054       <span class="keywordflow">for</span> (m--; (m &gt; old_mask) &amp;&amp; (*m == <span class="charliteral">'?'</span>); m--)
<a name="l00055"></a>00055         ;
<a name="l00056"></a>00056       <span class="keywordflow">if</span> ((*m == <span class="charliteral">'*'</span>) &amp;&amp; (m &gt; old_mask) &amp;&amp; (m[-1] != <span class="charliteral">'\\'</span>))
<a name="l00057"></a>00057         <span class="keywordflow">return</span> 0;
<a name="l00058"></a>00058       <span class="keywordflow">if</span> (!wild)
<a name="l00059"></a>00059         <span class="keywordflow">return</span> 1;
<a name="l00060"></a>00060       m = ma;
<a name="l00061"></a>00061 
<a name="l00062"></a>00062       <span class="comment">/* Added to `mmatch' : Because '\?' and '\*' now is one character: */</span>
<a name="l00063"></a>00063       <span class="keywordflow">if</span> ((*na == <span class="charliteral">'\\'</span>) &amp;&amp; ((na[1] == <span class="charliteral">'*'</span>) || (na[1] == <span class="charliteral">'?'</span>)))
<a name="l00064"></a>00064         ++na;
<a name="l00065"></a>00065 
<a name="l00066"></a>00066       n = ++na;
<a name="l00067"></a>00067     }
<a name="l00068"></a>00068     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!*n)
<a name="l00069"></a>00069     {
<a name="l00070"></a>00070       <span class="keywordflow">while</span> (*m == <span class="charliteral">'*'</span>)
<a name="l00071"></a>00071         m++;
<a name="l00072"></a>00072       <span class="keywordflow">return</span> (*m != 0);
<a name="l00073"></a>00073     }
<a name="l00074"></a>00074     <span class="keywordflow">if</span> ((*m == <span class="charliteral">'\\'</span>) &amp;&amp; ((m[1] == <span class="charliteral">'*'</span>) || (m[1] == <span class="charliteral">'?'</span>)))
<a name="l00075"></a>00075     {
<a name="l00076"></a>00076       m++;
<a name="l00077"></a>00077       mq = 1;
<a name="l00078"></a>00078     }
<a name="l00079"></a>00079     <span class="keywordflow">else</span>
<a name="l00080"></a>00080       mq = 0;
<a name="l00081"></a>00081 
<a name="l00082"></a>00082     <span class="comment">/* Added to `mmatch' : Because '\?' and '\*' now is one character: */</span>
<a name="l00083"></a>00083     <span class="keywordflow">if</span> ((*n == <span class="charliteral">'\\'</span>) &amp;&amp; ((n[1] == <span class="charliteral">'*'</span>) || (n[1] == <span class="charliteral">'?'</span>)))
<a name="l00084"></a>00084     {
<a name="l00085"></a>00085       n++;
<a name="l00086"></a>00086       nq = 1;
<a name="l00087"></a>00087     }
<a name="l00088"></a>00088     <span class="keywordflow">else</span>
<a name="l00089"></a>00089       nq = 0;
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="comment">/*</span>
<a name="l00092"></a>00092 <span class="comment"> * This `if' has been changed compared to match() to do the following:</span>
<a name="l00093"></a>00093 <span class="comment"> * Match when:</span>
<a name="l00094"></a>00094 <span class="comment"> *   old (m)         new (n)         boolean expression</span>
<a name="l00095"></a>00095 <span class="comment"> *    *               any             (*m == '*' &amp;&amp; !mq) ||</span>
<a name="l00096"></a>00096 <span class="comment"> *    ?               any except '*'  (*m == '?' &amp;&amp; !mq &amp;&amp; (*n != '*' || nq)) ||</span>
<a name="l00097"></a>00097 <span class="comment"> * any except * or ?  same as m       (!((*m == '*' || *m == '?') &amp;&amp; !mq) &amp;&amp;</span>
<a name="l00098"></a>00098 <span class="comment"> *                                      ToLower(*m) == ToLower(*n) &amp;&amp;</span>
<a name="l00099"></a>00099 <span class="comment"> *                                        !((mq &amp;&amp; !nq) || (!mq &amp;&amp; nq)))</span>
<a name="l00100"></a>00100 <span class="comment"> *</span>
<a name="l00101"></a>00101 <span class="comment"> * Here `any' also includes \* and \? !</span>
<a name="l00102"></a>00102 <span class="comment"> *</span>
<a name="l00103"></a>00103 <span class="comment"> * After reworking the boolean expressions, we get:</span>
<a name="l00104"></a>00104 <span class="comment"> * (Optimized to use boolean shortcircuits, with most frequently occuring</span>
<a name="l00105"></a>00105 <span class="comment"> *  cases upfront (which took 2 hours!)).</span>
<a name="l00106"></a>00106 <span class="comment"> */</span>
<a name="l00107"></a>00107     <span class="keywordflow">if</span> ((*m == <span class="charliteral">'*'</span> &amp;&amp; !mq) ||
<a name="l00108"></a>00108         ((!mq || nq) &amp;&amp; ToLower(*m) == ToLower(*n)) ||
<a name="l00109"></a>00109         (*m == <span class="charliteral">'?'</span> &amp;&amp; !mq &amp;&amp; (*n != <span class="charliteral">'*'</span> || nq)))
<a name="l00110"></a>00110     {
<a name="l00111"></a>00111       <span class="keywordflow">if</span> (*m)
<a name="l00112"></a>00112         m++;
<a name="l00113"></a>00113       <span class="keywordflow">if</span> (*n)
<a name="l00114"></a>00114         n++;
<a name="l00115"></a>00115     }
<a name="l00116"></a>00116     <span class="keywordflow">else</span>
<a name="l00117"></a>00117     {
<a name="l00118"></a>00118       <span class="keywordflow">if</span> (!wild)
<a name="l00119"></a>00119         <span class="keywordflow">return</span> 1;
<a name="l00120"></a>00120       m = ma;
<a name="l00121"></a>00121 
<a name="l00122"></a>00122       <span class="comment">/* Added to `mmatch' : Because '\?' and '\*' now is one character: */</span>
<a name="l00123"></a>00123       <span class="keywordflow">if</span> ((*na == <span class="charliteral">'\\'</span>) &amp;&amp; ((na[1] == <span class="charliteral">'*'</span>) || (na[1] == <span class="charliteral">'?'</span>)))
<a name="l00124"></a>00124         ++na;
<a name="l00125"></a>00125 
<a name="l00126"></a>00126       n = ++na;
<a name="l00127"></a>00127     }
<a name="l00128"></a>00128   }
<a name="l00129"></a>00129 }
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="comment">/*</span>
<a name="l00132"></a>00132 <span class="comment"> * Compare if a given string (name) matches the given</span>
<a name="l00133"></a>00133 <span class="comment"> * mask (which can contain wild cards: '*' - match any</span>
<a name="l00134"></a>00134 <span class="comment"> * number of chars, '?' - match any single character.</span>
<a name="l00135"></a>00135 <span class="comment"> *</span>
<a name="l00136"></a>00136 <span class="comment"> * return  0, if match</span>
<a name="l00137"></a>00137 <span class="comment"> *         1, if no match</span>
<a name="l00138"></a>00138 <span class="comment"> */</span>
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 <span class="comment">/*</span>
<a name="l00141"></a>00141 <span class="comment"> * match</span>
<a name="l00142"></a>00142 <span class="comment"> *</span>
<a name="l00143"></a>00143 <span class="comment"> * Rewritten by Andrea Cocito (Nemesi), November 1998.</span>
<a name="l00144"></a>00144 <span class="comment"> *</span>
<a name="l00145"></a>00145 <span class="comment"> */</span>
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="comment">/****************** Nemesi's match() ***************/</span>
<a name="l00148"></a>00148 
<a name="l00149"></a><a class="code" href="match_8h.html#9b2f9ceca75ecc6c207422d67a372e6e">00149</a> <span class="keywordtype">int</span> match(<span class="keywordtype">char</span> <span class="keyword">const</span>* mask, <span class="keywordtype">char</span> <span class="keyword">const</span>* <span class="keywordtype">string</span>)
<a name="l00150"></a>00150 {
<a name="l00151"></a>00151   <span class="keyword">register</span> <span class="keywordtype">char</span> <span class="keyword">const</span>* m = mask, *s = string;
<a name="l00152"></a>00152   <span class="keyword">register</span> <span class="keywordtype">char</span> ch;
<a name="l00153"></a>00153   <span class="keywordtype">char</span> <span class="keyword">const</span>* bm, *bs;          <span class="comment">/* Will be reg anyway on a decent CPU/compiler */</span>
<a name="l00154"></a>00154 
<a name="l00155"></a>00155   <span class="comment">/* Process the "head" of the mask, if any */</span>
<a name="l00156"></a>00156   <span class="keywordflow">while</span> ((ch = *m++) &amp;&amp; (ch != <span class="charliteral">'*'</span>))
<a name="l00157"></a>00157     <span class="keywordflow">switch</span> (ch)
<a name="l00158"></a>00158     {
<a name="l00159"></a>00159       <span class="keywordflow">case</span> <span class="charliteral">'\\'</span>:
<a name="l00160"></a>00160         <span class="keywordflow">if</span> (*m == <span class="charliteral">'?'</span> || *m == <span class="charliteral">'*'</span>)
<a name="l00161"></a>00161           ch = *m++;
<a name="l00162"></a>00162       <span class="keywordflow">default</span>:
<a name="l00163"></a>00163         <span class="keywordflow">if</span> (ToLower(*s) != ToLower(ch))
<a name="l00164"></a>00164           <span class="keywordflow">return</span> 1;
<a name="l00165"></a>00165       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
<a name="l00166"></a>00166         <span class="keywordflow">if</span> (!*s++)
<a name="l00167"></a>00167           <span class="keywordflow">return</span> 1;
<a name="l00168"></a>00168     };
<a name="l00169"></a>00169   <span class="keywordflow">if</span> (!ch)
<a name="l00170"></a>00170     <span class="keywordflow">return</span> *s;
<a name="l00171"></a>00171 
<a name="l00172"></a>00172   <span class="comment">/* We got a star: quickly find if/where we match the next char */</span>
<a name="l00173"></a>00173 got_star:
<a name="l00174"></a>00174   bm = m;                       <span class="comment">/* Next try rollback here */</span>
<a name="l00175"></a>00175   <span class="keywordflow">while</span> ((ch = *m++))
<a name="l00176"></a>00176     <span class="keywordflow">switch</span> (ch)
<a name="l00177"></a>00177     {
<a name="l00178"></a>00178       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
<a name="l00179"></a>00179         <span class="keywordflow">if</span> (!*s++)
<a name="l00180"></a>00180           <span class="keywordflow">return</span> 1;
<a name="l00181"></a>00181       <span class="keywordflow">case</span> <span class="charliteral">'*'</span>:
<a name="l00182"></a>00182         bm = m;
<a name="l00183"></a>00183         <span class="keywordflow">continue</span>;               <span class="comment">/* while */</span>
<a name="l00184"></a>00184       <span class="keywordflow">case</span> <span class="charliteral">'\\'</span>:
<a name="l00185"></a>00185         <span class="keywordflow">if</span> (*m == <span class="charliteral">'?'</span> || *m == <span class="charliteral">'*'</span>)
<a name="l00186"></a>00186           ch = *m++;
<a name="l00187"></a>00187       <span class="keywordflow">default</span>:
<a name="l00188"></a>00188         <span class="keywordflow">goto</span> break_while;       <span class="comment">/* C is structured ? */</span>
<a name="l00189"></a>00189     };
<a name="l00190"></a>00190 break_while:
<a name="l00191"></a>00191   <span class="keywordflow">if</span> (!ch)
<a name="l00192"></a>00192     <span class="keywordflow">return</span> 0;                   <span class="comment">/* mask ends with '*', we got it */</span>
<a name="l00193"></a>00193   ch = ToLower(ch);
<a name="l00194"></a>00194   <span class="keywordflow">while</span> (ToLower(*s++) != ch)
<a name="l00195"></a>00195     <span class="keywordflow">if</span> (!*s)
<a name="l00196"></a>00196       <span class="keywordflow">return</span> 1;
<a name="l00197"></a>00197   bs = s;                       <span class="comment">/* Next try start from here */</span>
<a name="l00198"></a>00198 
<a name="l00199"></a>00199   <span class="comment">/* Check the rest of the "chunk" */</span>
<a name="l00200"></a>00200   <span class="keywordflow">while</span> ((ch = *m++))
<a name="l00201"></a>00201   {
<a name="l00202"></a>00202     <span class="keywordflow">switch</span> (ch)
<a name="l00203"></a>00203     {
<a name="l00204"></a>00204       <span class="keywordflow">case</span> <span class="charliteral">'*'</span>:
<a name="l00205"></a>00205         <span class="keywordflow">goto</span> got_star;
<a name="l00206"></a>00206       <span class="keywordflow">case</span> <span class="charliteral">'\\'</span>:
<a name="l00207"></a>00207         <span class="keywordflow">if</span> (*m == <span class="charliteral">'?'</span> || *m == <span class="charliteral">'*'</span>)
<a name="l00208"></a>00208           ch = *m++;
<a name="l00209"></a>00209       <span class="keywordflow">default</span>:
<a name="l00210"></a>00210         <span class="keywordflow">if</span> (ToLower(*s) != ToLower(ch))
<a name="l00211"></a>00211         {
<a name="l00212"></a>00212           m = bm;
<a name="l00213"></a>00213           s = bs;
<a name="l00214"></a>00214           <span class="keywordflow">goto</span> got_star;
<a name="l00215"></a>00215         };
<a name="l00216"></a>00216       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
<a name="l00217"></a>00217         <span class="keywordflow">if</span> (!*s++)
<a name="l00218"></a>00218           <span class="keywordflow">return</span> 1;
<a name="l00219"></a>00219     };
<a name="l00220"></a>00220   };
<a name="l00221"></a>00221   <span class="keywordflow">if</span> (*s)
<a name="l00222"></a>00222   {
<a name="l00223"></a>00223     m = bm;
<a name="l00224"></a>00224     s = bs;
<a name="l00225"></a>00225     <span class="keywordflow">goto</span> got_star;
<a name="l00226"></a>00226   };
<a name="l00227"></a>00227   <span class="keywordflow">return</span> 0;
<a name="l00228"></a>00228 }
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 <span class="comment">/*</span>
<a name="l00231"></a>00231 <span class="comment"> * collapse()</span>
<a name="l00232"></a>00232 <span class="comment"> * Collapse a pattern string into minimal components.</span>
<a name="l00233"></a>00233 <span class="comment"> * This particular version is "in place", so that it changes the pattern</span>
<a name="l00234"></a>00234 <span class="comment"> * which is to be reduced to a "minimal" size.</span>
<a name="l00235"></a>00235 <span class="comment"> *</span>
<a name="l00236"></a>00236 <span class="comment"> * (C) Carlo Wood - 6 Oct 1998</span>
<a name="l00237"></a>00237 <span class="comment"> * Speedup rewrite by Andrea Cocito, December 1998.</span>
<a name="l00238"></a>00238 <span class="comment"> * Note that this new optimized alghoritm can *only* work in place.</span>
<a name="l00239"></a>00239 <span class="comment"> */</span>
<a name="l00240"></a>00240 
<a name="l00241"></a><a class="code" href="match_8h.html#6bb0bbb7685bff72cc49d91316af6610">00241</a> <span class="keywordtype">char</span>* collapse(<span class="keywordtype">char</span>* mask)
<a name="l00242"></a>00242 {
<a name="l00243"></a>00243   <span class="keyword">register</span> <span class="keywordtype">int</span> star = 0;
<a name="l00244"></a>00244   <span class="keyword">register</span> <span class="keywordtype">char</span>* m = mask;
<a name="l00245"></a>00245   <span class="keyword">register</span> <span class="keywordtype">char</span>* b;
<a name="l00246"></a>00246 
<a name="l00247"></a>00247   <span class="keywordflow">if</span> (m)
<a name="l00248"></a>00248   {
<a name="l00249"></a>00249     <span class="keywordflow">do</span>
<a name="l00250"></a>00250     {
<a name="l00251"></a>00251       <span class="keywordflow">if</span> ((*m == <span class="charliteral">'*'</span>) &amp;&amp; ((m[1] == <span class="charliteral">'*'</span>) || (m[1] == <span class="charliteral">'?'</span>)))
<a name="l00252"></a>00252       {
<a name="l00253"></a>00253         b = m;
<a name="l00254"></a>00254         <span class="keywordflow">do</span>
<a name="l00255"></a>00255         {
<a name="l00256"></a>00256           <span class="keywordflow">if</span> (*m == <span class="charliteral">'*'</span>)
<a name="l00257"></a>00257             star = 1;
<a name="l00258"></a>00258           <span class="keywordflow">else</span>
<a name="l00259"></a>00259           {
<a name="l00260"></a>00260             <span class="keywordflow">if</span> (star &amp;&amp; (*m != <span class="charliteral">'?'</span>))
<a name="l00261"></a>00261             {
<a name="l00262"></a>00262               *b++ = <span class="charliteral">'*'</span>;
<a name="l00263"></a>00263               star = 0;
<a name="l00264"></a>00264             };
<a name="l00265"></a>00265             *b++ = *m;
<a name="l00266"></a>00266             <span class="keywordflow">if</span> ((*m == <span class="charliteral">'\\'</span>) &amp;&amp; ((m[1] == <span class="charliteral">'*'</span>) || (m[1] == <span class="charliteral">'?'</span>)))
<a name="l00267"></a>00267               *b++ = *++m;
<a name="l00268"></a>00268           };
<a name="l00269"></a>00269         }
<a name="l00270"></a>00270         <span class="keywordflow">while</span> (*m++);
<a name="l00271"></a>00271         <span class="keywordflow">break</span>;
<a name="l00272"></a>00272       }
<a name="l00273"></a>00273       <span class="keywordflow">else</span>
<a name="l00274"></a>00274       {
<a name="l00275"></a>00275         <span class="keywordflow">if</span> ((*m == <span class="charliteral">'\\'</span>) &amp;&amp; ((m[1] == <span class="charliteral">'*'</span>) || (m[1] == <span class="charliteral">'?'</span>)))
<a name="l00276"></a>00276           m++;
<a name="l00277"></a>00277       };
<a name="l00278"></a>00278     }
<a name="l00279"></a>00279     <span class="keywordflow">while</span> (*m++);
<a name="l00280"></a>00280   };
<a name="l00281"></a>00281   <span class="keywordflow">return</span> mask;
<a name="l00282"></a>00282 }
<a name="l00283"></a>00283 
<a name="l00284"></a>00284 <span class="comment">/*</span>
<a name="l00285"></a>00285 <span class="comment"> ***************** Nemesi's matchcomp() / matchexec() **************</span>
<a name="l00286"></a>00286 <span class="comment"> */</span>
<a name="l00287"></a>00287 
<a name="l00288"></a>00288 <span class="comment">/* These functions allow the use of "compiled" masks, you compile a mask</span>
<a name="l00289"></a>00289 <span class="comment"> * by means of matchcomp() that gets the plain text mask as input and writes</span>
<a name="l00290"></a>00290 <span class="comment"> * its result in the memory locations addressed by the 3 parameters:</span>
<a name="l00291"></a>00291 <span class="comment"> * - *cmask will contain the text of the compiled mask</span>
<a name="l00292"></a>00292 <span class="comment"> * - *minlen will contain the lenght of the shortest string that can match </span>
<a name="l00293"></a>00293 <span class="comment"> *   the mask</span>
<a name="l00294"></a>00294 <span class="comment"> * - *charset will contain the minimal set of chars needed to match the mask</span>
<a name="l00295"></a>00295 <span class="comment"> * You can pass NULL as *charset and it will be simply not returned, but you</span>
<a name="l00296"></a>00296 <span class="comment"> * MUST pass valid pointers for *minlen and *cmask (wich must be big enough </span>
<a name="l00297"></a>00297 <span class="comment"> * to contain the compiled mask text that is in the worst case as long as the </span>
<a name="l00298"></a>00298 <span class="comment"> * text of the mask itself in plaintext format) and the return value of </span>
<a name="l00299"></a>00299 <span class="comment"> * matchcomp() will be the number of chars actually written there (excluded </span>
<a name="l00300"></a>00300 <span class="comment"> * the trailing zero). cmask can be == mask, matchcomp() can work in place.</span>
<a name="l00301"></a>00301 <span class="comment"> * The {cmask, minlen} couple of values make the real compiled mask and</span>
<a name="l00302"></a>00302 <span class="comment"> * need to be passed to the functions that use the compiled mask, if you pass</span>
<a name="l00303"></a>00303 <span class="comment"> * the wrong minlen or something wrong in cmask to one of these expect a</span>
<a name="l00304"></a>00304 <span class="comment"> * coredump. This means that when you record a compiled mask you must store</span>
<a name="l00305"></a>00305 <span class="comment"> * *both* these values.</span>
<a name="l00306"></a>00306 <span class="comment"> * Once compiled the mask can be used to match a string by means of </span>
<a name="l00307"></a>00307 <span class="comment"> * matchexec(), it can be printed back to human-readable format by means</span>
<a name="l00308"></a>00308 <span class="comment"> * of sprintmatch() or it can be compared to another compiled mask by means</span>
<a name="l00309"></a>00309 <span class="comment"> * of mmexec() that will tell if it completely overrides that mask (a lot like</span>
<a name="l00310"></a>00310 <span class="comment"> * what mmatch() does for plain text masks).</span>
<a name="l00311"></a>00311 <span class="comment"> * You can gain a lot of speed in many situations avoiding to matchexec() when:</span>
<a name="l00312"></a>00312 <span class="comment"> * - The maximum lenght of the field you are about to match() the mask to is</span>
<a name="l00313"></a>00313 <span class="comment"> *   shorter than minlen, in example when matching abc*def*ghil with a nick:</span>
<a name="l00314"></a>00314 <span class="comment"> *   It just cannot match since a nick is at most 9 chars long and the mask</span>
<a name="l00315"></a>00315 <span class="comment"> *   needs at least 10 chars (10 will be the value returned in minlen).</span>
<a name="l00316"></a>00316 <span class="comment"> * - The charset allowed for the field you are about to match to doesn't</span>
<a name="l00317"></a>00317 <span class="comment"> *   "contain" the charset returned by matchcomp(), in example when you</span>
<a name="l00318"></a>00318 <span class="comment"> *   have *.* as mask it makes no sense to try to match it against a nick</span>
<a name="l00319"></a>00319 <span class="comment"> *   because, again, a nick can't contain a '.', you can check this with</span>
<a name="l00320"></a>00320 <span class="comment"> *   a simple (charset &amp; NTL_IRCNK) in this case.</span>
<a name="l00321"></a>00321 <span class="comment"> * - As a special case, since compiled masks are forced to lowercase,</span>
<a name="l00322"></a>00322 <span class="comment"> *   it would make no sense to use the NTL_LOWER and NTL_UPPER on a compiled</span>
<a name="l00323"></a>00323 <span class="comment"> *   mask, thus they are reused as follows: if the NTL_LOWER bit of charset</span>
<a name="l00324"></a>00324 <span class="comment"> *   is set it means that the mask contains only non-wilds chars (i.e. you can</span>
<a name="l00325"></a>00325 <span class="comment"> *   use strCasecmp() to match it or a direct hash lookup), if the NTL_UPPER</span>
<a name="l00326"></a>00326 <span class="comment"> *   bit is set it means that it contains only wild chars (and you can</span>
<a name="l00327"></a>00327 <span class="comment"> *   match it with strlen(field)&gt;=minlen).</span>
<a name="l00328"></a>00328 <span class="comment"> * Do these optimizations ONLY when the data you are about to pass to</span>
<a name="l00329"></a>00329 <span class="comment"> * matchexec() are *known* to be invalid in advance, using strChattr() </span>
<a name="l00330"></a>00330 <span class="comment"> * or strlen() on the text would be slower than calling matchexec() directly</span>
<a name="l00331"></a>00331 <span class="comment"> * and let it fail.</span>
<a name="l00332"></a>00332 <span class="comment"> * Internally a compiled mask contain in the *cmask area the text of</span>
<a name="l00333"></a>00333 <span class="comment"> * the plain text form of the mask itself with applied the following hacks:</span>
<a name="l00334"></a>00334 <span class="comment"> * - All characters are forced to lowercase (so that uppercase letters and</span>
<a name="l00335"></a>00335 <span class="comment"> *   specifically the symbols 'A' and 'Z' are reserved for special use)</span>
<a name="l00336"></a>00336 <span class="comment"> * - All non-escaped stars '*' are replaced by the letter 'Z'</span>
<a name="l00337"></a>00337 <span class="comment"> * - All non-escaped question marks '?' are replaced by the letter 'A' </span>
<a name="l00338"></a>00338 <span class="comment"> * - All escape characters are removed, the wilds escaped by them are</span>
<a name="l00339"></a>00339 <span class="comment"> *   then passed by without the escape since they don't collide anymore</span>
<a name="l00340"></a>00340 <span class="comment"> *   with the real wilds (encoded as A/Z) </span>
<a name="l00341"></a>00341 <span class="comment"> * - Finally the part of the mask that follows the last asterisk is</span>
<a name="l00342"></a>00342 <span class="comment"> *   reversed (byte order mirroring) and moved right after the first</span>
<a name="l00343"></a>00343 <span class="comment"> *   asterisk.</span>
<a name="l00344"></a>00344 <span class="comment"> * After all this a mask like:   Head*CHUNK1*chu\*nK2*ch??k3*TaIl </span>
<a name="l00345"></a>00345 <span class="comment"> *               .... becomes:   headZliatZchunk1Zchu*nk2ZchAAk3</span>
<a name="l00346"></a>00346 <span class="comment"> * This can still be printed on a console, more or less understood by an</span>
<a name="l00347"></a>00347 <span class="comment"> * human and handled with the usual str*() library functions.</span>
<a name="l00348"></a>00348 <span class="comment"> * When you store somewhere the compiled mask you can avoid storing the</span>
<a name="l00349"></a>00349 <span class="comment"> * textform of it since it can be "decompiled" by means of sprintmatch(),</span>
<a name="l00350"></a>00350 <span class="comment"> * but at that time the following things are changed in the mask:</span>
<a name="l00351"></a>00351 <span class="comment"> * - All chars have been forced to lowercase.</span>
<a name="l00352"></a>00352 <span class="comment"> * - The mask is collapsed.</span>
<a name="l00353"></a>00353 <span class="comment"> * The balance point of using compiled masks in terms of CPU is when you expect</span>
<a name="l00354"></a>00354 <span class="comment"> * to use matchexec() instead of match() at least 20 times on the same mask</span>
<a name="l00355"></a>00355 <span class="comment"> * or when you expect to use mmexec() instead of mmatch() 3 times.</span>
<a name="l00356"></a>00356 <span class="comment"> */</span>
<a name="l00357"></a>00357 
<a name="l00358"></a>00358  <span class="comment">/* </span>
<a name="l00359"></a>00359 <span class="comment">  * matchcomp()</span>
<a name="l00360"></a>00360 <span class="comment">  *</span>
<a name="l00361"></a>00361 <span class="comment">  * Compiles a mask into a form suitable for using in matchexec().</span>
<a name="l00362"></a>00362 <span class="comment">  */</span>
<a name="l00363"></a>00363 
<a name="l00364"></a><a class="code" href="match_8h.html#580f7f1ae42b34ca456557cb1e76eea5">00364</a> <span class="keywordtype">int</span> matchcomp(<span class="keywordtype">char</span>* cmask, <span class="keywordtype">int</span>* minlen, <span class="keywordtype">int</span>* charset, <span class="keywordtype">char</span> <span class="keyword">const</span>* mask)
<a name="l00365"></a>00365 {
<a name="l00366"></a>00366   <span class="keywordtype">char</span> <span class="keyword">const</span>* m = mask;
<a name="l00367"></a>00367   <span class="keywordtype">char</span>* b = cmask;
<a name="l00368"></a>00368   <span class="keywordtype">char</span>* fs = NULL;
<a name="l00369"></a>00369   <span class="keywordtype">char</span>* ls = NULL;
<a name="l00370"></a>00370   <span class="keywordtype">char</span>* x1, *x2;
<a name="l00371"></a>00371   <span class="keywordtype">int</span> l1, l2, lmin, loop, sign;
<a name="l00372"></a>00372   <span class="keywordtype">int</span> star = 0;
<a name="l00373"></a>00373   <span class="keywordtype">int</span> cnt = 0;
<a name="l00374"></a>00374   <span class="keywordtype">char</span> ch;
<a name="l00375"></a>00375   <span class="keywordtype">int</span> chset = ~0;
<a name="l00376"></a>00376   <span class="keywordtype">int</span> chset2 = (NTL_LOWER | NTL_UPPER);
<a name="l00377"></a>00377 
<a name="l00378"></a>00378   <span class="keywordflow">if</span> (m)
<a name="l00379"></a>00379     <span class="keywordflow">while</span> ((ch = *m++))
<a name="l00380"></a>00380       <span class="keywordflow">switch</span> (ch)
<a name="l00381"></a>00381       {
<a name="l00382"></a>00382         <span class="keywordflow">case</span> <span class="charliteral">'*'</span>:
<a name="l00383"></a>00383           star = 1;
<a name="l00384"></a>00384           <span class="keywordflow">break</span>;
<a name="l00385"></a>00385         <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
<a name="l00386"></a>00386           cnt++;
<a name="l00387"></a>00387           *b++ = <span class="charliteral">'A'</span>;
<a name="l00388"></a>00388           chset2 &amp;= ~NTL_LOWER;
<a name="l00389"></a>00389           <span class="keywordflow">break</span>;
<a name="l00390"></a>00390         <span class="keywordflow">case</span> <span class="charliteral">'\\'</span>:
<a name="l00391"></a>00391           <span class="keywordflow">if</span> ((*m == <span class="charliteral">'?'</span>) || (*m == <span class="charliteral">'*'</span>))
<a name="l00392"></a>00392             ch = *m++;
<a name="l00393"></a>00393         <span class="keywordflow">default</span>:
<a name="l00394"></a>00394           <span class="keywordflow">if</span> (star)
<a name="l00395"></a>00395           {
<a name="l00396"></a>00396             ls = b;
<a name="l00397"></a>00397             fs = fs ? fs : b;
<a name="l00398"></a>00398             *b++ = <span class="charliteral">'Z'</span>;
<a name="l00399"></a>00399             chset2 &amp;= ~NTL_LOWER;
<a name="l00400"></a>00400             star = 0;
<a name="l00401"></a>00401           };
<a name="l00402"></a>00402           cnt++;
<a name="l00403"></a>00403           chset &amp;= IRCD_CharAttrTab[((*b++ = ToLower(ch))) - std::numeric_limits&lt;char&gt;::min()];
<a name="l00404"></a>00404           chset2 &amp;= ~NTL_UPPER;
<a name="l00405"></a>00405       };
<a name="l00406"></a>00406 
<a name="l00407"></a>00407   <span class="keywordflow">if</span> (charset)
<a name="l00408"></a>00408     *charset = (chset | chset2);
<a name="l00409"></a>00409 
<a name="l00410"></a>00410   <span class="keywordflow">if</span> (star)
<a name="l00411"></a>00411   {
<a name="l00412"></a>00412     ls = b;
<a name="l00413"></a>00413     fs = (fs ? fs : b);
<a name="l00414"></a>00414     *b++ = <span class="charliteral">'Z'</span>;
<a name="l00415"></a>00415   };
<a name="l00416"></a>00416 
<a name="l00417"></a>00417   <span class="keywordflow">if</span> (ls)
<a name="l00418"></a>00418   {
<a name="l00419"></a>00419     <span class="keywordflow">for</span> (x1 = ls + 1, x2 = (b - 1); x1 &lt; x2; x1++, x2--)
<a name="l00420"></a>00420     {
<a name="l00421"></a>00421       ch = *x1;
<a name="l00422"></a>00422       *x1 = *x2;
<a name="l00423"></a>00423       *x2 = ch;
<a name="l00424"></a>00424     };
<a name="l00425"></a>00425     l1 = (ls - fs);
<a name="l00426"></a>00426     l2 = (b - ls);
<a name="l00427"></a>00427     x1 = fs;
<a name="l00428"></a>00428     <span class="keywordflow">while</span> ((lmin = (l1 &lt; l2) ? l1 : l2))
<a name="l00429"></a>00429     {
<a name="l00430"></a>00430       x2 = x1 + l1;
<a name="l00431"></a>00431       <span class="keywordflow">for</span> (loop = 0; loop &lt; lmin; loop++)
<a name="l00432"></a>00432       {
<a name="l00433"></a>00433         ch = x1[loop];
<a name="l00434"></a>00434         x1[loop] = x2[loop];
<a name="l00435"></a>00435         x2[loop] = ch;
<a name="l00436"></a>00436       };
<a name="l00437"></a>00437       x1 += lmin;
<a name="l00438"></a>00438       sign = l1 - l2;
<a name="l00439"></a>00439       l1 -= (sign &lt; 0) ? 0 : lmin;
<a name="l00440"></a>00440       l2 -= (sign &gt; 0) ? 0 : lmin;
<a name="l00441"></a>00441     };
<a name="l00442"></a>00442   };
<a name="l00443"></a>00443 
<a name="l00444"></a>00444   *b = <span class="charliteral">'\000'</span>;
<a name="l00445"></a>00445   *minlen = cnt;
<a name="l00446"></a>00446   <span class="keywordflow">return</span> (b - cmask);
<a name="l00447"></a>00447 }
<a name="l00448"></a>00448 
<a name="l00449"></a>00449 <span class="comment">/*</span>
<a name="l00450"></a>00450 <span class="comment"> * matchexec()</span>
<a name="l00451"></a>00451 <span class="comment"> *</span>
<a name="l00452"></a>00452 <span class="comment"> * Executes a match with a mask previosuly compiled with matchcomp()</span>
<a name="l00453"></a>00453 <span class="comment"> * Note 1: If the mask isn't correctly produced by matchcomp() I will core</span>
<a name="l00454"></a>00454 <span class="comment"> * Note 2: 'min' MUST be the value returned by matchcomp on that mask,</span>
<a name="l00455"></a>00455 <span class="comment"> *         or.... I will core even faster :-)</span>
<a name="l00456"></a>00456 <span class="comment"> * Note 3: This piece of code is not intended to be nice but efficient.</span>
<a name="l00457"></a>00457 <span class="comment"> *</span>
<a name="l00458"></a>00458 <span class="comment"> * 25 May 2006:</span>
<a name="l00459"></a>00459 <span class="comment"> *</span>
<a name="l00460"></a>00460 <span class="comment"> * Adapted by Carlo Wood for a non- zero-terminated string.</span>
<a name="l00461"></a>00461 <span class="comment"> * Instead, the a parameter 'len' is passed, being the number of valid characters in 'string'.</span>
<a name="l00462"></a>00462 <span class="comment"> */</span>
<a name="l00463"></a>00463 
<a name="l00464"></a><a class="code" href="match_8h.html#a3b1e1d6215f889b8307f22e038d7683">00464</a> <span class="keywordtype">int</span> matchexec(<span class="keywordtype">char</span> <span class="keyword">const</span>* <span class="keywordtype">string</span>, <span class="keywordtype">size_t</span> len, <span class="keywordtype">char</span> <span class="keyword">const</span>* cmask, <span class="keywordtype">int</span> minlen)
<a name="l00465"></a>00465 {
<a name="l00466"></a>00466   <span class="keywordtype">char</span> <span class="keyword">const</span>* bs = <span class="keywordtype">string</span> - 1;
<a name="l00467"></a>00467   <span class="keywordtype">char</span> <span class="keyword">const</span>* s = <span class="keywordtype">string</span> + len;
<a name="l00468"></a>00468   <span class="keywordtype">char</span> <span class="keyword">const</span>* b = cmask - 1;
<a name="l00469"></a>00469   <span class="keywordtype">int</span> trash;
<a name="l00470"></a>00470   <span class="keywordtype">char</span> <span class="keyword">const</span>* bb;
<a name="l00471"></a>00471   <span class="keywordtype">char</span> ch;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473 tryhead:
<a name="l00474"></a>00474   <span class="keywordflow">while</span> ((ToLower(*++bs) == *++b) &amp;&amp; bs != s);
<a name="l00475"></a>00475   <span class="keywordflow">if</span> (bs == s)
<a name="l00476"></a>00476     <span class="keywordflow">return</span> ((*b != <span class="charliteral">'\000'</span>) &amp;&amp; ((*b++ != <span class="charliteral">'Z'</span>) || (*b != <span class="charliteral">'\000'</span>)));
<a name="l00477"></a>00477   <span class="keywordflow">if</span> (*b != <span class="charliteral">'Z'</span>)
<a name="l00478"></a>00478   {
<a name="l00479"></a>00479     <span class="keywordflow">if</span> (*b == <span class="charliteral">'A'</span>)
<a name="l00480"></a>00480       <span class="keywordflow">goto</span> tryhead;
<a name="l00481"></a>00481     <span class="keywordflow">return</span> 1;
<a name="l00482"></a>00482   };
<a name="l00483"></a>00483 
<a name="l00484"></a>00484   <span class="keywordflow">if</span> ((trash = (len - minlen)) &lt; 0)
<a name="l00485"></a>00485     <span class="keywordflow">return</span> 2;
<a name="l00486"></a>00486 
<a name="l00487"></a>00487 trytail:
<a name="l00488"></a>00488   <span class="keywordflow">while</span> ((ToLower(*--s) == *++b) &amp;&amp; *b &amp;&amp; (ToLower(*--s) == *++b) &amp;&amp; *b
<a name="l00489"></a>00489       &amp;&amp; (ToLower(*--s) == *++b) &amp;&amp; *b &amp;&amp; (ToLower(*--s) == *++b) &amp;&amp; *b);
<a name="l00490"></a>00490   <span class="keywordflow">if</span> (*b != <span class="charliteral">'Z'</span>)
<a name="l00491"></a>00491   {
<a name="l00492"></a>00492     <span class="keywordflow">if</span> (*b == <span class="charliteral">'A'</span>)
<a name="l00493"></a>00493       <span class="keywordflow">goto</span> trytail;
<a name="l00494"></a>00494     <span class="keywordflow">return</span> (*b != <span class="charliteral">'\000'</span>);
<a name="l00495"></a>00495   };
<a name="l00496"></a>00496 
<a name="l00497"></a>00497   s = --bs;
<a name="l00498"></a>00498   bb = b;
<a name="l00499"></a>00499 
<a name="l00500"></a>00500   <span class="keywordflow">while</span> ((ch = *++b))
<a name="l00501"></a>00501   {
<a name="l00502"></a>00502     <span class="keywordflow">while</span> ((ToLower(*++s) != ch))
<a name="l00503"></a>00503       <span class="keywordflow">if</span> (--trash &lt; 0)
<a name="l00504"></a>00504         <span class="keywordflow">return</span> 4;
<a name="l00505"></a>00505     bs = s;
<a name="l00506"></a>00506 
<a name="l00507"></a>00507   trychunk:
<a name="l00508"></a>00508     <span class="keywordflow">while</span> ((ToLower(*++s) == *++b) &amp;&amp; *b);
<a name="l00509"></a>00509     <span class="keywordflow">if</span> (!*b)
<a name="l00510"></a>00510       <span class="keywordflow">return</span> 0;
<a name="l00511"></a>00511     <span class="keywordflow">if</span> (*b == <span class="charliteral">'Z'</span>)
<a name="l00512"></a>00512     {
<a name="l00513"></a>00513       bs = --s;
<a name="l00514"></a>00514       bb = b;
<a name="l00515"></a>00515       <span class="keywordflow">continue</span>;
<a name="l00516"></a>00516     };
<a name="l00517"></a>00517     <span class="keywordflow">if</span> (*b == <span class="charliteral">'A'</span>)
<a name="l00518"></a>00518       <span class="keywordflow">goto</span> trychunk;
<a name="l00519"></a>00519 
<a name="l00520"></a>00520     b = bb;
<a name="l00521"></a>00521     s = bs;
<a name="l00522"></a>00522     <span class="keywordflow">if</span> (--trash &lt; 0)
<a name="l00523"></a>00523       <span class="keywordflow">return</span> 5;
<a name="l00524"></a>00524   };
<a name="l00525"></a>00525 
<a name="l00526"></a>00526   <span class="keywordflow">return</span> 0;
<a name="l00527"></a>00527 }
<a name="l00528"></a>00528 
<a name="l00529"></a>00529 <span class="comment">/*</span>
<a name="l00530"></a>00530 <span class="comment"> * matchdecomp()</span>
<a name="l00531"></a>00531 <span class="comment"> * Prints the human readable version of *cmask into *mask, (decompiles</span>
<a name="l00532"></a>00532 <span class="comment"> * cmask).</span>
<a name="l00533"></a>00533 <span class="comment"> * The area pointed by *mask MUST be big enough (the mask might be up to</span>
<a name="l00534"></a>00534 <span class="comment"> * twice the size of its compiled form if it's made all of \? or \*, and</span>
<a name="l00535"></a>00535 <span class="comment"> * this function can NOT work in place since it might enflate the mask)</span>
<a name="l00536"></a>00536 <span class="comment"> * The printed mask is not identical to the one that was compiled to cmask,</span>
<a name="l00537"></a>00537 <span class="comment"> * infact it is 1) forced to all lowercase, 2) collapsed, both things</span>
<a name="l00538"></a>00538 <span class="comment"> * are supposed to NOT change it's meaning.</span>
<a name="l00539"></a>00539 <span class="comment"> * It returns the number of chars actually written to *mask;</span>
<a name="l00540"></a>00540 <span class="comment"> */</span>
<a name="l00541"></a>00541 
<a name="l00542"></a><a class="code" href="match_8h.html#72477f81c432270fee1a94e10c28ca5b">00542</a> <span class="keywordtype">int</span> matchdecomp(<span class="keywordtype">char</span>* mask, <span class="keywordtype">char</span> <span class="keyword">const</span>* cmask)
<a name="l00543"></a>00543 {
<a name="l00544"></a>00544   <span class="keyword">register</span> <span class="keywordtype">char</span>* rtb = mask;
<a name="l00545"></a>00545   <span class="keyword">register</span> <span class="keywordtype">char</span> <span class="keyword">const</span>* rcm = cmask;
<a name="l00546"></a>00546   <span class="keyword">register</span> <span class="keywordtype">char</span> <span class="keyword">const</span>* begtail, *endtail;
<a name="l00547"></a>00547 
<a name="l00548"></a>00548   <span class="keywordflow">if</span> (rtb == NULL)
<a name="l00549"></a>00549     <span class="keywordflow">return</span> (-1);
<a name="l00550"></a>00550 
<a name="l00551"></a>00551   <span class="keywordflow">if</span> (rcm == NULL)
<a name="l00552"></a>00552     <span class="keywordflow">return</span> (-2);
<a name="l00553"></a>00553 
<a name="l00554"></a>00554   <span class="keywordflow">for</span> (; (*rcm != <span class="charliteral">'Z'</span>); rcm++, rtb++)
<a name="l00555"></a>00555   {
<a name="l00556"></a>00556     <span class="keywordflow">if</span> ((*rcm == <span class="charliteral">'?'</span>) || (*rcm == <span class="charliteral">'*'</span>))
<a name="l00557"></a>00557       *rtb++ = <span class="charliteral">'\\'</span>;
<a name="l00558"></a>00558     <span class="keywordflow">if</span> (!((*rtb = ((*rcm == <span class="charliteral">'A'</span>) ? <span class="charliteral">'?'</span> : *rcm))))
<a name="l00559"></a>00559       <span class="keywordflow">return</span> (rtb - mask);
<a name="l00560"></a>00560   };
<a name="l00561"></a>00561 
<a name="l00562"></a>00562   begtail = rcm++;
<a name="l00563"></a>00563   *rtb++ = <span class="charliteral">'*'</span>;
<a name="l00564"></a>00564 
<a name="l00565"></a>00565   <span class="keywordflow">while</span> (*rcm &amp;&amp; (*rcm != <span class="charliteral">'Z'</span>))
<a name="l00566"></a>00566     rcm++;
<a name="l00567"></a>00567 
<a name="l00568"></a>00568   endtail = rcm;
<a name="l00569"></a>00569 
<a name="l00570"></a>00570   <span class="keywordflow">if</span> (*rcm)
<a name="l00571"></a>00571   {
<a name="l00572"></a>00572     <span class="keywordflow">while</span> (*++rcm)
<a name="l00573"></a>00573       <span class="keywordflow">switch</span> (*rcm)
<a name="l00574"></a>00574       {
<a name="l00575"></a>00575         <span class="keywordflow">case</span> <span class="charliteral">'A'</span>:
<a name="l00576"></a>00576           *rtb++ = <span class="charliteral">'?'</span>;
<a name="l00577"></a>00577           <span class="keywordflow">break</span>;
<a name="l00578"></a>00578         <span class="keywordflow">case</span> <span class="charliteral">'Z'</span>:
<a name="l00579"></a>00579           *rtb++ = <span class="charliteral">'*'</span>;
<a name="l00580"></a>00580           <span class="keywordflow">break</span>;
<a name="l00581"></a>00581         <span class="keywordflow">case</span> <span class="charliteral">'*'</span>:
<a name="l00582"></a>00582         <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
<a name="l00583"></a>00583           *rtb++ = <span class="charliteral">'\\'</span>;
<a name="l00584"></a>00584         <span class="keywordflow">default</span>:
<a name="l00585"></a>00585           *rtb++ = *rcm;
<a name="l00586"></a>00586       };
<a name="l00587"></a>00587     *rtb++ = <span class="charliteral">'*'</span>;
<a name="l00588"></a>00588   };
<a name="l00589"></a>00589 
<a name="l00590"></a>00590   <span class="keywordflow">for</span> (rcm = endtail; (--rcm) &gt; begtail; *rtb++ = ((*rcm == <span class="charliteral">'A'</span>) ? <span class="charliteral">'?'</span> : *rcm))
<a name="l00591"></a>00591     <span class="keywordflow">if</span> ((*rcm == <span class="charliteral">'?'</span>) || (*rcm == <span class="charliteral">'*'</span>))
<a name="l00592"></a>00592       *rtb++ = <span class="charliteral">'\\'</span>;
<a name="l00593"></a>00593 
<a name="l00594"></a>00594   *rtb = <span class="charliteral">'\000'</span>;
<a name="l00595"></a>00595   <span class="keywordflow">return</span> (rtb - mask);
<a name="l00596"></a>00596 }
<a name="l00597"></a>00597 
<a name="l00598"></a>00598 <span class="comment">/*</span>
<a name="l00599"></a>00599 <span class="comment"> * mmexec()</span>
<a name="l00600"></a>00600 <span class="comment"> * Checks if a wider compiled mask (wcm/wminlen) completely overrides</span>
<a name="l00601"></a>00601 <span class="comment"> * a more restrict one (rcm/rminlen), basically what mmatch() does for</span>
<a name="l00602"></a>00602 <span class="comment"> * non-compiled masks, returns 0 if the override is true (like mmatch()).</span>
<a name="l00603"></a>00603 <span class="comment"> * "the wider overrides the restrict" means that any string that matches</span>
<a name="l00604"></a>00604 <span class="comment"> * the restrict one _will_ also match the wider one, always. </span>
<a name="l00605"></a>00605 <span class="comment"> * In this we behave differently from mmatch() because in example we return </span>
<a name="l00606"></a>00606 <span class="comment"> * true for " a?*cd overrides a*bcd " for wich the override happens for how </span>
<a name="l00607"></a>00607 <span class="comment"> * we literally defined it, here mmatch() would have returned false.</span>
<a name="l00608"></a>00608 <span class="comment"> * The original concepts and the base alghoritm are copied from mmatch() </span>
<a name="l00609"></a>00609 <span class="comment"> * written by Run (Carlo Wood), this function is written by</span>
<a name="l00610"></a>00610 <span class="comment"> * Nemesi (Andrea Cocito)</span>
<a name="l00611"></a>00611 <span class="comment"> */</span>
<a name="l00612"></a>00612 
<a name="l00613"></a><a class="code" href="match_8h.html#f80255405d6c7e13d5fb109f5b7b7629">00613</a> <span class="keywordtype">int</span> mmexec(<span class="keywordtype">char</span> <span class="keyword">const</span>* wcm, <span class="keywordtype">int</span> wminlen, <span class="keywordtype">char</span> <span class="keyword">const</span>* rcm, <span class="keywordtype">int</span> rminlen)
<a name="l00614"></a>00614 {
<a name="l00615"></a>00615   <span class="keyword">register</span> <span class="keywordtype">char</span> <span class="keyword">const</span>* w, *r, *br, *bw, *rx, *rz;
<a name="l00616"></a>00616   <span class="keyword">register</span> <span class="keywordtype">int</span> eat, trash;
<a name="l00617"></a>00617 
<a name="l00618"></a>00618   <span class="comment">/* First of all rm must have enough non-stars to 'contain' wm */</span>
<a name="l00619"></a>00619   <span class="keywordflow">if</span> ((trash = rminlen - wminlen) &lt; 0)
<a name="l00620"></a>00620     <span class="keywordflow">return</span> 1;
<a name="l00621"></a>00621   w = wcm;
<a name="l00622"></a>00622   r = rcm;
<a name="l00623"></a>00623   eat = 0;
<a name="l00624"></a>00624 
<a name="l00625"></a>00625   <span class="comment">/* Let's start the game, remember that '*' is mapped to 'Z', '?'</span>
<a name="l00626"></a>00626 <span class="comment">     is mapped to 'A' and that head?*??*?chunk*???*tail becomes</span>
<a name="l00627"></a>00627 <span class="comment">     headAAAAZliatAAAZchunk for compiled masks */</span>
<a name="l00628"></a>00628 
<a name="l00629"></a>00629   <span class="comment">/* Match the head of wm with the head of rm */</span>
<a name="l00630"></a>00630   <span class="keywordflow">for</span> (; (*r) &amp;&amp; (*r != <span class="charliteral">'Z'</span>) &amp;&amp; ((*w == *r) || (*w == <span class="charliteral">'A'</span>)); r++, w++);
<a name="l00631"></a>00631   <span class="keywordflow">if</span> (*r == <span class="charliteral">'Z'</span>)
<a name="l00632"></a>00632     <span class="keywordflow">while</span> (*w == <span class="charliteral">'A'</span>)           <span class="comment">/* Eat extra '?' before '*' in wm if got '*' in rm */</span>
<a name="l00633"></a>00633       w++, eat++;
<a name="l00634"></a>00634   <span class="keywordflow">if</span> (*w != <span class="charliteral">'Z'</span>)                <span class="comment">/* head1&lt;any&gt;.. can't match head2&lt;any&gt;.. */</span>
<a name="l00635"></a>00635     <span class="keywordflow">return</span> ((*w) || (*r)) ? 1 : 0;      <span class="comment">/* and head&lt;nul&gt; matches only head&lt;nul&gt; */</span>
<a name="l00636"></a>00636   <span class="keywordflow">if</span> (!*++w)
<a name="l00637"></a>00637     <span class="keywordflow">return</span> 0;                   <span class="comment">/* headZ&lt;nul&gt; matches head&lt;anything&gt;    */</span>
<a name="l00638"></a>00638 
<a name="l00639"></a>00639   <span class="comment">/* Does rm have any stars in it ? let's check */</span>
<a name="l00640"></a>00640   <span class="keywordflow">for</span> (rx = r; *r &amp;&amp; (*r != <span class="charliteral">'Z'</span>); r++);
<a name="l00641"></a>00641   <span class="keywordflow">if</span> (!*r)
<a name="l00642"></a>00642   {
<a name="l00643"></a>00643     <span class="comment">/* rm has no stars and thus isn't a mask but it's just a flat</span>
<a name="l00644"></a>00644 <span class="comment">       string: special handling occurs here, note that eat must be 0 here */</span>
<a name="l00645"></a>00645 
<a name="l00646"></a>00646     <span class="comment">/* match the tail */</span>
<a name="l00647"></a>00647     <span class="keywordflow">if</span> (*w != <span class="charliteral">'Z'</span>)
<a name="l00648"></a>00648     {
<a name="l00649"></a>00649       <span class="keywordflow">for</span> (; r--, (*w) &amp;&amp; ((*w == *r) || (*w == <span class="charliteral">'A'</span>)); w++);
<a name="l00650"></a>00650       <span class="keywordflow">if</span> (*w != <span class="charliteral">'Z'</span>)            <span class="comment">/* headZliat1&lt;any&gt; fails on head&lt;any&gt;2tail  */</span>
<a name="l00651"></a>00651         <span class="keywordflow">return</span> (*w) ? 1 : 0;    <span class="comment">/* but headZliat&lt;nul&gt; matches head&lt;any&gt;tail */</span>
<a name="l00652"></a>00652     };
<a name="l00653"></a>00653 
<a name="l00654"></a>00654     <span class="comment">/* match the chunks */</span>
<a name="l00655"></a>00655     <span class="keywordflow">while</span> (1)
<a name="l00656"></a>00656     {                           <span class="comment">/* This loop can't break but only return   */</span>
<a name="l00657"></a>00657 
<a name="l00658"></a>00658       <span class="keywordflow">for</span> (bw = w++; (*w != *rx); rx++) <span class="comment">/* Seek the 1st char of the chunk */</span>
<a name="l00659"></a>00659         <span class="keywordflow">if</span> (--trash &lt; 0)        <span class="comment">/* See if we can trash one more char of rm */</span>
<a name="l00660"></a>00660           <span class="keywordflow">return</span> 1;             <span class="comment">/* If not we can only fail of course       */</span>
<a name="l00661"></a>00661       <span class="keywordflow">for</span> (r = ++rx, w++; (*w) &amp;&amp; ((*w == *r) || (*w == <span class="charliteral">'A'</span>)); r++, w++);
<a name="l00662"></a>00662       <span class="keywordflow">if</span> (!*w)                  <span class="comment">/* Did last loop match the rest of chunk ? */</span>
<a name="l00663"></a>00663         <span class="keywordflow">return</span> 0;               <span class="comment">/* ... Yes, end of wm, matched !           */</span>
<a name="l00664"></a>00664       <span class="keywordflow">if</span> (*w != <span class="charliteral">'Z'</span>)
<a name="l00665"></a>00665       {                         <span class="comment">/* ... No, hitted non-star                 */</span>
<a name="l00666"></a>00666         w = bw;                 <span class="comment">/* Rollback at beginning of chunk          */</span>
<a name="l00667"></a>00667         <span class="keywordflow">if</span> (--trash &lt; 0)        <span class="comment">/* Trashed the char where this try started */</span>
<a name="l00668"></a>00668           <span class="keywordflow">return</span> 1;             <span class="comment">/* if we can't trash more chars fail       */</span>
<a name="l00669"></a>00669       }
<a name="l00670"></a>00670       <span class="keywordflow">else</span>
<a name="l00671"></a>00671       {
<a name="l00672"></a>00672         rx = r;                 <span class="comment">/* Successfully matched a chunk, move rx   */</span>
<a name="l00673"></a>00673       };                        <span class="comment">/* and go on with the next one             */</span>
<a name="l00674"></a>00674     };
<a name="l00675"></a>00675   };
<a name="l00676"></a>00676 
<a name="l00677"></a>00677   <span class="comment">/* rm has at least one '*' and thus is a 'real' mask */</span>
<a name="l00678"></a>00678   rz = r++;                     <span class="comment">/* rx = unused of head, rz = beg-tail */</span>
<a name="l00679"></a>00679 
<a name="l00680"></a>00680   <span class="comment">/* Match the tail of wm (if any) against the tail of rm */</span>
<a name="l00681"></a>00681   <span class="keywordflow">if</span> (*w != <span class="charliteral">'Z'</span>)
<a name="l00682"></a>00682   {
<a name="l00683"></a>00683     <span class="keywordflow">for</span> (; (*w) &amp;&amp; (*r != <span class="charliteral">'Z'</span>) &amp;&amp; ((*w == *r) || (*w == <span class="charliteral">'A'</span>)); w++, r++);
<a name="l00684"></a>00684     <span class="keywordflow">if</span> (*r == <span class="charliteral">'Z'</span>)              <span class="comment">/* extra '?' before tail are fluff, just flush 'em */</span>
<a name="l00685"></a>00685       <span class="keywordflow">while</span> (*w == <span class="charliteral">'A'</span>)
<a name="l00686"></a>00686         w++;
<a name="l00687"></a>00687     <span class="keywordflow">if</span> (*w != <span class="charliteral">'Z'</span>)              <span class="comment">/* We aren't matching a chunk, can't rollback      */</span>
<a name="l00688"></a>00688       <span class="keywordflow">return</span> (*w) ? 1 : 0;
<a name="l00689"></a>00689   };
<a name="l00690"></a>00690 
<a name="l00691"></a>00691   <span class="comment">/* Match the chunks of wm against what remains of the head of rm */</span>
<a name="l00692"></a>00692   <span class="keywordflow">while</span> (1)
<a name="l00693"></a>00693   {
<a name="l00694"></a>00694     bw = w;
<a name="l00695"></a>00695     <span class="keywordflow">for</span> (bw++; (rx &lt; rz) &amp;&amp; (*bw != *rx); rx++) <span class="comment">/* Seek the first           */</span>
<a name="l00696"></a>00696       <span class="keywordflow">if</span> (--trash &lt; 0)          <span class="comment">/* waste some trash reserve */</span>
<a name="l00697"></a>00697         <span class="keywordflow">return</span> 1;
<a name="l00698"></a>00698     <span class="keywordflow">if</span> (!(rx &lt; rz))             <span class="comment">/* head finished            */</span>
<a name="l00699"></a>00699       <span class="keywordflow">break</span>;
<a name="l00700"></a>00700     <span class="keywordflow">for</span> (bw++, (br = ++rx);
<a name="l00701"></a>00701         (br &lt; rz) &amp;&amp; (*bw) &amp;&amp; ((*bw == *br) || (*bw == <span class="charliteral">'A'</span>)); br++, bw++);
<a name="l00702"></a>00702     <span class="keywordflow">if</span> (!(br &lt; rz))             <span class="comment">/* Note that we didn't use any 'eat' char yet, if  */</span>
<a name="l00703"></a>00703       <span class="keywordflow">while</span> (*bw == <span class="charliteral">'A'</span>)        <span class="comment">/* there were eat-en chars the head would be over  */</span>
<a name="l00704"></a>00704         bw++, eat++;            <span class="comment">/* Happens only at end of head, and eat is still 0 */</span>
<a name="l00705"></a>00705     <span class="keywordflow">if</span> (!*bw)
<a name="l00706"></a>00706       <span class="keywordflow">return</span> 0;
<a name="l00707"></a>00707     <span class="keywordflow">if</span> (*bw != <span class="charliteral">'Z'</span>)
<a name="l00708"></a>00708     {
<a name="l00709"></a>00709       eat = 0;
<a name="l00710"></a>00710       <span class="keywordflow">if</span> (!(br &lt; rz))
<a name="l00711"></a>00711       {                         <span class="comment">/* If we failed because we got the end of head */</span>
<a name="l00712"></a>00712         trash -= (br - rx);     <span class="comment">/* it makes no sense to rollback, just trash   */</span>
<a name="l00713"></a>00713         <span class="keywordflow">if</span> (--trash &lt; 0)        <span class="comment">/* all the rest of the head wich isn't long    */</span>
<a name="l00714"></a>00714           <span class="keywordflow">return</span> 1;             <span class="comment">/* enough for this chunk and go out of this    */</span>
<a name="l00715"></a>00715         <span class="keywordflow">break</span>;                  <span class="comment">/* loop, then we try with the chunks of rm     */</span>
<a name="l00716"></a>00716       };
<a name="l00717"></a>00717       <span class="keywordflow">if</span> (--trash &lt; 0)
<a name="l00718"></a>00718         <span class="keywordflow">return</span> 1;
<a name="l00719"></a>00719     }
<a name="l00720"></a>00720     <span class="keywordflow">else</span>
<a name="l00721"></a>00721     {
<a name="l00722"></a>00722       w = bw;
<a name="l00723"></a>00723       rx = br;
<a name="l00724"></a>00724     };
<a name="l00725"></a>00725   };
<a name="l00726"></a>00726 
<a name="l00727"></a>00727   <span class="comment">/* Match the unused chunks of wm against the chunks of rm */</span>
<a name="l00728"></a>00728   rx = r;
<a name="l00729"></a>00729   <span class="keywordflow">for</span> (; *r &amp;&amp; (*r != <span class="charliteral">'Z'</span>); r++);
<a name="l00730"></a>00730   rz = r;
<a name="l00731"></a>00731   <span class="keywordflow">if</span> (*r++)
<a name="l00732"></a>00732   {
<a name="l00733"></a>00733     <span class="keywordflow">while</span> (*r)
<a name="l00734"></a>00734     {
<a name="l00735"></a>00735       bw = w;
<a name="l00736"></a>00736       <span class="keywordflow">while</span> (eat &amp;&amp; *r)         <span class="comment">/* the '?' we had eated make us skip as many chars */</span>
<a name="l00737"></a>00737         <span class="keywordflow">if</span> (*r++ != <span class="charliteral">'Z'</span>)        <span class="comment">/* here, but can't skip stars or trailing zero     */</span>
<a name="l00738"></a>00738           eat--;
<a name="l00739"></a>00739       <span class="keywordflow">for</span> (bw++; (*r) &amp;&amp; (*bw != *r); r++)
<a name="l00740"></a>00740         <span class="keywordflow">if</span> ((*r != <span class="charliteral">'Z'</span>) &amp;&amp; (--trash &lt; 0))
<a name="l00741"></a>00741           <span class="keywordflow">return</span> 1;
<a name="l00742"></a>00742       <span class="keywordflow">if</span> (!*r)
<a name="l00743"></a>00743         <span class="keywordflow">break</span>;
<a name="l00744"></a>00744       <span class="keywordflow">for</span> ((br = ++r), bw++;
<a name="l00745"></a>00745           (*br) &amp;&amp; (*br != <span class="charliteral">'Z'</span>) &amp;&amp; ((*bw == *br) || (*bw == <span class="charliteral">'A'</span>)); br++, bw++);
<a name="l00746"></a>00746       <span class="keywordflow">if</span> (*br == <span class="charliteral">'Z'</span>)
<a name="l00747"></a>00747         <span class="keywordflow">while</span> (*bw == <span class="charliteral">'A'</span>)
<a name="l00748"></a>00748           bw++, eat++;
<a name="l00749"></a>00749       <span class="keywordflow">if</span> (!*bw)
<a name="l00750"></a>00750         <span class="keywordflow">return</span> 0;
<a name="l00751"></a>00751       <span class="keywordflow">if</span> (*bw != <span class="charliteral">'Z'</span>)
<a name="l00752"></a>00752       {
<a name="l00753"></a>00753         eat = 0;
<a name="l00754"></a>00754         <span class="keywordflow">if</span> ((!*br) || (*r == <span class="charliteral">'Z'</span>))
<a name="l00755"></a>00755         {                       <span class="comment">/* If we hit the end of rm or a star in it */</span>
<a name="l00756"></a>00756           trash -= (br - r);    <span class="comment">/* makes no sense to rollback within this  */</span>
<a name="l00757"></a>00757           <span class="keywordflow">if</span> (trash &lt; 0)        <span class="comment">/* same chunk of br, skip it all and then  */</span>
<a name="l00758"></a>00758             <span class="keywordflow">return</span> 1;           <span class="comment">/* either rollback or break this loop if   */</span>
<a name="l00759"></a>00759           <span class="keywordflow">if</span> (!*br)             <span class="comment">/* it was the end of rm                    */</span>
<a name="l00760"></a>00760             <span class="keywordflow">break</span>;
<a name="l00761"></a>00761           r = br;
<a name="l00762"></a>00762         };
<a name="l00763"></a>00763         <span class="keywordflow">if</span> (--trash &lt; 0)
<a name="l00764"></a>00764           <span class="keywordflow">return</span> 1;
<a name="l00765"></a>00765       }
<a name="l00766"></a>00766       <span class="keywordflow">else</span>
<a name="l00767"></a>00767       {
<a name="l00768"></a>00768         r = br;
<a name="l00769"></a>00769         w = bw;
<a name="l00770"></a>00770       };
<a name="l00771"></a>00771     };
<a name="l00772"></a>00772   };
<a name="l00773"></a>00773 
<a name="l00774"></a>00774   <span class="comment">/* match the remaining chunks of wm against what remains of the tail of rm */</span>
<a name="l00775"></a>00775   r = rz - eat - 1;             <span class="comment">/* can't have &lt;nul&gt; or 'Z'within the tail, so just move r */</span>
<a name="l00776"></a>00776   <span class="keywordflow">while</span> (r &gt;= rx)
<a name="l00777"></a>00777   {
<a name="l00778"></a>00778     bw = w;
<a name="l00779"></a>00779     <span class="keywordflow">for</span> (bw++; (*bw != *r); r--)
<a name="l00780"></a>00780       <span class="keywordflow">if</span> (--trash &lt; 0)
<a name="l00781"></a>00781         <span class="keywordflow">return</span> 1;
<a name="l00782"></a>00782     <span class="keywordflow">if</span> (!(r &gt;= rx))
<a name="l00783"></a>00783       <span class="keywordflow">return</span> 1;
<a name="l00784"></a>00784     <span class="keywordflow">for</span> ((br = --r), bw++;
<a name="l00785"></a>00785         (*bw) &amp;&amp; (br &gt;= rx) &amp;&amp; ((*bw == *br) || (*bw == <span class="charliteral">'A'</span>)); br--, bw++);
<a name="l00786"></a>00786     <span class="keywordflow">if</span> (!*bw)
<a name="l00787"></a>00787       <span class="keywordflow">return</span> 0;
<a name="l00788"></a>00788     <span class="keywordflow">if</span> (!(br &gt;= rx))
<a name="l00789"></a>00789       <span class="keywordflow">return</span> 1;
<a name="l00790"></a>00790     <span class="keywordflow">if</span> (*bw != <span class="charliteral">'Z'</span>)
<a name="l00791"></a>00791     {
<a name="l00792"></a>00792       <span class="keywordflow">if</span> (--trash &lt; 0)
<a name="l00793"></a>00793         <span class="keywordflow">return</span> 1;
<a name="l00794"></a>00794     }
<a name="l00795"></a>00795     <span class="keywordflow">else</span>
<a name="l00796"></a>00796     {
<a name="l00797"></a>00797       r = br;
<a name="l00798"></a>00798       w = bw;
<a name="l00799"></a>00799     };
<a name="l00800"></a>00800   };
<a name="l00801"></a>00801   <span class="keywordflow">return</span> 1;                     <span class="comment">/* Auch... something left out ? Fail */</span>
<a name="l00802"></a>00802 }
<a name="l00803"></a>00803 
<a name="l00804"></a>00804 <span class="comment">/*</span>
<a name="l00805"></a>00805 <span class="comment"> * matchcompIP()</span>
<a name="l00806"></a>00806 <span class="comment"> * Compiles an IP mask into an in_mask structure</span>
<a name="l00807"></a>00807 <span class="comment"> * The given &lt;mask&gt; can either be:</span>
<a name="l00808"></a>00808 <span class="comment"> * - An usual irc type mask, containing * and or ?</span>
<a name="l00809"></a>00809 <span class="comment"> * - An ip number plus a /bitnumber part, that will only consider</span>
<a name="l00810"></a>00810 <span class="comment"> *   the first "bitnumber" bits of the IP (bitnumber must be in 0-31 range)</span>
<a name="l00811"></a>00811 <span class="comment"> * - An ip number plus a /ip.bit.mask.values that will consider</span>
<a name="l00812"></a>00812 <span class="comment"> *   only the bits marked as 1 in the ip.bit.mask.values</span>
<a name="l00813"></a>00813 <span class="comment"> * In the last two cases both the ip number and the bitmask can specify</span>
<a name="l00814"></a>00814 <span class="comment"> * less than 4 bytes, the missing bytes then default to zero, note that</span>
<a name="l00815"></a>00815 <span class="comment"> * this is *different* from the way inet_aton() does and that this does</span>
<a name="l00816"></a>00816 <span class="comment"> * NOT happen for normal IPmasks (not containing '/')</span>
<a name="l00817"></a>00817 <span class="comment"> * If the returned value is zero the produced in_mask might match some IP,</span>
<a name="l00818"></a>00818 <span class="comment"> * if it's nonzero it will never match anything (and the imask struct is</span>
<a name="l00819"></a>00819 <span class="comment"> * set so that always fails).</span>
<a name="l00820"></a>00820 <span class="comment"> *</span>
<a name="l00821"></a>00821 <span class="comment"> * The returned structure contains 3 fields whose meaning is the following:</span>
<a name="l00822"></a>00822 <span class="comment"> * im.mask = The bits considered significative in the IP</span>
<a name="l00823"></a>00823 <span class="comment"> * im.bits = What these bits should look like to have a match</span>
<a name="l00824"></a>00824 <span class="comment"> * im.fall = If zero means that the above information used as </span>
<a name="l00825"></a>00825 <span class="comment"> *           ((IP &amp; im.mask) == im.bits) is enough to tell if the compiled</span>
<a name="l00826"></a>00826 <span class="comment"> *           mask matches the given IP, nonzero means that it is needed,</span>
<a name="l00827"></a>00827 <span class="comment"> *           in case they did match, to call also the usual text match</span>
<a name="l00828"></a>00828 <span class="comment"> *           functions, because the mask wasn't "completely compiled"</span>
<a name="l00829"></a>00829 <span class="comment"> *</span>
<a name="l00830"></a>00830 <span class="comment"> * They should be used like:</span>
<a name="l00831"></a>00831 <span class="comment"> * matchcompIP(&amp;im, mask);</span>
<a name="l00832"></a>00832 <span class="comment"> * if ( ((IP &amp; im.mask)!=im.bits)) || (im.fall&amp;&amp;match(mask,inet_ntoa(IP))) )</span>
<a name="l00833"></a>00833 <span class="comment"> *    { handle_non_match } else { handle_match };</span>
<a name="l00834"></a>00834 <span class="comment"> * instead of:</span>
<a name="l00835"></a>00835 <span class="comment"> * if ( match(mask, inet_ntoa(IP)) )</span>
<a name="l00836"></a>00836 <span class="comment"> *    { handle_non_match } else { handle_match };</span>
<a name="l00837"></a>00837 <span class="comment"> * </span>
<a name="l00838"></a>00838 <span class="comment"> * Note: This function could be smarter when dealing with complex masks,</span>
<a name="l00839"></a>00839 <span class="comment"> *       this implementation is quite lazy and understands only very simple</span>
<a name="l00840"></a>00840 <span class="comment"> *       cases, whatever contains a ? anywhere or contains a '*' that isn't</span>
<a name="l00841"></a>00841 <span class="comment"> *       part of a trailing '.*' will fallback to text-match, this could be </span>
<a name="l00842"></a>00842 <span class="comment"> *       avoided for masks like 12?3.5.6 12.*.3.4 1.*.*.2 72?72?72?72 and</span>
<a name="l00843"></a>00843 <span class="comment"> *       so on that "could" be completely compiled to IP masks.</span>
<a name="l00844"></a>00844 <span class="comment"> *       If you try to improve this be aware of the fact that ? and *</span>
<a name="l00845"></a>00845 <span class="comment"> *       could match both dots and digits and we _must_ always reject</span>
<a name="l00846"></a>00846 <span class="comment"> *       what doesn't match in textform (like leading zeros and so on),</span>
<a name="l00847"></a>00847 <span class="comment"> *       so it's a LOT more tricky than it might seem. By now most common</span>
<a name="l00848"></a>00848 <span class="comment"> *       cases are optimized.</span>
<a name="l00849"></a>00849 <span class="comment"> */</span>
<a name="l00850"></a>00850 
<a name="l00851"></a><a class="code" href="match_8h.html#adadc85adf37601bb6d65860826cdd2c">00851</a> <span class="keywordtype">int</span> matchcompIP(<a class="code" href="structin__mask.html" title="An IP mask used for matchcompIP.">in_mask</a>* imask, <span class="keywordtype">char</span> <span class="keyword">const</span>* mask)
<a name="l00852"></a>00852 {
<a name="l00853"></a>00853   <span class="keyword">register</span> <span class="keywordtype">char</span> <span class="keyword">const</span>* m = mask;
<a name="l00854"></a>00854   <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bits = 0;
<a name="l00855"></a>00855   <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> filt = 0;
<a name="l00856"></a>00856   <span class="keyword">register</span> <span class="keywordtype">int</span> unco = 0;
<a name="l00857"></a>00857   <span class="keyword">register</span> <span class="keywordtype">int</span> digits = 0;
<a name="l00858"></a>00858   <span class="keyword">register</span> <span class="keywordtype">int</span> shift = 24;
<a name="l00859"></a>00859   <span class="keyword">register</span> <span class="keywordtype">int</span> tmp = 0;
<a name="l00860"></a>00860 
<a name="l00861"></a>00861   <span class="keywordflow">do</span>
<a name="l00862"></a>00862   {
<a name="l00863"></a>00863     <span class="keywordflow">switch</span> (*m)
<a name="l00864"></a>00864     {
<a name="l00865"></a>00865       <span class="keywordflow">case</span> <span class="charliteral">'\\'</span>:
<a name="l00866"></a>00866         <span class="keywordflow">if</span> ((m[1] == <span class="charliteral">'\\'</span>) || (m[1] == <span class="charliteral">'*'</span>) || (m[1] == <span class="charliteral">'?'</span>)
<a name="l00867"></a>00867             || (m[1] == <span class="charliteral">'\000'</span>))
<a name="l00868"></a>00868           <span class="keywordflow">break</span>;
<a name="l00869"></a>00869         <span class="keywordflow">continue</span>;
<a name="l00870"></a>00870       <span class="keywordflow">case</span> <span class="charliteral">'0'</span>:
<a name="l00871"></a>00871       <span class="keywordflow">case</span> <span class="charliteral">'1'</span>:
<a name="l00872"></a>00872       <span class="keywordflow">case</span> <span class="charliteral">'2'</span>:
<a name="l00873"></a>00873       <span class="keywordflow">case</span> <span class="charliteral">'3'</span>:
<a name="l00874"></a>00874       <span class="keywordflow">case</span> <span class="charliteral">'4'</span>:
<a name="l00875"></a>00875       <span class="keywordflow">case</span> <span class="charliteral">'5'</span>:
<a name="l00876"></a>00876       <span class="keywordflow">case</span> <span class="charliteral">'6'</span>:
<a name="l00877"></a>00877       <span class="keywordflow">case</span> <span class="charliteral">'7'</span>:
<a name="l00878"></a>00878       <span class="keywordflow">case</span> <span class="charliteral">'8'</span>:
<a name="l00879"></a>00879       <span class="keywordflow">case</span> <span class="charliteral">'9'</span>:
<a name="l00880"></a>00880         <span class="keywordflow">if</span> (digits &amp;&amp; !tmp)     <span class="comment">/* Leading zeros */</span>
<a name="l00881"></a>00881           <span class="keywordflow">break</span>;
<a name="l00882"></a>00882         digits++;
<a name="l00883"></a>00883         tmp *= 10;
<a name="l00884"></a>00884         tmp += (*m - <span class="charliteral">'0'</span>);      <span class="comment">/* Can't overflow, INT_MAX &gt; 2559 */</span>
<a name="l00885"></a>00885         <span class="keywordflow">if</span> (tmp &gt; 255)
<a name="l00886"></a>00886           <span class="keywordflow">break</span>;
<a name="l00887"></a>00887         <span class="keywordflow">continue</span>;
<a name="l00888"></a>00888       <span class="keywordflow">case</span> <span class="charliteral">'\000'</span>:
<a name="l00889"></a>00889         filt = 0xFFFFFFFF;
<a name="l00890"></a>00890         <span class="comment">/* Intentional fallthrough */</span>
<a name="l00891"></a>00891       <span class="keywordflow">case</span> <span class="charliteral">'.'</span>:
<a name="l00892"></a>00892         <span class="keywordflow">if</span> ((!shift) != (!*m))
<a name="l00893"></a>00893           <span class="keywordflow">break</span>;
<a name="l00894"></a>00894         <span class="comment">/* Intentional fallthrough */</span>
<a name="l00895"></a>00895       <span class="keywordflow">case</span> <span class="charliteral">'/'</span>:
<a name="l00896"></a>00896         bits |= (tmp &lt;&lt; shift);
<a name="l00897"></a>00897         shift -= 8;
<a name="l00898"></a>00898         digits = 0;
<a name="l00899"></a>00899         tmp = 0;
<a name="l00900"></a>00900         <span class="keywordflow">if</span> (*m != <span class="charliteral">'/'</span>)
<a name="l00901"></a>00901           <span class="keywordflow">continue</span>;
<a name="l00902"></a>00902         shift = 24;
<a name="l00903"></a>00903         <span class="keywordflow">do</span>
<a name="l00904"></a>00904         {
<a name="l00905"></a>00905           m++;
<a name="l00906"></a>00906           <span class="keywordflow">if</span> (IsDigit(*m))
<a name="l00907"></a>00907           {
<a name="l00908"></a>00908             <span class="keywordflow">if</span> (digits &amp;&amp; !tmp) <span class="comment">/* Leading zeros */</span>
<a name="l00909"></a>00909               <span class="keywordflow">break</span>;
<a name="l00910"></a>00910             digits++;
<a name="l00911"></a>00911             tmp *= 10;
<a name="l00912"></a>00912             tmp += (*m - <span class="charliteral">'0'</span>);  <span class="comment">/* Can't overflow, INT_MAX &gt; 2559 */</span>
<a name="l00913"></a>00913             <span class="keywordflow">if</span> (tmp &gt; 255)
<a name="l00914"></a>00914               <span class="keywordflow">break</span>;
<a name="l00915"></a>00915           }
<a name="l00916"></a>00916           <span class="keywordflow">else</span>
<a name="l00917"></a>00917           {
<a name="l00918"></a>00918             <span class="keywordflow">switch</span> (*m)
<a name="l00919"></a>00919             {
<a name="l00920"></a>00920               <span class="keywordflow">case</span> <span class="charliteral">'.'</span>:
<a name="l00921"></a>00921               <span class="keywordflow">case</span> <span class="charliteral">'\000'</span>:
<a name="l00922"></a>00922                 <span class="keywordflow">if</span> ((!shift) &amp;&amp; (*m))
<a name="l00923"></a>00923                   <span class="keywordflow">break</span>;
<a name="l00924"></a>00924                 filt |= (tmp &lt;&lt; shift);
<a name="l00925"></a>00925                 shift -= 8;
<a name="l00926"></a>00926                 tmp = 0;
<a name="l00927"></a>00927                 digits = 0;
<a name="l00928"></a>00928                 <span class="keywordflow">continue</span>;
<a name="l00929"></a>00929               <span class="keywordflow">default</span>:
<a name="l00930"></a>00930                 <span class="keywordflow">break</span>;
<a name="l00931"></a>00931             }
<a name="l00932"></a>00932             <span class="keywordflow">break</span>;
<a name="l00933"></a>00933           }
<a name="l00934"></a>00934         }
<a name="l00935"></a>00935         <span class="keywordflow">while</span> (*m);
<a name="l00936"></a>00936         <span class="keywordflow">if</span> (*m)
<a name="l00937"></a>00937           <span class="keywordflow">break</span>;
<a name="l00938"></a>00938         <span class="keywordflow">if</span> (filt &amp;&amp; (!(shift &lt; 16)) &amp;&amp; (!(filt &amp; 0xE0FFFFFF)))
<a name="l00939"></a>00939           filt = 0xFFFFFFFF &lt;&lt; (32 - ((filt &gt;&gt; 24)));
<a name="l00940"></a>00940         bits &amp;= filt;
<a name="l00941"></a>00941         <span class="keywordflow">continue</span>;
<a name="l00942"></a>00942       <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
<a name="l00943"></a>00943         unco = 1;
<a name="l00944"></a>00944         <span class="comment">/* Intentional fallthrough */</span>
<a name="l00945"></a>00945       <span class="keywordflow">case</span> <span class="charliteral">'*'</span>:
<a name="l00946"></a>00946         <span class="keywordflow">if</span> (digits)
<a name="l00947"></a>00947           unco = 1;
<a name="l00948"></a>00948         filt = (0xFFFFFFFF &lt;&lt; (shift)) &lt;&lt; 8;
<a name="l00949"></a>00949         <span class="keywordflow">while</span> (*++m)
<a name="l00950"></a>00950         {
<a name="l00951"></a>00951           <span class="keywordflow">if</span> (IsDigit(*m))
<a name="l00952"></a>00952             unco = 1;
<a name="l00953"></a>00953           <span class="keywordflow">else</span>
<a name="l00954"></a>00954           {
<a name="l00955"></a>00955             <span class="keywordflow">switch</span> (*m)
<a name="l00956"></a>00956             {
<a name="l00957"></a>00957               <span class="keywordflow">case</span> <span class="charliteral">'.'</span>:
<a name="l00958"></a>00958                 <span class="keywordflow">if</span> (m[1] != <span class="charliteral">'*'</span>)
<a name="l00959"></a>00959                   unco = 1;
<a name="l00960"></a>00960                 <span class="keywordflow">if</span> (!shift)
<a name="l00961"></a>00961                   <span class="keywordflow">break</span>;
<a name="l00962"></a>00962                 shift -= 8;
<a name="l00963"></a>00963                 <span class="keywordflow">continue</span>;
<a name="l00964"></a>00964               <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
<a name="l00965"></a>00965                 unco = 1;
<a name="l00966"></a>00966               <span class="keywordflow">case</span> <span class="charliteral">'*'</span>:
<a name="l00967"></a>00967                 <span class="keywordflow">continue</span>;
<a name="l00968"></a>00968               <span class="keywordflow">default</span>:
<a name="l00969"></a>00969                 <span class="keywordflow">break</span>;
<a name="l00970"></a>00970             }
<a name="l00971"></a>00971             <span class="keywordflow">break</span>;
<a name="l00972"></a>00972           }
<a name="l00973"></a>00973         }
<a name="l00974"></a>00974         <span class="keywordflow">if</span> (*m)
<a name="l00975"></a>00975           <span class="keywordflow">break</span>;
<a name="l00976"></a>00976         <span class="keywordflow">continue</span>;
<a name="l00977"></a>00977       <span class="keywordflow">default</span>:
<a name="l00978"></a>00978         <span class="keywordflow">break</span>;
<a name="l00979"></a>00979     }
<a name="l00980"></a>00980 
<a name="l00981"></a>00981     <span class="comment">/* If we get here there is some error and this can't ever match */</span>
<a name="l00982"></a>00982     filt = 0;
<a name="l00983"></a>00983     bits = ~0;
<a name="l00984"></a>00984     unco = 0;
<a name="l00985"></a>00985     <span class="keywordflow">break</span>;                      <span class="comment">/* This time break the loop :) */</span>
<a name="l00986"></a>00986 
<a name="l00987"></a>00987   }
<a name="l00988"></a>00988   <span class="keywordflow">while</span> (*m++);
<a name="l00989"></a>00989 
<a name="l00990"></a>00990   imask-&gt;<a class="code" href="structin__mask.html#287679f861e0542c53021864c5763596" title="What these bits should look like to have a match.">bits</a>.s_addr = htonl(bits);
<a name="l00991"></a>00991   imask-&gt;<a class="code" href="structin__mask.html#f473fce8aab0d334997539eb6ce985a0" title="The bits considered significative in the IP.">mask</a>.s_addr = htonl(filt);
<a name="l00992"></a>00992   imask-&gt;<a class="code" href="structin__mask.html#d80713f0de37377506adec86ca1a65b7" title="Non-zero if besides bits and mask a text compare is still needed.">fall</a> = unco;
<a name="l00993"></a>00993   <span class="keywordflow">return</span> ((bits &amp; ~filt) ? -1 : 0);
<a name="l00994"></a>00994 }
</pre></div></div>
<hr>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0>
<TR>
<TH ALIGN=left BGCOLOR="#e8feff"><ADDRESS>Copyright &copy; 2005-2007 Carlo Wood.&nbsp; All rights reserved.</ADDRESS></TH>
</TR>
</TABLE>

</DIV>
</BODY>
</HTML>

