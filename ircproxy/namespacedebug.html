<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML LANG="en-us">
 
<HEAD>
<META name="Author" content="Carlo Wood">
<META name="description" content="IRC proxy">
<META name="keywords" content="IRC, proxy, bnc, security, protection">
<META http-equiv="content-type" content="text/html; charset=iso-8859-1">
<TITLE>ircproxy documentation</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
<LINK HREF="main.css" REL="stylesheet" TYPE="text/css">
</HEAD>

<BODY>

<TABLE class="header" BORDER=0 CELLSPACING=0 CELLPADDING=0>
<TR>
<TD WIDTH=120><IMG SRC="images/ircproxy.png" BORDER=0></TD>
<TD VALIGN=center ALIGN=center BGCOLOR="#0A0607"><FONT size=+4 color="#ffffff"><B>&nbsp;ircproxy</B>&nbsp;</FONT>
<FONT size=+3 color="#ffffff">The&nbsp;Ultimate&nbsp;Cyborg</FONT></TD>
</TR>
</TABLE>

<DIV class="normal">
<hr>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>debug Namespace Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Debug specific code. 
<p>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebug_1_1InvisibleAllocations.html">InvisibleAllocations</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface for marking scopes of invisible memory allocations.  <a href="structdebug_1_1InvisibleAllocations.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebug_1_1Indent.html">Indent</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface for marking scopes with indented <a class="el" href="namespacedebug.html" title="Debug specific code.">debug</a> output.  <a href="structdebug_1_1Indent.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebug_1_1SecondaryConnection.html">SecondaryConnection</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdebug_1_1TeeBuf.html">TeeBuf</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdebug_1_1TeeStream.html">TeeStream</a></td></tr>

<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedebug_1_1channels.html">channels</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debug Channels (<a class="el" href="namespacedebug_1_1channels_1_1dc.html" title="The namespace containing the actual debug channels.">dc</a>) namespace. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedebug.html#f2c477186f7fdbd0593241d7f4f1c855">is_on_in_rcfile</a> (char const *dc_label)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the the original state of a <a class="el" href="namespacedebug.html" title="Debug specific code.">debug</a> channel.  <a href="#f2c477186f7fdbd0593241d7f4f1c855"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedebug.html#d3f9b34eb8b7eb68313fa0e6f1c238b5">init_thread</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize debugging code from new threads.  <a href="#d3f9b34eb8b7eb68313fa0e6f1c238b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedebug.html#ee52af5fc0d681b4df07b2219e3a8b1a">init</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize debugging code from main.  <a href="#ee52af5fc0d681b4df07b2219e3a8b1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedebug.html#df1d69dd8c5cffcb6f1c1e065febea95">dump_hex</a> (libcwd::channel_ct const &amp;channel, unsigned char const *buf, size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a hexadecimal and ascii dump of a buffer to a given <a class="el" href="namespacedebug.html" title="Debug specific code.">debug</a> channel.  <a href="#df1d69dd8c5cffcb6f1c1e065febea95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedebug.html#ff6b0a4419699fff1258dfedbbe5e710">state_nt_name</a> (<a class="el" href="ServerConnection_8h.html#8bd3e377b5e0da0a7d154425796c9ef2">state_nt</a> state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a string literal representing the name of the <code>state_nt</code> <em>state</em>.  <a href="#ff6b0a4419699fff1258dfedbbe5e710"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedebug.html#bd19a53f9dcf6a6f21cfce7bddb4765b">openmode_name</a> (<a class="el" href="classPersistXML.html#ebe6d1165a2ef09b5cc722f09d145eda">PersistXML::openmode_type</a> openmode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a string literal representing the name of the <code><a class="el" href="classPersistXML.html#ebe6d1165a2ef09b5cc722f09d145eda" title="The open mode type of the archive.">PersistXML::openmode_type</a></code> <em>openmode</em>.  <a href="#bd19a53f9dcf6a6f21cfce7bddb4765b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedebug.html#8b26f684e91c586576ce2549e0764417">match0_type_name</a> (<a class="el" href="Matcher_8h.html#90f3670ed6ab047285d10701e29dbafd">match0_type</a> mt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a string literal representing the name of the <code>match0_type</code> <em>mt</em>.  <a href="#8b26f684e91c586576ce2549e0764417"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedebug.html#98b208714e1cc8c764b14977737502ba">match1_type_name</a> (<a class="el" href="Matcher_8h.html#da3b2c552b1637cb1dd042c8e4b424a7">match1_type</a> mt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a string literal representing the name of the <code>match1_type</code> <em>mt</em>.  <a href="#98b208714e1cc8c764b14977737502ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedebug.html#39d601594009b086edd65d2a51356dbe">command_name</a> (int command)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a string literal representing the name of the <code>int</code> <em>command</em>.  <a href="#39d601594009b086edd65d2a51356dbe"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="f2c477186f7fdbd0593241d7f4f1c855"></a><!-- doxytag: member="debug::is_on_in_rcfile" ref="f2c477186f7fdbd0593241d7f4f1c855" args="(char const *dc_label)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool debug::is_on_in_rcfile           </td>
          <td>(</td>
          <td class="paramtype">char const *&nbsp;</td>
          <td class="paramname"> <em>dc_label</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the the original state of a <a class="el" href="namespacedebug.html" title="Debug specific code.">debug</a> channel. 
<p>
<p><b>For internal use only.</b></p>
<p>
For a given <em>dc_label</em>, which must be the exact name (<code>channel_ct::get_label</code>) of an existing <a class="el" href="namespacedebug.html" title="Debug specific code.">debug</a> channel, this function returns <code>true</code> when the corresponding <a class="el" href="namespacedebug.html" title="Debug specific code.">debug</a> channel was <em>on</em> at the startup of the application, directly after reading the libcwd runtime configuration file (.libcwdrc).<p>
If the label/channel did not exist at the start of the application, it will return <code>false</code> (note that libcwd disallows adding <a class="el" href="namespacedebug.html" title="Debug specific code.">debug</a> <a class="el" href="namespacedebug_1_1channels.html" title="Debug Channels (dc) namespace.">channels</a> to modules - so this would probably a bug). </p>

<p>Definition at line <a class="el" href="debug_8cc-source.html#l00128">128</a> of file <a class="el" href="debug_8cc-source.html">debug.cc</a>.</p>

<p>Referenced by <a class="el" href="debug_8cc-source.html#l00149">init_thread()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00129"></a>00129   {
<a name="l00130"></a>00130     rcfile_dc_states_type::const_iterator iter = rcfile_dc_states.find(std::string(dc_label));
<a name="l00131"></a>00131     <span class="keywordflow">if</span> (iter == rcfile_dc_states.end())
<a name="l00132"></a>00132     {
<a name="l00133"></a>00133       Dout(dc::warning, <span class="stringliteral">"is_on_in_rcfile(\""</span> &lt;&lt; dc_label &lt;&lt; <span class="stringliteral">"\"): \""</span> &lt;&lt; dc_label &lt;&lt; <span class="stringliteral">"\" is an unknown label!"</span>);
<a name="l00134"></a>00134       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00135"></a>00135     }
<a name="l00136"></a>00136     <span class="keywordflow">return</span> iter-&gt;second;
<a name="l00137"></a>00137   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d3f9b34eb8b7eb68313fa0e6f1c238b5"></a><!-- doxytag: member="debug::init_thread" ref="d3f9b34eb8b7eb68313fa0e6f1c238b5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void debug::init_thread           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize debugging code from new threads. 
<p>
This function needs to be called at the start of each new thread, because a new thread starts in a completely reset state.<p>
The function turns on all <a class="el" href="namespacedebug.html" title="Debug specific code.">debug</a> <a class="el" href="namespacedebug_1_1channels.html" title="Debug Channels (dc) namespace.">channels</a> that were turned on after reading the rcfile at the start of the application. Furthermore it initializes the <a class="el" href="namespacedebug.html" title="Debug specific code.">debug</a> ostream, its mutex and the margin of the default <a class="el" href="namespacedebug.html" title="Debug specific code.">debug</a> object (Dout). 
<p>Definition at line <a class="el" href="debug_8cc-source.html#l00149">149</a> of file <a class="el" href="debug_8cc-source.html">debug.cc</a>.</p>

<p>References <a class="el" href="debug_8cc-source.html#l00128">is_on_in_rcfile()</a>.</p>

<p>Referenced by <a class="el" href="debug_8cc-source.html#l00179">init()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00150"></a>00150   {
<a name="l00151"></a>00151     <span class="comment">// Turn on all debug channels that are turned on as per rcfile configuration.</span>
<a name="l00152"></a>00152     ForAllDebugChannels(
<a name="l00153"></a>00153         <span class="keywordflow">if</span> (!debugChannel.is_on() &amp;&amp; <a class="code" href="namespacedebug.html#f2c477186f7fdbd0593241d7f4f1c855" title="Returns the the original state of a debug channel.">is_on_in_rcfile</a>(debugChannel.get_label()))
<a name="l00154"></a>00154           debugChannel.on();
<a name="l00155"></a>00155     );
<a name="l00156"></a>00156 
<a name="l00157"></a>00157     <span class="comment">// Turn on debug output.</span>
<a name="l00158"></a>00158     Debug( libcw_do.on() );
<a name="l00159"></a>00159 <span class="preprocessor">#if LIBCWD_THREAD_SAFE</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span>    Debug( libcw_do.set_ostream(&amp;std::cout, &amp;cout_mutex) );
<a name="l00161"></a>00161 <span class="preprocessor">#else</span>
<a name="l00162"></a>00162 <span class="preprocessor"></span>    Debug( libcw_do.set_ostream(&amp;std::cout) );
<a name="l00163"></a>00163 <span class="preprocessor">#endif</span>
<a name="l00164"></a>00164 <span class="preprocessor"></span>
<a name="l00165"></a>00165     <span class="keyword">static</span> <span class="keywordtype">bool</span> first_thread = <span class="keyword">true</span>;
<a name="l00166"></a>00166     <span class="keywordflow">if</span> (!first_thread)                  <span class="comment">// So far, the application has only one thread.  So don't add a thread id.</span>
<a name="l00167"></a>00167     {
<a name="l00168"></a>00168       <span class="comment">// Set the thread id in the margin.</span>
<a name="l00169"></a>00169       <span class="keywordtype">char</span> margin[12];
<a name="l00170"></a>00170       sprintf(margin, <span class="stringliteral">"%-10lu "</span>, pthread_self());
<a name="l00171"></a>00171       Debug( libcw_do.margin().assign(margin, 11) );
<a name="l00172"></a>00172     }
<a name="l00173"></a>00173   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ee52af5fc0d681b4df07b2219e3a8b1a"></a><!-- doxytag: member="debug::init" ref="ee52af5fc0d681b4df07b2219e3a8b1a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void debug::init           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize debugging code from main. 
<p>
This function initializes the <a class="el" href="namespacedebug.html" title="Debug specific code.">debug</a> code. 
<p>Definition at line <a class="el" href="debug_8cc-source.html#l00179">179</a> of file <a class="el" href="debug_8cc-source.html">debug.cc</a>.</p>

<p>References <a class="el" href="debug_8cc-source.html#l00149">init_thread()</a>.</p>

<p>Referenced by <a class="el" href="Application_8cc-source.html#l00089">Application::main_entered()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00180"></a>00180   {
<a name="l00181"></a>00181 <span class="preprocessor">#if CWDEBUG_ALLOC &amp;&amp; defined(USE_LIBCW)</span>
<a name="l00182"></a>00182 <span class="preprocessor"></span>    <span class="comment">// Tell the memory leak detector which parts of the code are</span>
<a name="l00183"></a>00183     <span class="comment">// expected to leak so that we won't get an alarm for those.</span>
<a name="l00184"></a>00184     {
<a name="l00185"></a>00185       std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; hide_list;
<a name="l00186"></a>00186       hide_list.push_back(std::pair&lt;std::string, std::string&gt;(<span class="stringliteral">"libdl.so.2"</span>, <span class="stringliteral">"_dlerror_run"</span>));
<a name="l00187"></a>00187       hide_list.push_back(std::pair&lt;std::string, std::string&gt;(<span class="stringliteral">"libstdc++.so.6"</span>, <span class="stringliteral">"__cxa_get_globals"</span>));
<a name="l00188"></a>00188       <span class="comment">// The following is actually necessary because of a bug in glibc</span>
<a name="l00189"></a>00189       <span class="comment">// (see http://sources.redhat.com/bugzilla/show_bug.cgi?id=311).</span>
<a name="l00190"></a>00190       hide_list.push_back(std::pair&lt;std::string, std::string&gt;(<span class="stringliteral">"libc.so.6"</span>, <span class="stringliteral">"dl_open_worker"</span>));
<a name="l00191"></a>00191       memleak_filter().hide_functions_matching(hide_list);
<a name="l00192"></a>00192     }
<a name="l00193"></a>00193     {
<a name="l00194"></a>00194       std::vector&lt;std::string&gt; hide_list;
<a name="l00195"></a>00195       <span class="comment">// Also because of http://sources.redhat.com/bugzilla/show_bug.cgi?id=311</span>
<a name="l00196"></a>00196       hide_list.push_back(std::string(<span class="stringliteral">"ld-linux.so.2"</span>));
<a name="l00197"></a>00197       memleak_filter().hide_objectfiles_matching(hide_list);
<a name="l00198"></a>00198     }
<a name="l00199"></a>00199     memleak_filter().set_flags(libcwd::show_objectfile|libcwd::show_function);
<a name="l00200"></a>00200 <span class="preprocessor">#endif</span>
<a name="l00201"></a>00201 <span class="preprocessor"></span>
<a name="l00202"></a>00202     <span class="comment">// The following call allocated the filebuf's of cin, cout, cerr, wcin, wcout and wcerr.</span>
<a name="l00203"></a>00203     <span class="comment">// Because this causes a memory leak being reported, make them invisible.</span>
<a name="l00204"></a>00204     Debug(set_invisible_on());
<a name="l00205"></a>00205 
<a name="l00206"></a>00206     <span class="comment">// You want this, unless you mix streams output with C output.</span>
<a name="l00207"></a>00207     <span class="comment">// Read  http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#8 for an explanation.</span>
<a name="l00208"></a>00208     <span class="comment">//std::ios::sync_with_stdio(false);</span>
<a name="l00209"></a>00209 
<a name="l00210"></a>00210     <span class="comment">// Cancel previous call to set_invisible_on.</span>
<a name="l00211"></a>00211     Debug(set_invisible_off());
<a name="l00212"></a>00212 
<a name="l00213"></a>00213     <span class="comment">// This will warn you when you are using header files that do not belong to the</span>
<a name="l00214"></a>00214     <span class="comment">// shared libcwd object that you linked with.</span>
<a name="l00215"></a>00215     Debug( check_configuration() );
<a name="l00216"></a>00216 
<a name="l00217"></a>00217     Debug(
<a name="l00218"></a>00218       libcw_do.on();            <span class="comment">// Show which rcfile we are reading!</span>
<a name="l00219"></a>00219       ForAllDebugChannels(
<a name="l00220"></a>00220         <span class="keywordflow">while</span> (debugChannel.is_on())
<a name="l00221"></a>00221           debugChannel.off()    <span class="comment">// Print as little as possible though.</span>
<a name="l00222"></a>00222       );
<a name="l00223"></a>00223       read_rcfile();            <span class="comment">// Put 'silent = on' in the rcfile to suppress most of the output here.</span>
<a name="l00224"></a>00224       libcw_do.off()
<a name="l00225"></a>00225     );
<a name="l00226"></a>00226     save_dc_states();
<a name="l00227"></a>00227 
<a name="l00228"></a>00228     <a class="code" href="namespacedebug.html#d3f9b34eb8b7eb68313fa0e6f1c238b5" title="Initialize debugging code from new threads.">init_thread</a>();
<a name="l00229"></a>00229   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="df1d69dd8c5cffcb6f1c1e065febea95"></a><!-- doxytag: member="debug::dump_hex" ref="df1d69dd8c5cffcb6f1c1e065febea95" args="(libcwd::channel_ct const &amp;channel, unsigned char const *buf, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void debug::dump_hex           </td>
          <td>(</td>
          <td class="paramtype">libcwd::channel_ct const &amp;&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char const *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a hexadecimal and ascii dump of a buffer to a given <a class="el" href="namespacedebug.html" title="Debug specific code.">debug</a> channel. 
<p>
This function can be used to print a binary block of data of <em>size</em> bytes, starting at <em>buf</em>. The output is written to <a class="el" href="namespacedebug.html" title="Debug specific code.">debug</a> channel <em>channel</em>. 
<p>Definition at line <a class="el" href="debug_8cc-source.html#l00236">236</a> of file <a class="el" href="debug_8cc-source.html">debug.cc</a>.</p>

<p>References <a class="el" href="debug_8h-source.html#l00073">DEBUGCHANNELS</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00237"></a>00237   {
<a name="l00238"></a>00238     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> addr = 0; addr &lt; size; addr += 16)
<a name="l00239"></a>00239     {
<a name="l00240"></a>00240       LibcwDoutScopeBegin(<a class="code" href="debug_8h.html#229fff65ddcd774b6cfe99a1c66b4687" title="The namespace in which the dc namespace is declared.">DEBUGCHANNELS</a>, libcwd::libcw_do, channel)
<a name="l00241"></a>00241       LibcwDoutStream &lt;&lt; std::hex &lt;&lt; std::setfill('0') &lt;&lt; std::setw(4) &lt;&lt; addr &lt;&lt; " |";
<a name="l00242"></a>00242       <span class="keywordtype">int</span> offset;
<a name="l00243"></a>00243       for (offset = 0; offset &lt; 16 &amp;&amp; addr + offset &lt; size; ++offset)
<a name="l00244"></a>00244         LibcwDoutStream &lt;&lt; ' ' &lt;&lt; std::hex &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; (<span class="keywordtype">int</span>)buf[addr + offset];
<a name="l00245"></a>00245       for (; offset &lt; 16; ++offset)
<a name="l00246"></a>00246         LibcwDoutStream &lt;&lt; "   ";
<a name="l00247"></a>00247       LibcwDoutStream &lt;&lt; " | ";
<a name="l00248"></a>00248       for (<span class="keywordtype">int</span> offset = 0; offset &lt; 16 &amp;&amp; addr + offset &lt; size; ++offset)
<a name="l00249"></a>00249       {
<a name="l00250"></a>00250         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c = buf[addr + offset];
<a name="l00251"></a>00251         <span class="keywordflow">if</span> (!std::isprint(c))
<a name="l00252"></a>00252           c = <span class="charliteral">'.'</span>;
<a name="l00253"></a>00253         LibcwDoutStream &lt;&lt; c;
<a name="l00254"></a>00254       }
<a name="l00255"></a>00255       LibcwDoutScopeEnd;
<a name="l00256"></a>00256     }
<a name="l00257"></a>00257   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ff6b0a4419699fff1258dfedbbe5e710"></a><!-- doxytag: member="debug::state_nt_name" ref="ff6b0a4419699fff1258dfedbbe5e710" args="(state_nt state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const* debug::state_nt_name           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ServerConnection_8h.html#8bd3e377b5e0da0a7d154425796c9ef2">state_nt</a>&nbsp;</td>
          <td class="paramname"> <em>state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a string literal representing the name of the <code>state_nt</code> <em>state</em>. 
<p>
<p><b>For internal use only.</b></p>
<p>
</p>

<p>Definition at line <a class="el" href="debug__ostream__operators_8cc-source.html#l00062">62</a> of file <a class="el" href="debug__ostream__operators_8cc-source.html">debug_ostream_operators.cc</a>.</p>

<p>References <a class="el" href="ServerConnection_8h-source.html#l00039">authentication_started</a>, <a class="el" href="casereturnstr_8h-source.html#l00033">CASERETURNSTR</a>, <a class="el" href="ServerConnection_8h-source.html#l00038">disconnected</a>, <a class="el" href="ServerConnection_8h-source.html#l00042">login_sent</a>, <a class="el" href="ServerConnection_8h-source.html#l00041">pong_sent</a>, <a class="el" href="ServerConnection_8h-source.html#l00044">real_nick_accepted</a>, <a class="el" href="ServerConnection_8h-source.html#l00043">real_nick_sent</a>, and <a class="el" href="ServerConnection_8h-source.html#l00040">successful_connect</a>.</p>

<p>Referenced by <a class="el" href="debug__ostream__operators_8cc-source.html#l00169">operator&lt;&lt;()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00063"></a>00063 {
<a name="l00064"></a>00064   <span class="keywordflow">switch</span>(state)
<a name="l00065"></a>00065   {
<a name="l00066"></a>00066     <span class="comment">// See enum state_nt in ServerConnection.h</span>
<a name="l00067"></a>00067     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(<a class="code" href="ServerConnection_8h.html#8bd3e377b5e0da0a7d154425796c9ef2519f950c18a0ec32082cf9984cd2b225" title="Disconnected.">disconnected</a>);
<a name="l00068"></a>00068     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(<a class="code" href="ServerConnection_8h.html#8bd3e377b5e0da0a7d154425796c9ef220561b24714ed87425f7d797a83f1f78" title="Received first server message.">successful_connect</a>);
<a name="l00069"></a>00069     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(<a class="code" href="ServerConnection_8h.html#8bd3e377b5e0da0a7d154425796c9ef257f508eceda8432c9eab0643f0e6346d" title="PASS, NICK and USER message sent.">authentication_started</a>);
<a name="l00070"></a>00070     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(<a class="code" href="ServerConnection_8h.html#8bd3e377b5e0da0a7d154425796c9ef2e329594b1df5c5307e5e5126edb1d605" title="PONG and MODE +i sent.">pong_sent</a>);
<a name="l00071"></a>00071     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(<a class="code" href="ServerConnection_8h.html#8bd3e377b5e0da0a7d154425796c9ef27fedf7842abd845d06c188fc73e5775b" title="Login message to X sent.">login_sent</a>);
<a name="l00072"></a>00072     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(<a class="code" href="ServerConnection_8h.html#8bd3e377b5e0da0a7d154425796c9ef23fcdc806883284d1121056468515dc4d" title="NICK with real nick name sent.">real_nick_sent</a>);
<a name="l00073"></a>00073     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(<a class="code" href="ServerConnection_8h.html#8bd3e377b5e0da0a7d154425796c9ef27bbffd5a8ff7ab2301e2e2a7df9be974" title="NICK with real nick accepted.">real_nick_accepted</a>);
<a name="l00074"></a>00074   }
<a name="l00075"></a>00075   DoutFatal(dc::fatal, <span class="stringliteral">"Unhandled state_nt in state_nt_name"</span>);
<a name="l00076"></a>00076 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="bd19a53f9dcf6a6f21cfce7bddb4765b"></a><!-- doxytag: member="debug::openmode_name" ref="bd19a53f9dcf6a6f21cfce7bddb4765b" args="(PersistXML::openmode_type openmode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const* debug::openmode_name           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPersistXML.html#ebe6d1165a2ef09b5cc722f09d145eda">PersistXML::openmode_type</a>&nbsp;</td>
          <td class="paramname"> <em>openmode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a string literal representing the name of the <code><a class="el" href="classPersistXML.html#ebe6d1165a2ef09b5cc722f09d145eda" title="The open mode type of the archive.">PersistXML::openmode_type</a></code> <em>openmode</em>. 
<p>
<p><b>For internal use only.</b></p>
<p>
</p>

<p>Definition at line <a class="el" href="debug__ostream__operators_8cc-source.html#l00082">82</a> of file <a class="el" href="debug__ostream__operators_8cc-source.html">debug_ostream_operators.cc</a>.</p>

<p>References <a class="el" href="casereturnstr_8h-source.html#l00033">CASERETURNSTR</a>, <a class="el" href="PersistXML_8h-source.html#l00101">PersistXML::load</a>, <a class="el" href="PersistXML_8h-source.html#l00099">PersistXML::not_open</a>, and <a class="el" href="PersistXML_8h-source.html#l00100">PersistXML::store</a>.</p>

<p>Referenced by <a class="el" href="debug__ostream__operators_8cc-source.html#l00175">operator&lt;&lt;()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00083"></a>00083 {
<a name="l00084"></a>00084   <span class="keywordflow">switch</span>(openmode)
<a name="l00085"></a>00085   {
<a name="l00086"></a>00086     <span class="comment">// See enum PersistXML::openmode_type in PersistXML.h</span>
<a name="l00087"></a>00087     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(<a class="code" href="classPersistXML.html#ebe6d1165a2ef09b5cc722f09d145edaad0d87e448e1d77010c4111d76a6ed93" title="Used internally to mark that the archive is not open.">PersistXML::not_open</a>);
<a name="l00088"></a>00088     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(<a class="code" href="classPersistXML.html#ebe6d1165a2ef09b5cc722f09d145eda332ebd1dc31393255a2a6ed1ddcb0270" title="Open for writing objects to the archive.">PersistXML::store</a>);
<a name="l00089"></a>00089     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(<a class="code" href="classPersistXML.html#ebe6d1165a2ef09b5cc722f09d145eda312929ba0cd974a84c9edeaad046c922" title="Open for reading objects from the archive.">PersistXML::load</a>);
<a name="l00090"></a>00090   }
<a name="l00091"></a>00091   DoutFatal(dc::fatal, <span class="stringliteral">"Unhandled PersistXML::openmode in openmode_name"</span>);
<a name="l00092"></a>00092 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8b26f684e91c586576ce2549e0764417"></a><!-- doxytag: member="debug::match0_type_name" ref="8b26f684e91c586576ce2549e0764417" args="(match0_type mt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const* debug::match0_type_name           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Matcher_8h.html#90f3670ed6ab047285d10701e29dbafd">match0_type</a>&nbsp;</td>
          <td class="paramname"> <em>mt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a string literal representing the name of the <code>match0_type</code> <em>mt</em>. 
<p>
<p><b>For internal use only.</b></p>
<p>
</p>

<p>Definition at line <a class="el" href="debug__ostream__operators_8cc-source.html#l00098">98</a> of file <a class="el" href="debug__ostream__operators_8cc-source.html">debug_ostream_operators.cc</a>.</p>

<p>References <a class="el" href="casereturnstr_8h-source.html#l00033">CASERETURNSTR</a>.</p>

<p>Referenced by <a class="el" href="debug__ostream__operators_8cc-source.html#l00181">operator&lt;&lt;()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00099"></a>00099 {
<a name="l00100"></a>00100   <span class="keywordflow">switch</span>(mt)
<a name="l00101"></a>00101   {
<a name="l00102"></a>00102     <span class="comment">// See enum match0_type in Matcher.h</span>
<a name="l00103"></a>00103     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(anystring_mt);
<a name="l00104"></a>00104     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(nonemptystring_mt);
<a name="l00105"></a>00105     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(anyserver_mt);
<a name="l00106"></a>00106     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(localserver_mt);
<a name="l00107"></a>00107     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(anynick_mt);
<a name="l00108"></a>00108     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(mynick_mt);
<a name="l00109"></a>00109     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(anychannel_mt);
<a name="l00110"></a>00110     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(anyglobalchannel_mt);
<a name="l00111"></a>00111     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(anylocalchannel_mt);
<a name="l00112"></a>00112   }
<a name="l00113"></a>00113   DoutFatal(dc::fatal, <span class="stringliteral">"Unhandled match0_type in match0_type_name"</span>);
<a name="l00114"></a>00114 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="98b208714e1cc8c764b14977737502ba"></a><!-- doxytag: member="debug::match1_type_name" ref="98b208714e1cc8c764b14977737502ba" args="(match1_type mt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const* debug::match1_type_name           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Matcher_8h.html#da3b2c552b1637cb1dd042c8e4b424a7">match1_type</a>&nbsp;</td>
          <td class="paramname"> <em>mt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a string literal representing the name of the <code>match1_type</code> <em>mt</em>. 
<p>
<p><b>For internal use only.</b></p>
<p>
</p>

<p>Definition at line <a class="el" href="debug__ostream__operators_8cc-source.html#l00120">120</a> of file <a class="el" href="debug__ostream__operators_8cc-source.html">debug_ostream_operators.cc</a>.</p>

<p>References <a class="el" href="casereturnstr_8h-source.html#l00033">CASERETURNSTR</a>.</p>

<p>Referenced by <a class="el" href="debug__ostream__operators_8cc-source.html#l00187">operator&lt;&lt;()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00121"></a>00121 {
<a name="l00122"></a>00122   <span class="keywordflow">switch</span>(mt)
<a name="l00123"></a>00123   {
<a name="l00124"></a>00124     <span class="comment">// See enum match1_type in Matcher.h</span>
<a name="l00125"></a>00125     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(wildcard_mt);
<a name="l00126"></a>00126     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(regexp_mt);
<a name="l00127"></a>00127     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(exactmatch_mt);
<a name="l00128"></a>00128   }
<a name="l00129"></a>00129   DoutFatal(dc::fatal, <span class="stringliteral">"Unhandled match1_type in match1_type_name"</span>);
<a name="l00130"></a>00130 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="39d601594009b086edd65d2a51356dbe"></a><!-- doxytag: member="debug::command_name" ref="39d601594009b086edd65d2a51356dbe" args="(int command)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const* debug::command_name           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>command</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a string literal representing the name of the <code>int</code> <em>command</em>. 
<p>
<p><b>For internal use only.</b></p>
<p>
</p>

<p>Definition at line <a class="el" href="debug__ostream__operators_8cc-source.html#l00136">136</a> of file <a class="el" href="debug__ostream__operators_8cc-source.html">debug_ostream_operators.cc</a>.</p>

<p>References <a class="el" href="casereturnstr_8h-source.html#l00033">CASERETURNSTR</a>.</p>

<p>Referenced by <a class="el" href="debug__ostream__operators_8cc-source.html#l00531">operator&lt;&lt;()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00137"></a>00137 {
<a name="l00138"></a>00138   <span class="keyword">using namespace </span>keys;
<a name="l00139"></a>00139   <span class="keywordflow">switch</span>(command)
<a name="l00140"></a>00140   {
<a name="l00141"></a>00141     <span class="comment">// See irc_commands</span>
<a name="l00142"></a>00142     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(PASS);
<a name="l00143"></a>00143     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(USER);
<a name="l00144"></a>00144     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(NICK);
<a name="l00145"></a>00145     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(PING);
<a name="l00146"></a>00146     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(ERROR);
<a name="l00147"></a>00147     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(QUIT);
<a name="l00148"></a>00148     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(WHO);
<a name="l00149"></a>00149     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(WHOIS);
<a name="l00150"></a>00150     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(WHOWAS);
<a name="l00151"></a>00151     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(PRIVMSG);
<a name="l00152"></a>00152     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(NOTICE);
<a name="l00153"></a>00153     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(CPRIVMSG);
<a name="l00154"></a>00154     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(CNOTICE);
<a name="l00155"></a>00155     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(LINKS);
<a name="l00156"></a>00156     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(JOIN);
<a name="l00157"></a>00157     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(PART);
<a name="l00158"></a>00158     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(KICK);
<a name="l00159"></a>00159     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(MODE);
<a name="l00160"></a>00160     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(NAMES);
<a name="l00161"></a>00161     <a class="code" href="casereturnstr_8h.html#240d4e206827df8daae7639aed581055" title="Macro for switches that print enums.">CASERETURNSTR</a>(TOPIC);
<a name="l00162"></a>00162   }
<a name="l00163"></a>00163   DoutFatal(dc::fatal, <span class="stringliteral">"Unhandled command key in command_name"</span>);
<a name="l00164"></a>00164 }
</pre></div>
<p>

</div>
</div><p>
</div>
<hr>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0>
<TR>
<TH ALIGN=left BGCOLOR="#e8feff"><ADDRESS>Copyright &copy; 2005-2007 Carlo Wood.&nbsp; All rights reserved.</ADDRESS></TH>
</TR>
</TABLE>

</DIV>
</BODY>
</HTML>

