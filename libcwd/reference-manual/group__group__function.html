<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML LANG="en-us">
<HEAD>
<META name="Author" content="Carlo Wood">
<META name="description" content="C++ debugging support library with ostream debug output">
<META name="keywords" content="libcwd, debug output, debug facility, debug channel, object orientation, OO, C++, nested debug output, ostream, memory allocation, debugging, source file and line number">
<META http-equiv="content-type" content="text/html; charset=iso-8859-1">
<META http-equiv="content-script-type" content="text/javascript">
<TITLE>libcwd: The C++ Debugging Support Library - Reference Manual</TITLE>
<SCRIPT src="../scripts/detect_browser.js"></SCRIPT>
<SCRIPT>need_style_doxygen=1</SCRIPT>
<SCRIPT src="../scripts/load_style_sheets.js"></SCRIPT>
</HEAD>
<BODY>
<DIV class="normal">
<center>
<a class="qindex" href="../index.html">Main Page</a> &nbsp;
<a class="qindex" href="index.html">Reference Manual</a> &nbsp;
<a class="qindex" href="namespaces.html">Namespace List</a> &nbsp;
<a class="qindex" href="annotated.html">Compound List</a> &nbsp;
<a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp;
<a class="qindex" href="functions.html">Compound Members</a> &nbsp;
<a class="qindex" href="globals.html">File Members</a> &nbsp;
</center>
<HR SIZE=1 NOSHADE>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Function objects</div>  </div>
</div><!--header-->
<div class="contents">
<p>... </p>
<div class="textblock"><hr  />
<h2>Defining and initializing <code>Function</code> objects</h2>
<h4>Defining</h4>
<code>Function</code> objects need to be defined as static or global objects otherwise they will be re-initialized every time you call the <code>Function::init()</code> method.<div class="fragment"><div class="line">Function f1;                    <span class="comment">// Global `Function&#39; instance.</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> f()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> Function f2;           <span class="comment">// Static `Function&#39; instance.</span></div>
<div class="line">  f2.init();</div>
<div class="line">}</div>
</div><!-- fragment -->Each <code>Function</code> instance needs to be initialized at least once before it can be used. There are several ways to do this all of which use the overloaded <code>Function::init()</code> method.When you try to use an uninitialized <code>Function</code> object, the program will fail by default (exit with an error message). If you don't want that then you can add a flag to its constructor:<div class="fragment"><div class="line">Function f1(Function::nofail);</div>
</div><!-- fragment --><h4>Initializing</h4>
First of all, it is possible to assign the <em>current function</em> to a <code>Function</code> object like so:<div class="fragment"><div class="line"><span class="keywordtype">void</span> f()</div>
<div class="line">{</div>
<div class="line">  f1.init();                                    <span class="comment">// f1 represents the current function, f().</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment -->If this function is a template function (or a method in a templated class) then it is possible that it covers more than one instance. Therefore, in the case of a template you need to make the function object a static instance inside the template function: this will lead to one instance per template function instantiation.In order to be able to refer to it later in that case you must use another <code>Function</code> to alias for the static instance:<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keywordtype">void</span> f(T <span class="keyword">const</span>&amp; a)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">static</span> Function sf;                         <span class="comment">// Do NOT call sf.init()!</span></div>
<div class="line">    f1.init(sf);                                <span class="comment">// f1 represents all `void f&lt;T&gt;(T const&amp;)&#39;</span></div>
<div class="line">                                                <span class="comment">//   template function instantiations that</span></div>
<div class="line">    <span class="comment">// ...                                      //   have been called so far.</span></div>
<div class="line">  }</div>
</div><!-- fragment -->Note that in this case the <em>static</em> object must <b>not</b> be initialized!<h4>Searches</h4>
If you need to refer to functions that are not called yet, or when those functions are part of third party libraries, then you'll need to use search routines. These are much slower, especially the ones that use the demangled names; but each lookup will be done only once.The following examples demonstrate several ways to search for function symbols. These initialization calls are best put early in main() of course. All of them will print debug output about what they are looking up and what they found. By default they will fail when nothing is found.<div class="fragment"><div class="line">f1.init(Function::regexp(<span class="stringliteral">&quot;^int g(.*)$&quot;</span>));       <span class="comment">// f1 represents all functions &#39;g&#39; returning an int.</span></div>
<div class="line"> </div>
<div class="line">f1.init(Function::exactmatch(<span class="stringliteral">&quot;int h(void)&quot;</span>));   <span class="comment">// f1 represents the function &#39;int h()&#39;.</span></div>
<div class="line"> </div>
<div class="line">f1.init(Function::mangled(<span class="stringliteral">&quot;_ZTv0_n12_NSoD0Ev&quot;</span>); <span class="comment">// Look up by mangled name (exact matches only).</span></div>
</div><!-- fragment -->The <code>mangled</code> lookup is the fastest. It looks for both, C++ as well as C functions, so you could use it to look for C functions skipping the cpu intensive demangling that way. However, you can also specifically specify that the function you are looking for has C linkage by passing a flag to the search.Flags are always the right-most parameter.<div class="fragment"><div class="line">f1.init(Function::regexp(<span class="stringliteral">&quot;malloc&quot;</span>), Function::c_linkage);</div>
</div><!-- fragment --><code>regexp</code> and <code>exactmatch</code> look only for C++ functions by default.<h4>Labels</h4>
It's possible to link an arbitrary <em>label</em> (an unsigned integer constant) to a <code>Function</code> object. This can be useful when you want to specifically mark a <code>Function</code> temporarily; you are allowed to reassign labels and/or remove the labels again.For example,<div class="fragment"><div class="line"><span class="comment">// Add this to debug.h.</span></div>
<div class="line"><span class="keyword">enum</span> function_labels {</div>
<div class="line">  f_x,</div>
<div class="line">  f_y</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Elsewhere...</span></div>
<div class="line"><span class="keywordtype">void</span> f()</div>
<div class="line">{</div>
<div class="line">  f1.init();                                    <span class="comment">// f1 represents the current function</span></div>
<div class="line">  f1.label(f_x);                                <span class="comment">//   and assign the label f_x to it.</span></div>
<div class="line"> </div>
<div class="line">  x();</div>
<div class="line"> </div>
<div class="line">  f1.label(f_y);                                <span class="comment">// Change the label, setting it to f_y.</span></div>
<div class="line"> </div>
<div class="line">  y();</div>
<div class="line"> </div>
<div class="line">  f1.rmlabel();</div>
<div class="line">}</div>
</div><!-- fragment -->Functions x() and y() can retrieve the label set on f1, and as such find out whether this function (f1) called x() or y(). This might be needed when for example x() also calls y().<b>Important</b>: The label is not removed when you exit function f()! You'll have to explicitely do so yourself if you want to keep track of the fact that the current function exited (otherwise subsequential calls to y() could think that it still was called from f()). </div></div><!-- contents -->
<ADDRESS>Copyright &copy; 2001 - 2004 Carlo Wood.&nbsp; All rights reserved.</ADDRESS>
</DIV>
</BODY>
</HTML>
