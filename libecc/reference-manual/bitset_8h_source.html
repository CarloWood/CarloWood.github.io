<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html LANG="en_US">

<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="Author" content="Carlo Wood">
<meta name="description" content="Elliptic Curve Cryptography C++ Library">
<meta name="keywords" content="libecc, fast, elliptic curves, cryptography, fixed key size, speed, object orientation, OO, C++">
<title>libecc: Elliptic Curve Cryptography C++ Library - Reference Manual</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<script src="../scripts/detect_browser.js"></script>
<script>need_style_doxygen=1</script>
<script src="../scripts/load_style_sheets.js"></script>
</head>

<body>
<div class="normal">

<center>
<a class="qindex" href="../index.html">Main Page</a> &nbsp;
<a class="qindex" href="index.html">Reference Manual</a> &nbsp;
<a class="qindex" href="annotated.html">Compound List</a> &nbsp;
<a class="qindex" href="files.html">File List</a> &nbsp;
</center>

<hr size=1 noshade>
<!-- Generated by Doxygen 1.7.1 -->
<div class="header">
  <div class="headertitle">
<h1>libecc/bitset.h</h1>  </div>
</div>
<div class="contents">
<a href="bitset_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//</span>
<a name="l00006"></a>00006 <span class="comment"></span><span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">// This file is part of the libecc package.</span>
<a name="l00008"></a>00008 <span class="comment">// Copyright (C) 2002, by</span>
<a name="l00009"></a>00009 <span class="comment">//</span>
<a name="l00010"></a>00010 <span class="comment">// Carlo Wood, Run on IRC &lt;carlo@alinoe.com&gt;</span>
<a name="l00011"></a>00011 <span class="comment">// RSA-1024 0x624ACAD5 1997-01-26                    Sign &amp; Encrypt</span>
<a name="l00012"></a>00012 <span class="comment">// Fingerprint16 = 32 EC A7 B6 AC DB 65 A6  F6 F6 55 DD 1C DC FF 61</span>
<a name="l00013"></a>00013 <span class="comment">//</span>
<a name="l00014"></a>00014 <span class="comment">// This program is free software; you can redistribute it and/or</span>
<a name="l00015"></a>00015 <span class="comment">// modify it under the terms of the GNU General Public License</span>
<a name="l00016"></a>00016 <span class="comment">// as published by the Free Software Foundation; either version 2</span>
<a name="l00017"></a>00017 <span class="comment">// of the License, or (at your option) any later version.</span>
<a name="l00018"></a>00018 <span class="comment">//</span>
<a name="l00019"></a>00019 <span class="comment">// This program is distributed in the hope that it will be useful,</span>
<a name="l00020"></a>00020 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00021"></a>00021 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00022"></a>00022 <span class="comment">// GNU General Public License for more details.</span>
<a name="l00023"></a>00023 <span class="comment">//</span>
<a name="l00024"></a>00024 <span class="comment">// You should have received a copy of the GNU General Public License</span>
<a name="l00025"></a>00025 <span class="comment">// along with this program; if not, write to the Free Software</span>
<a name="l00026"></a>00026 <span class="comment">// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="preprocessor">#ifndef LIBECC_BITS_H</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_BITS_H</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span>
<a name="l00031"></a>00031 <span class="preprocessor">#ifndef LIBECC_DEBUG_H</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="preprocessor">#error &quot;You need to include the appropriate debug.h in the source file, before including this header file.&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;<a class="code" href="config_8h.html" title="Configuration defines.">libecc/config.h</a>&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;iosfwd&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;cstddef&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;cstring&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;inttypes.h&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;endian.h&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#ifdef CWDEBUG</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="debug_8h.html" title="Debugging declarations and defines.">debug.h</a>&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;libcwd/cwprint.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#endif</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_TRACK_EXPR_TEMPORARIES (ECC_DEBUG &amp;&amp; 1)</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">#if LIBECC_TRACK_EXPR_TEMPORARIES</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#include &lt;set&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#endif</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>
<a name="l00052"></a>00052 <span class="preprocessor">#if defined(__i386__) &amp;&amp; defined(HAVE_NASM)</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span><span class="comment">// Assembly code, defined in window.s.</span>
<a name="l00054"></a>00054 <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">int</span> libecc_shift_xorassign(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* bitset1, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keyword">const</span>* bitset2, <span class="keywordtype">int</span> lsb, <span class="keywordtype">int</span> msb, <span class="keywordtype">int</span> shift);
<a name="l00055"></a>00055 <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">int</span> libecc_shiftwindow_xorassign(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* bitset1, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keyword">const</span>* bitset2, <span class="keywordtype">int</span> lsb, <span class="keywordtype">int</span> msb, <span class="keywordtype">int</span> shift);
<a name="l00056"></a>00056 <span class="preprocessor">#endif</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span>
<a name="l00058"></a>00058 <span class="keyword">namespace</span>libecc {
<a name="l00059"></a>00059 
<a name="l00069"></a><a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d">00069</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bitset_digit_t;
<a name="l00070"></a>00070 
<a name="l00072"></a>00072 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> bitset_digit_bits = <span class="keyword">sizeof</span>(bitset_digit_t) * 8;
<a name="l00073"></a>00073 
<a name="l00075"></a>00075 <span class="preprocessor">#if ECC_BITS == 32</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> bitset_digit_bits_log2 = 5;
<a name="l00077"></a>00077 <span class="preprocessor">#elif ECC_BITS == 64</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> bitset_digit_bits_log2 = 6;
<a name="l00079"></a>00079 <span class="preprocessor">#elif ECC_BITS == 128</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span><span class="preprocessor">#warning 128 bit code has not been tested.  This warning will remain here until you mail me.</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> bitset_digit_bits_log2 = 7;
<a name="l00082"></a>00082 <span class="preprocessor">#endif</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span>
<a name="l00084"></a>00084 <span class="comment">//------------------------------------------------------------------------------------------------------------------</span>
<a name="l00085"></a>00085 <span class="comment">// Iterators</span>
<a name="l00086"></a>00086 <span class="comment">//</span>
<a name="l00087"></a>00087 
<a name="l00097"></a><a class="code" href="classlibecc_1_1bitset__index.html">00097</a> <span class="keyword">class</span><a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> {
<a name="l00098"></a>00098 <span class="preprocessor">#if defined(__i386__) || defined(LIBECC_DOXYGEN)</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span>  <span class="keyword">protected</span>:
<a name="l00100"></a><a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab">00100</a>     <span class="keywordtype">int</span> <a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a>;                        
<a name="l00101"></a>00101 
<a name="l00102"></a>00102   <span class="keyword">public</span>:
<a name="l00103"></a>00103     <span class="comment">// Accessors.</span>
<a name="l00104"></a>00104     <span class="keywordtype">int</span> <a class="code" href="classlibecc_1_1bitset__index.html#ad97d9d24247e358eb528fd82b41976df">get_index</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="preprocessor">#else</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span>  <span class="keyword">protected</span>:
<a name="l00108"></a>00108     <span class="keywordtype">int</span> M_digit;                        
<a name="l00109"></a>00109     <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> M_mask;              
<a name="l00110"></a>00110 
<a name="l00111"></a>00111   <span class="keyword">public</span>:
<a name="l00112"></a>00112     <span class="comment">// Accessors.</span>
<a name="l00113"></a>00113     <span class="keywordtype">int</span> get_digit(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00114"></a>00114     <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> get_mask(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00115"></a>00115 
<a name="l00116"></a>00116     <span class="comment">// Used in polynomial.h</span>
<a name="l00117"></a>00117     <span class="keywordtype">int</span> <a class="code" href="classlibecc_1_1bitset__index.html#ad97d9d24247e358eb528fd82b41976df">get_index</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00118"></a>00118 <span class="preprocessor">#endif</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span>
<a name="l00120"></a>00120   <span class="keyword">public</span>:
<a name="l00121"></a>00121     <span class="comment">// Equality Comparable.</span>
<a name="l00122"></a>00122     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classlibecc_1_1bitset__index.html#a5179a3e340855dbdc789d2924c23d909" title="Equality operator.">operator==</a>(<a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; i1, <a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; i2);
<a name="l00123"></a>00123     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classlibecc_1_1bitset__index.html#a2a01a735469f2afad7d00279cdc40861" title="Inequality operator.">operator!=</a>(<a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; i1, <a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; i2);
<a name="l00124"></a>00124 
<a name="l00125"></a>00125   <span class="keyword">protected</span>:
<a name="l00126"></a>00126     <span class="comment">// Bidirectional.</span>
<a name="l00127"></a>00127     <span class="keywordtype">void</span> <a class="code" href="classlibecc_1_1bitset__index.html#a79e9850f81a21048ad43631ca7341dfa" title="Move one bit left in the bitset.">left</a>(<span class="keywordtype">void</span>);
<a name="l00128"></a>00128     <span class="keywordtype">void</span> <a class="code" href="classlibecc_1_1bitset__index.html#ae366c0dd472244f875634fc67ed71d7d" title="Move one bit right in the bitset.">right</a>(<span class="keywordtype">void</span>);
<a name="l00129"></a>00129 
<a name="l00130"></a>00130     <span class="comment">// Random access.</span>
<a name="l00131"></a>00131     <span class="keywordtype">void</span> <a class="code" href="classlibecc_1_1bitset__index.html#a79e9850f81a21048ad43631ca7341dfa" title="Move one bit left in the bitset.">left</a>(<span class="keywordtype">int</span> n);
<a name="l00132"></a>00132     <span class="keywordtype">void</span> <a class="code" href="classlibecc_1_1bitset__index.html#ae366c0dd472244f875634fc67ed71d7d" title="Move one bit right in the bitset.">right</a>(<span class="keywordtype">int</span> n);
<a name="l00133"></a>00133     <span class="keyword">friend</span> <span class="keywordtype">int</span> subtract(<a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; i1, <a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; i2);
<a name="l00134"></a>00134 
<a name="l00135"></a>00135   <span class="keyword">protected</span>:
<a name="l00136"></a>00136     <span class="comment">// Constructors.</span>
<a name="l00137"></a>00137     <a class="code" href="classlibecc_1_1bitset__index.html#ae7fd53dc5d89f54edaa4c199cc67c915" title="Construct an uninitialized bitset index.">bitset_index</a>(<span class="keywordtype">void</span>);
<a name="l00138"></a>00138     <a class="code" href="classlibecc_1_1bitset__index.html#ae7fd53dc5d89f54edaa4c199cc67c915" title="Construct an uninitialized bitset index.">bitset_index</a>(<a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; index);
<a name="l00139"></a>00139     <a class="code" href="classlibecc_1_1bitset__index.html#ae7fd53dc5d89f54edaa4c199cc67c915" title="Construct an uninitialized bitset index.">bitset_index</a>(<span class="keywordtype">int</span> bit);
<a name="l00140"></a>00140 
<a name="l00141"></a>00141   <span class="keyword">public</span>:
<a name="l00142"></a>00142     <span class="keyword">friend</span> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, <a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; i);
<a name="l00143"></a>00143 };
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 <span class="preprocessor">#if defined(__i386__) || defined(LIBECC_DOXYGEN)</span>
<a name="l00146"></a>00146 <span class="preprocessor"></span>
<a name="l00150"></a>00150 <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l00151"></a><a class="code" href="classlibecc_1_1bitset__index.html#ad97d9d24247e358eb528fd82b41976df">00151</a> <a class="code" href="classlibecc_1_1bitset__index.html#ad97d9d24247e358eb528fd82b41976df">bitset_index::get_index</a>(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00152"></a>00152 <span class="keyword"></span>{
<a name="l00153"></a>00153   <span class="keywordflow">return</span> <a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a>;
<a name="l00154"></a>00154 }
<a name="l00155"></a>00155 
<a name="l00156"></a>00156 <span class="preprocessor">#else // !defined(__i386__)</span>
<a name="l00157"></a>00157 <span class="preprocessor"></span>
<a name="l00158"></a>00158 <span class="comment">// Accessor for the current digit index.</span>
<a name="l00159"></a>00159 <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l00160"></a>00160 bitset_index::get_digit(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00161"></a>00161 <span class="keyword"></span>{
<a name="l00162"></a>00162   <span class="keywordflow">return</span> M_digit;
<a name="l00163"></a>00163 }
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 <span class="comment">// Accessor for the current digit mask.</span>
<a name="l00166"></a>00166 <span class="keyword">inline</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>
<a name="l00167"></a>00167 bitset_index::get_mask(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00168"></a>00168 <span class="keyword"></span>{ 
<a name="l00169"></a>00169   <span class="keywordflow">return</span> M_mask;
<a name="l00170"></a>00170 }
<a name="l00171"></a>00171 
<a name="l00172"></a>00172 <span class="preprocessor">#include &lt;strings.h&gt;</span>   <span class="comment">// Needed for ffsl.</span>
<a name="l00173"></a>00173 <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l00174"></a>00174 <a class="code" href="classlibecc_1_1bitset__index.html#ad97d9d24247e358eb528fd82b41976df">bitset_index::get_index</a>(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00175"></a>00175 <span class="keyword"></span>{
<a name="l00176"></a>00176   <span class="keywordflow">return</span> M_digit * bitset_digit_bits + ::ffsl(M_mask) - 1;
<a name="l00177"></a>00177 }
<a name="l00178"></a>00178 
<a name="l00179"></a>00179 <span class="preprocessor">#endif // !defined(__i386__)</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span>
<a name="l00184"></a>00184 <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00185"></a><a class="code" href="namespacelibecc.html#a20e07c996961c9c66d64359e77443df4">00185</a> <a class="code" href="namespacelibecc.html#a20e07c996961c9c66d64359e77443df4" title="Equality operator.">operator==</a>(<a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; i1, <a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; i2)
<a name="l00186"></a>00186 {
<a name="l00187"></a>00187 <span class="preprocessor">#ifdef __i386__</span>
<a name="l00188"></a>00188 <span class="preprocessor"></span>  <span class="keywordflow">return</span> (i1.<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a> == i2.<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a>);
<a name="l00189"></a>00189 <span class="preprocessor">#else</span>
<a name="l00190"></a>00190 <span class="preprocessor"></span>  <span class="keywordflow">return</span> (i1.M_digit == i2.M_digit &amp;&amp; i1.M_mask == i2.M_mask);
<a name="l00191"></a>00191 <span class="preprocessor">#endif</span>
<a name="l00192"></a>00192 <span class="preprocessor"></span>}
<a name="l00193"></a>00193 
<a name="l00197"></a>00197 <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00198"></a><a class="code" href="namespacelibecc.html#ac394825c0221d5171fe495fb4cac3ef2">00198</a> <a class="code" href="namespacelibecc.html#ac394825c0221d5171fe495fb4cac3ef2" title="Inequality operator.">operator!=</a>(<a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; i1, <a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; i2)
<a name="l00199"></a>00199 {
<a name="l00200"></a>00200 <span class="preprocessor">#ifdef __i386__</span>
<a name="l00201"></a>00201 <span class="preprocessor"></span>  <span class="keywordflow">return</span> (i1.<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a> != i2.<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a>);
<a name="l00202"></a>00202 <span class="preprocessor">#else</span>
<a name="l00203"></a>00203 <span class="preprocessor"></span>  <span class="keywordflow">return</span> (i1.M_digit != i2.M_digit || i1.M_mask != i2.M_mask);
<a name="l00204"></a>00204 <span class="preprocessor">#endif</span>
<a name="l00205"></a>00205 <span class="preprocessor"></span>}
<a name="l00206"></a>00206 
<a name="l00210"></a>00210 <span class="keyword">inline</span>
<a name="l00211"></a><a class="code" href="classlibecc_1_1bitset__index.html#ae7fd53dc5d89f54edaa4c199cc67c915">00211</a> <a class="code" href="classlibecc_1_1bitset__index.html#ae7fd53dc5d89f54edaa4c199cc67c915" title="Construct an uninitialized bitset index.">bitset_index::bitset_index</a>(<span class="keywordtype">void</span>)
<a name="l00212"></a>00212 {
<a name="l00213"></a>00213 }
<a name="l00214"></a>00214 
<a name="l00218"></a>00218 <span class="keyword">inline</span>
<a name="l00219"></a><a class="code" href="classlibecc_1_1bitset__index.html#a71d3986639109cf2c0498597ee3b69e7">00219</a> <a class="code" href="classlibecc_1_1bitset__index.html#ae7fd53dc5d89f54edaa4c199cc67c915" title="Construct an uninitialized bitset index.">bitset_index::bitset_index</a>(<a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; index) :
<a name="l00220"></a>00220 #ifdef __i386__
<a name="l00221"></a>00221     M_index(index.M_index)
<a name="l00222"></a>00222 #else
<a name="l00223"></a>00223     M_digit(index.M_digit), M_mask(index.M_mask)
<a name="l00224"></a>00224 #endif
<a name="l00225"></a>00225 { 
<a name="l00226"></a>00226 }
<a name="l00227"></a>00227 
<a name="l00234"></a>00234 <span class="keyword">inline</span>
<a name="l00235"></a><a class="code" href="classlibecc_1_1bitset__index.html#a787f849d32a1da8c9649f39a7d6aefb7">00235</a> <a class="code" href="classlibecc_1_1bitset__index.html#ae7fd53dc5d89f54edaa4c199cc67c915" title="Construct an uninitialized bitset index.">bitset_index::bitset_index</a>(<span class="keywordtype">int</span> bit) :
<a name="l00236"></a>00236 #ifdef __i386__
<a name="l00237"></a>00237     M_index(bit)
<a name="l00238"></a>00238 #else
<a name="l00239"></a>00239     <span class="comment">// If bit == -1 then M_digit should become -1 and M_mask 0x80000000.</span>
<a name="l00240"></a>00240     M_digit(bit &gt;&gt; bitset_digit_bits_log2),
<a name="l00241"></a>00241     M_mask(static_cast&lt;<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>&gt;(1) &lt;&lt; ((unsigned int)bit &amp; (bitset_digit_bits - 1)))
<a name="l00242"></a>00242 #endif
<a name="l00243"></a>00243 {
<a name="l00244"></a>00244 }
<a name="l00245"></a>00245 
<a name="l00249"></a>00249 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00250"></a><a class="code" href="classlibecc_1_1bitset__index.html#a79e9850f81a21048ad43631ca7341dfa">00250</a> <a class="code" href="classlibecc_1_1bitset__index.html#a79e9850f81a21048ad43631ca7341dfa" title="Move one bit left in the bitset.">bitset_index::left</a>(<span class="keywordtype">void</span>)
<a name="l00251"></a>00251 {
<a name="l00252"></a>00252 <span class="preprocessor">#ifdef __i386__</span>
<a name="l00253"></a>00253 <span class="preprocessor"></span>  ++<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a>;
<a name="l00254"></a>00254 <span class="preprocessor">#else</span>
<a name="l00255"></a>00255 <span class="preprocessor"></span>  <span class="keywordflow">if</span> ((M_mask &lt;&lt;= 1) == 0)
<a name="l00256"></a>00256   {
<a name="l00257"></a>00257     ++M_digit;
<a name="l00258"></a>00258     M_mask = 1;
<a name="l00259"></a>00259   }
<a name="l00260"></a>00260 <span class="preprocessor">#endif</span>
<a name="l00261"></a>00261 <span class="preprocessor"></span>}
<a name="l00262"></a>00262 
<a name="l00266"></a>00266 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00267"></a><a class="code" href="classlibecc_1_1bitset__index.html#ae366c0dd472244f875634fc67ed71d7d">00267</a> <a class="code" href="classlibecc_1_1bitset__index.html#ae366c0dd472244f875634fc67ed71d7d" title="Move one bit right in the bitset.">bitset_index::right</a>(<span class="keywordtype">void</span>)
<a name="l00268"></a>00268 {
<a name="l00269"></a>00269 <span class="preprocessor">#ifdef __i386__</span>
<a name="l00270"></a>00270 <span class="preprocessor"></span>  --<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a>;
<a name="l00271"></a>00271 <span class="preprocessor">#else</span>
<a name="l00272"></a>00272 <span class="preprocessor"></span>  <span class="keywordflow">if</span> ((M_mask &gt;&gt;= 1) == 0)
<a name="l00273"></a>00273   {
<a name="l00274"></a>00274     --M_digit;
<a name="l00275"></a>00275     M_mask = <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a><span class="keyword">&gt;</span>(1) &lt;&lt; (bitset_digit_bits - 1);
<a name="l00276"></a>00276   }
<a name="l00277"></a>00277 <span class="preprocessor">#endif</span>
<a name="l00278"></a>00278 <span class="preprocessor"></span>}
<a name="l00279"></a>00279 
<a name="l00283"></a>00283 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00284"></a><a class="code" href="classlibecc_1_1bitset__index.html#afe5d3d98027ff5300e3b535db87520b6">00284</a> <a class="code" href="classlibecc_1_1bitset__index.html#a79e9850f81a21048ad43631ca7341dfa" title="Move one bit left in the bitset.">bitset_index::left</a>(<span class="keywordtype">int</span> n)
<a name="l00285"></a>00285 {
<a name="l00286"></a>00286 <span class="preprocessor">#ifdef __i386__</span>
<a name="l00287"></a>00287 <span class="preprocessor"></span>  <a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a> += n;
<a name="l00288"></a>00288 <span class="preprocessor">#else</span>
<a name="l00289"></a>00289 <span class="preprocessor"></span>  <span class="keywordtype">int</span> <span class="keyword">const</span> digit_shift = n &gt;&gt; bitset_digit_bits_log2;
<a name="l00290"></a>00290   <span class="keywordtype">int</span> <span class="keyword">const</span> mask_shift = n &amp; (bitset_digit_bits - 1);
<a name="l00291"></a>00291   M_digit += digit_shift;
<a name="l00292"></a>00292   <span class="keywordflow">if</span> (mask_shift)
<a name="l00293"></a>00293   {
<a name="l00294"></a>00294     <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> new_mask = M_mask &lt;&lt; mask_shift;
<a name="l00295"></a>00295     <span class="keywordflow">if</span> (new_mask == 0)
<a name="l00296"></a>00296     {
<a name="l00297"></a>00297       ++M_digit;
<a name="l00298"></a>00298       new_mask = M_mask &gt;&gt; (bitset_digit_bits - mask_shift);
<a name="l00299"></a>00299     }
<a name="l00300"></a>00300     M_mask = new_mask;
<a name="l00301"></a>00301   }
<a name="l00302"></a>00302 <span class="preprocessor">#endif</span>
<a name="l00303"></a>00303 <span class="preprocessor"></span>}
<a name="l00304"></a>00304 
<a name="l00308"></a>00308 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00309"></a><a class="code" href="classlibecc_1_1bitset__index.html#aa1f4134b903f1c3c2548b78c6897b05c">00309</a> <a class="code" href="classlibecc_1_1bitset__index.html#ae366c0dd472244f875634fc67ed71d7d" title="Move one bit right in the bitset.">bitset_index::right</a>(<span class="keywordtype">int</span> n)
<a name="l00310"></a>00310 {
<a name="l00311"></a>00311 <span class="preprocessor">#ifdef __i386__</span>
<a name="l00312"></a>00312 <span class="preprocessor"></span>  <a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a> -= n;
<a name="l00313"></a>00313 <span class="preprocessor">#else</span>
<a name="l00314"></a>00314 <span class="preprocessor"></span>  <span class="keywordtype">int</span> <span class="keyword">const</span> digit_shift = n &gt;&gt; bitset_digit_bits_log2;
<a name="l00315"></a>00315   <span class="keywordtype">int</span> <span class="keyword">const</span> mask_shift = n &amp; (bitset_digit_bits - 1);
<a name="l00316"></a>00316   M_digit -= digit_shift;
<a name="l00317"></a>00317   <span class="keywordflow">if</span> (mask_shift)
<a name="l00318"></a>00318   {
<a name="l00319"></a>00319     <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> new_mask = M_mask &gt;&gt; mask_shift;
<a name="l00320"></a>00320     <span class="keywordflow">if</span> (new_mask == 0)
<a name="l00321"></a>00321     {
<a name="l00322"></a>00322       --M_digit;
<a name="l00323"></a>00323       new_mask = M_mask &lt;&lt; (bitset_digit_bits - mask_shift);
<a name="l00324"></a>00324     }
<a name="l00325"></a>00325     M_mask = new_mask;
<a name="l00326"></a>00326   }
<a name="l00327"></a>00327 <span class="preprocessor">#endif</span>
<a name="l00328"></a>00328 <span class="preprocessor"></span>}
<a name="l00329"></a>00329 
<a name="l00330"></a>00330 <span class="keyword">enum</span> {
<a name="l00331"></a>00331   forwards_iterating,
<a name="l00332"></a>00332   backwards_iterating
<a name="l00333"></a>00333 };
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 <span class="comment">// Forward declarations.</span>
<a name="l00336"></a>00336 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> DIRECTION&gt; <span class="keyword">class</span>bitset_index_iterator;
<a name="l00337"></a>00337 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> DIRECTION&gt; <span class="keywordtype">bool</span> operator&lt;(bitset_index_iterator&lt;DIRECTION&gt; <span class="keyword">const</span>&amp;, bitset_index_iterator&lt;DIRECTION&gt; <span class="keyword">const</span>&amp;);
<a name="l00338"></a>00338 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> DIRECTION&gt; <span class="keywordtype">bool</span> <a class="code" href="namespacelibecc.html#ad633c82ce07ed657f0253109b6ddab2e" title="Greater.">operator&gt;</a>(bitset_index_iterator&lt;DIRECTION&gt; <span class="keyword">const</span>&amp;, bitset_index_iterator&lt;DIRECTION&gt; <span class="keyword">const</span>&amp;);
<a name="l00339"></a>00339 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> DIRECTION&gt; <span class="keywordtype">bool</span> operator&lt;=(bitset_index_iterator&lt;DIRECTION&gt; <span class="keyword">const</span>&amp;, bitset_index_iterator&lt;DIRECTION&gt; <span class="keyword">const</span>&amp;);
<a name="l00340"></a>00340 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> DIRECTION&gt; <span class="keywordtype">bool</span> <a class="code" href="namespacelibecc.html#a2a5c351ce802cec421f36c5e0dfc74a5" title="Greater or equal.">operator&gt;=</a>(bitset_index_iterator&lt;DIRECTION&gt; <span class="keyword">const</span>&amp;, bitset_index_iterator&lt;DIRECTION&gt; <span class="keyword">const</span>&amp;);
<a name="l00341"></a>00341 
<a name="l00350"></a>00350 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> DIRECTION&gt;
<a name="l00351"></a><a class="code" href="classlibecc_1_1bitset__index__iterator.html">00351</a>   <span class="keyword">class</span><a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator</a> : <span class="keyword">public</span> <a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> {
<a name="l00352"></a>00352     <span class="keyword">public</span>:
<a name="l00353"></a>00353       <span class="comment">// LessThan Comparable.</span>
<a name="l00354"></a>00354       <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator&lt; &lt;&gt;(<a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator</a> <span class="keyword">const</span>&amp; i1, <a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator</a> <span class="keyword">const</span>&amp; i2);
<a name="l00355"></a>00355       <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator&gt; &lt;&gt;(<a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator</a> <span class="keyword">const</span>&amp; i1, <a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator</a> <span class="keyword">const</span>&amp; i2);
<a name="l00356"></a>00356       <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator&lt;= &lt;&gt;(<a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator</a> <span class="keyword">const</span>&amp; i1, <a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator</a> <span class="keyword">const</span>&amp; i2);
<a name="l00357"></a>00357       <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator&gt;= &lt;&gt;(<a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator</a> <span class="keyword">const</span>&amp; i1, <a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator</a> <span class="keyword">const</span>&amp; i2);
<a name="l00358"></a>00358 
<a name="l00359"></a>00359     <span class="keyword">public</span>:
<a name="l00360"></a>00360       <span class="comment">// Bidirectional.</span>
<a name="l00361"></a>00361       <span class="keywordtype">void</span> <a class="code" href="classlibecc_1_1bitset__index__iterator.html#ac9b8e11ec8aea7cceb114c11c8f25d06" title="Advance to the next bit.">increment</a>(<span class="keywordtype">void</span>);
<a name="l00362"></a>00362       <span class="keywordtype">void</span> <a class="code" href="classlibecc_1_1bitset__index__iterator.html#a138672930b0bc541f15c946f15766b9c" title="Backup to the previous bit.">decrement</a>(<span class="keywordtype">void</span>);
<a name="l00363"></a>00363 
<a name="l00364"></a>00364       <span class="comment">// Random access.</span>
<a name="l00365"></a>00365       <span class="keywordtype">void</span> <a class="code" href="classlibecc_1_1bitset__index__iterator.html#ac9b8e11ec8aea7cceb114c11c8f25d06" title="Advance to the next bit.">increment</a>(<span class="keywordtype">int</span> n);
<a name="l00366"></a>00366       <span class="keywordtype">void</span> <a class="code" href="classlibecc_1_1bitset__index__iterator.html#a138672930b0bc541f15c946f15766b9c" title="Backup to the previous bit.">decrement</a>(<span class="keywordtype">int</span> n);
<a name="l00367"></a>00367 
<a name="l00368"></a>00368       <span class="keyword">friend</span> <span class="keywordtype">int</span> operator-(<a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; i1, <a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; i2);
<a name="l00369"></a>00369 
<a name="l00370"></a>00370     <span class="keyword">public</span>:
<a name="l00371"></a>00371       <span class="comment">// Constructors.</span>
<a name="l00372"></a>00372       <a class="code" href="classlibecc_1_1bitset__index__iterator.html#aa799bd3735af59daf6313288041b9b8a" title="Construct an uninitialized iterator bitmask.">bitset_index_iterator</a>(<span class="keywordtype">void</span>);
<a name="l00373"></a>00373       <a class="code" href="classlibecc_1_1bitset__index__iterator.html#aa799bd3735af59daf6313288041b9b8a" title="Construct an uninitialized iterator bitmask.">bitset_index_iterator</a>(<a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator</a> <span class="keyword">const</span>&amp; index);
<a name="l00374"></a>00374       <a class="code" href="classlibecc_1_1bitset__index__iterator.html#aa799bd3735af59daf6313288041b9b8a" title="Construct an uninitialized iterator bitmask.">bitset_index_iterator</a>(<span class="keywordtype">int</span> bit);
<a name="l00375"></a>00375   };
<a name="l00376"></a>00376 
<a name="l00380"></a>00380 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> DIRECTION&gt;
<a name="l00381"></a>00381   <span class="keyword">inline</span>
<a name="l00382"></a><a class="code" href="classlibecc_1_1bitset__index__iterator.html#aa799bd3735af59daf6313288041b9b8a">00382</a>   <a class="code" href="classlibecc_1_1bitset__index__iterator.html#aa799bd3735af59daf6313288041b9b8a" title="Construct an uninitialized iterator bitmask.">bitset_index_iterator&lt;DIRECTION&gt;::bitset_index_iterator</a>(<span class="keywordtype">void</span>)
<a name="l00383"></a>00383   {
<a name="l00384"></a>00384   }
<a name="l00385"></a>00385 
<a name="l00389"></a>00389 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> DIRECTION&gt;
<a name="l00390"></a>00390   <span class="keyword">inline</span>
<a name="l00391"></a><a class="code" href="classlibecc_1_1bitset__index__iterator.html#a9c9b3f0b6ef137b0cc6066b8e1837464">00391</a>   <a class="code" href="classlibecc_1_1bitset__index__iterator.html#aa799bd3735af59daf6313288041b9b8a" title="Construct an uninitialized iterator bitmask.">bitset_index_iterator&lt;DIRECTION&gt;::bitset_index_iterator</a>(<a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator&lt;DIRECTION&gt;</a> <span class="keyword">const</span>&amp; index) :
<a name="l00392"></a>00392       <a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a>(index)
<a name="l00393"></a>00393   { 
<a name="l00394"></a>00394   }
<a name="l00395"></a>00395 
<a name="l00402"></a>00402 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> DIRECTION&gt;
<a name="l00403"></a>00403   <span class="keyword">inline</span>
<a name="l00404"></a><a class="code" href="classlibecc_1_1bitset__index__iterator.html#ac6dda550f91dabd094b2611915aa184f">00404</a>   <a class="code" href="classlibecc_1_1bitset__index__iterator.html#aa799bd3735af59daf6313288041b9b8a" title="Construct an uninitialized iterator bitmask.">bitset_index_iterator&lt;DIRECTION&gt;::bitset_index_iterator</a>(<span class="keywordtype">int</span> bit) : <a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a>(bit)
<a name="l00405"></a>00405   {
<a name="l00406"></a>00406   }
<a name="l00407"></a>00407 
<a name="l00411"></a>00411 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> DIRECTION&gt;
<a name="l00412"></a>00412   <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00413"></a><a class="code" href="namespacelibecc.html#a6dd9d88ad6232a1440bf99b9a17d0999">00413</a>   operator&lt;(bitset_index_iterator&lt;DIRECTION&gt; <span class="keyword">const</span>&amp; i1, <a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator&lt;DIRECTION&gt;</a> <span class="keyword">const</span>&amp; i2)
<a name="l00414"></a>00414   {
<a name="l00415"></a>00415 <span class="preprocessor">#ifdef __i386__</span>
<a name="l00416"></a>00416 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (DIRECTION == forwards_iterating)
<a name="l00417"></a>00417       <span class="keywordflow">return</span> (i1.M_index &lt; i2.M_index);
<a name="l00418"></a>00418     <span class="keywordflow">else</span>
<a name="l00419"></a>00419       <span class="keywordflow">return</span> (i1.M_index &gt; i2.M_index);
<a name="l00420"></a>00420 <span class="preprocessor">#else</span>
<a name="l00421"></a>00421 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (DIRECTION == forwards_iterating)
<a name="l00422"></a>00422       <span class="keywordflow">return</span> (i1.M_digit &lt; i2.M_digit || (i1.M_digit == i2.M_digit &amp;&amp; i1.M_mask &lt; i2.M_mask));
<a name="l00423"></a>00423     <span class="keywordflow">else</span>
<a name="l00424"></a>00424       <span class="keywordflow">return</span> (i1.M_digit &gt; i2.M_digit || (i1.M_digit == i2.M_digit &amp;&amp; i1.M_mask &gt; i2.M_mask));
<a name="l00425"></a>00425 <span class="preprocessor">#endif</span>
<a name="l00426"></a>00426 <span class="preprocessor"></span>  }
<a name="l00427"></a>00427 
<a name="l00431"></a>00431 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> DIRECTION&gt;
<a name="l00432"></a>00432   <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00433"></a><a class="code" href="namespacelibecc.html#ad633c82ce07ed657f0253109b6ddab2e">00433</a>   <a class="code" href="namespacelibecc.html#ad633c82ce07ed657f0253109b6ddab2e" title="Greater.">operator&gt;</a>(<a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator&lt;DIRECTION&gt;</a> <span class="keyword">const</span>&amp; i1, <a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator&lt;DIRECTION&gt;</a> <span class="keyword">const</span>&amp; i2)
<a name="l00434"></a>00434   {
<a name="l00435"></a>00435 <span class="preprocessor">#ifdef __i386__</span>
<a name="l00436"></a>00436 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (DIRECTION == forwards_iterating)
<a name="l00437"></a>00437       <span class="keywordflow">return</span> (i1.<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a> &gt; i2.<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a>);
<a name="l00438"></a>00438     <span class="keywordflow">else</span>
<a name="l00439"></a>00439       <span class="keywordflow">return</span> (i1.<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a> &lt; i2.<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a>);
<a name="l00440"></a>00440 <span class="preprocessor">#else</span>
<a name="l00441"></a>00441 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (DIRECTION == forwards_iterating)
<a name="l00442"></a>00442       <span class="keywordflow">return</span> (i1.M_digit &gt; i2.M_digit || (i1.M_digit == i2.M_digit &amp;&amp; i1.M_mask &gt; i2.M_mask));
<a name="l00443"></a>00443     <span class="keywordflow">else</span>
<a name="l00444"></a>00444       <span class="keywordflow">return</span> (i1.M_digit &lt; i2.M_digit || (i1.M_digit == i2.M_digit &amp;&amp; i1.M_mask &lt; i2.M_mask));
<a name="l00445"></a>00445 <span class="preprocessor">#endif</span>
<a name="l00446"></a>00446 <span class="preprocessor"></span>  }
<a name="l00447"></a>00447 
<a name="l00451"></a>00451 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> DIRECTION&gt;
<a name="l00452"></a>00452   <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00453"></a><a class="code" href="namespacelibecc.html#a6414177ca4462dcca73a183f33872f4d">00453</a>   operator&lt;=(bitset_index_iterator&lt;DIRECTION&gt; <span class="keyword">const</span>&amp; i1, <a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator&lt;DIRECTION&gt;</a> <span class="keyword">const</span>&amp; i2)
<a name="l00454"></a>00454   {
<a name="l00455"></a>00455 <span class="preprocessor">#ifdef __i386__</span>
<a name="l00456"></a>00456 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (DIRECTION == forwards_iterating)
<a name="l00457"></a>00457       <span class="keywordflow">return</span> (i1.M_index &lt;= i2.M_index);
<a name="l00458"></a>00458     <span class="keywordflow">else</span>
<a name="l00459"></a>00459       <span class="keywordflow">return</span> (i1.M_index &gt;= i2.M_index);
<a name="l00460"></a>00460 <span class="preprocessor">#else</span>
<a name="l00461"></a>00461 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (DIRECTION == forwards_iterating)
<a name="l00462"></a>00462       <span class="keywordflow">return</span> (i1.M_digit &lt;= i2.M_digit || (i1.M_digit == i2.M_digit &amp;&amp; i1.M_mask &lt;= i2.M_mask));
<a name="l00463"></a>00463     <span class="keywordflow">else</span>
<a name="l00464"></a>00464       <span class="keywordflow">return</span> (i1.M_digit &gt;= i2.M_digit || (i1.M_digit == i2.M_digit &amp;&amp; i1.M_mask &gt;= i2.M_mask));
<a name="l00465"></a>00465 <span class="preprocessor">#endif</span>
<a name="l00466"></a>00466 <span class="preprocessor"></span>  }
<a name="l00467"></a>00467 
<a name="l00471"></a>00471 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> DIRECTION&gt;
<a name="l00472"></a>00472   <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00473"></a><a class="code" href="namespacelibecc.html#a2a5c351ce802cec421f36c5e0dfc74a5">00473</a>   <a class="code" href="namespacelibecc.html#a2a5c351ce802cec421f36c5e0dfc74a5" title="Greater or equal.">operator&gt;=</a>(<a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator&lt;DIRECTION&gt;</a> <span class="keyword">const</span>&amp; i1, <a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator&lt;DIRECTION&gt;</a> <span class="keyword">const</span>&amp; i2)
<a name="l00474"></a>00474   {
<a name="l00475"></a>00475 <span class="preprocessor">#ifdef __i386__</span>
<a name="l00476"></a>00476 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (DIRECTION == forwards_iterating)
<a name="l00477"></a>00477       <span class="keywordflow">return</span> (i1.<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a> &gt;= i2.<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a>);
<a name="l00478"></a>00478     <span class="keywordflow">else</span>
<a name="l00479"></a>00479       <span class="keywordflow">return</span> (i1.<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a> &lt;= i2.<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a>);
<a name="l00480"></a>00480 <span class="preprocessor">#else</span>
<a name="l00481"></a>00481 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (DIRECTION == forwards_iterating)
<a name="l00482"></a>00482       <span class="keywordflow">return</span> (i1.M_digit &gt;= i2.M_digit || (i1.M_digit == i2.M_digit &amp;&amp; i1.M_mask &gt;= i2.M_mask));
<a name="l00483"></a>00483     <span class="keywordflow">else</span>
<a name="l00484"></a>00484       <span class="keywordflow">return</span> (i1.M_digit &lt;= i2.M_digit || (i1.M_digit == i2.M_digit &amp;&amp; i1.M_mask &lt;= i2.M_mask));
<a name="l00485"></a>00485 <span class="preprocessor">#endif</span>
<a name="l00486"></a>00486 <span class="preprocessor"></span>  }
<a name="l00487"></a>00487 
<a name="l00491"></a>00491 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> DIRECTION&gt;
<a name="l00492"></a>00492   <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00493"></a><a class="code" href="classlibecc_1_1bitset__index__iterator.html#ac9b8e11ec8aea7cceb114c11c8f25d06">00493</a>   <a class="code" href="classlibecc_1_1bitset__index__iterator.html#ac9b8e11ec8aea7cceb114c11c8f25d06" title="Advance to the next bit.">bitset_index_iterator&lt;DIRECTION&gt;::increment</a>(<span class="keywordtype">void</span>)
<a name="l00494"></a>00494   {
<a name="l00495"></a>00495     <span class="keywordflow">if</span> (DIRECTION == forwards_iterating)
<a name="l00496"></a>00496       <a class="code" href="classlibecc_1_1bitset__index.html#a79e9850f81a21048ad43631ca7341dfa" title="Move one bit left in the bitset.">left</a>();
<a name="l00497"></a>00497     <span class="keywordflow">else</span>
<a name="l00498"></a>00498       <a class="code" href="classlibecc_1_1bitset__index.html#ae366c0dd472244f875634fc67ed71d7d" title="Move one bit right in the bitset.">right</a>();
<a name="l00499"></a>00499   }
<a name="l00500"></a>00500 
<a name="l00504"></a>00504 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> DIRECTION&gt;
<a name="l00505"></a>00505   <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00506"></a><a class="code" href="classlibecc_1_1bitset__index__iterator.html#a138672930b0bc541f15c946f15766b9c">00506</a>   <a class="code" href="classlibecc_1_1bitset__index__iterator.html#a138672930b0bc541f15c946f15766b9c" title="Backup to the previous bit.">bitset_index_iterator&lt;DIRECTION&gt;::decrement</a>(<span class="keywordtype">void</span>)
<a name="l00507"></a>00507   {
<a name="l00508"></a>00508     <span class="keywordflow">if</span> (DIRECTION == forwards_iterating)
<a name="l00509"></a>00509       <a class="code" href="classlibecc_1_1bitset__index.html#ae366c0dd472244f875634fc67ed71d7d" title="Move one bit right in the bitset.">right</a>();
<a name="l00510"></a>00510     <span class="keywordflow">else</span>
<a name="l00511"></a>00511       <a class="code" href="classlibecc_1_1bitset__index.html#a79e9850f81a21048ad43631ca7341dfa" title="Move one bit left in the bitset.">left</a>();
<a name="l00512"></a>00512   }
<a name="l00513"></a>00513 
<a name="l00517"></a>00517 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> DIRECTION&gt;
<a name="l00518"></a>00518   <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00519"></a><a class="code" href="classlibecc_1_1bitset__index__iterator.html#a856bad995d841fdbb7f065375c412b65">00519</a>   <a class="code" href="classlibecc_1_1bitset__index__iterator.html#ac9b8e11ec8aea7cceb114c11c8f25d06" title="Advance to the next bit.">bitset_index_iterator&lt;DIRECTION&gt;::increment</a>(<span class="keywordtype">int</span> n)
<a name="l00520"></a>00520   {
<a name="l00521"></a>00521     <span class="keywordflow">if</span> (DIRECTION == forwards_iterating)
<a name="l00522"></a>00522       <a class="code" href="classlibecc_1_1bitset__index.html#a79e9850f81a21048ad43631ca7341dfa" title="Move one bit left in the bitset.">left</a>(n);
<a name="l00523"></a>00523     <span class="keywordflow">else</span>
<a name="l00524"></a>00524       <a class="code" href="classlibecc_1_1bitset__index.html#ae366c0dd472244f875634fc67ed71d7d" title="Move one bit right in the bitset.">right</a>(n);
<a name="l00525"></a>00525   }
<a name="l00526"></a>00526 
<a name="l00530"></a>00530 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> DIRECTION&gt;
<a name="l00531"></a>00531   <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00532"></a><a class="code" href="classlibecc_1_1bitset__index__iterator.html#a3fb400c40af027b4a105e36e8f4d9569">00532</a>   <a class="code" href="classlibecc_1_1bitset__index__iterator.html#a138672930b0bc541f15c946f15766b9c" title="Backup to the previous bit.">bitset_index_iterator&lt;DIRECTION&gt;::decrement</a>(<span class="keywordtype">int</span> n)
<a name="l00533"></a>00533   {
<a name="l00534"></a>00534     <span class="keywordflow">if</span> (DIRECTION == forwards_iterating)
<a name="l00535"></a>00535       <a class="code" href="classlibecc_1_1bitset__index.html#ae366c0dd472244f875634fc67ed71d7d" title="Move one bit right in the bitset.">right</a>(n);
<a name="l00536"></a>00536     <span class="keywordflow">else</span>
<a name="l00537"></a>00537       <a class="code" href="classlibecc_1_1bitset__index.html#a79e9850f81a21048ad43631ca7341dfa" title="Move one bit left in the bitset.">left</a>(n);
<a name="l00538"></a>00538   }
<a name="l00539"></a>00539 
<a name="l00540"></a>00540 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> DIRECTION&gt;
<a name="l00541"></a>00541   <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l00542"></a>00542   operator-(<a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator&lt;DIRECTION&gt;</a> <span class="keyword">const</span>&amp; i1, <a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator&lt;DIRECTION&gt;</a> <span class="keyword">const</span>&amp; i2)
<a name="l00543"></a>00543   {
<a name="l00544"></a>00544     <span class="keywordflow">return</span> (DIRECTION == forwards_iterating) ? subtract(i1, i2) : subtract(i2, i1);
<a name="l00545"></a>00545   }
<a name="l00546"></a>00546 
<a name="l00547"></a>00547 <span class="comment">// Forward declarations.</span>
<a name="l00548"></a>00548 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt; <span class="keyword">class</span>bitset_iterator;
<a name="l00549"></a>00549 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt; bitset_iterator&lt;N, DIRECTION&gt; <a class="code" href="namespacelibecc.html#a36b6c0536e6dc391140e676cb2315c53" title="Iterator addition.">operator+</a>(bitset_iterator&lt;N, DIRECTION&gt; <span class="keyword">const</span>&amp;, <span class="keywordtype">int</span>);
<a name="l00550"></a>00550 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt; bitset_iterator&lt;N, DIRECTION&gt; <a class="code" href="namespacelibecc.html#a36b6c0536e6dc391140e676cb2315c53" title="Iterator addition.">operator+</a>(<span class="keywordtype">int</span>, bitset_iterator&lt;N, DIRECTION&gt; <span class="keyword">const</span>&amp;);
<a name="l00551"></a>00551 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt; bitset_iterator&lt;N, DIRECTION&gt; operator-(bitset_iterator&lt;N, DIRECTION&gt; <span class="keyword">const</span>&amp;, <span class="keywordtype">int</span>);
<a name="l00552"></a>00552 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt; bitset_iterator&lt;N, DIRECTION&gt; operator-(<span class="keywordtype">int</span>, bitset_iterator&lt;N, DIRECTION&gt; <span class="keyword">const</span>&amp;);
<a name="l00553"></a>00553 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt; <span class="keyword">struct</span>bitset_base;
<a name="l00554"></a>00554 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">bool</span> inverted&gt; <span class="keyword">class</span>bitset_invertible;
<a name="l00555"></a>00555 
<a name="l00565"></a>00565 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l00566"></a><a class="code" href="classlibecc_1_1bitset__iterator.html">00566</a>   <span class="keyword">class</span><a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a> : <span class="keyword">public</span> <a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator</a>&lt;DIRECTION&gt;,
<a name="l00567"></a>00567                           <span class="keyword">public</span> std::iterator&lt;std::random_access_iterator_tag, bitset_digit_t,
<a name="l00568"></a>00568                                                int, bitset_digit_t*, bitset_digit_t&amp;&gt; {
<a name="l00569"></a>00569     <span class="keyword">protected</span>:
<a name="l00570"></a>00570       <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;</a> <span class="keyword">const</span>* M_bitset_ptr;
<a name="l00571"></a>00571 
<a name="l00572"></a>00572     <span class="keyword">public</span>:
<a name="l00573"></a>00573       <span class="comment">// Default Constructible</span>
<a name="l00574"></a>00574       <a class="code" href="classlibecc_1_1bitset__iterator.html#a97ac4cb1546799266c1daa2dfd8485be" title="Construct uninitialized bitset iterator.">bitset_iterator</a>(<span class="keywordtype">void</span>);
<a name="l00575"></a>00575 
<a name="l00576"></a>00576       <span class="comment">// Assignable</span>
<a name="l00577"></a>00577       <a class="code" href="classlibecc_1_1bitset__iterator.html#a97ac4cb1546799266c1daa2dfd8485be" title="Construct uninitialized bitset iterator.">bitset_iterator</a>(<a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a> <span class="keyword">const</span>&amp; iter);
<a name="l00578"></a>00578       <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a>&amp; <a class="code" href="classlibecc_1_1bitset__iterator.html#accae9dfd64443671078b59da557796cd" title="Assignment operator.">operator=</a>(<a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a> <span class="keyword">const</span>&amp; iter);
<a name="l00579"></a>00579       <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a>&amp; <a class="code" href="classlibecc_1_1bitset__iterator.html#accae9dfd64443671078b59da557796cd" title="Assignment operator.">operator=</a>(<a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator&lt;DIRECTION&gt;</a> <span class="keyword">const</span>&amp; index);
<a name="l00580"></a>00580 
<a name="l00581"></a>00581       <span class="comment">// Dereferencable</span>
<a name="l00582"></a>00582       <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <a class="code" href="classlibecc_1_1bitset__iterator.html#ab4bdc12c0463536e7a56b93d4d7a68e3" title="Access bit as zero or bitmask.">operator*</a>() <span class="keyword">const</span>;
<a name="l00583"></a>00583 
<a name="l00584"></a>00584       <span class="comment">// Bi-directional iterator</span>
<a name="l00585"></a>00585       <span class="comment">//</span>
<a name="l00586"></a>00586       <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a>&amp; <a class="code" href="classlibecc_1_1bitset__iterator.html#a18a2223300db3bb6a5055d8034e6f0c6" title="Preincrement.">operator++</a>();
<a name="l00587"></a>00587       <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a> <a class="code" href="classlibecc_1_1bitset__iterator.html#a18a2223300db3bb6a5055d8034e6f0c6" title="Preincrement.">operator++</a>(<span class="keywordtype">int</span>);
<a name="l00588"></a>00588       <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a>&amp; <a class="code" href="classlibecc_1_1bitset__iterator.html#a60249dc7d3d1a0082f6231a16d6a6bff" title="Predecrement.">operator--</a>();
<a name="l00589"></a>00589       <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a> <a class="code" href="classlibecc_1_1bitset__iterator.html#a60249dc7d3d1a0082f6231a16d6a6bff" title="Predecrement.">operator--</a>(<span class="keywordtype">int</span>);
<a name="l00590"></a>00590 
<a name="l00591"></a>00591       <span class="comment">// Random Access Iterator</span>
<a name="l00592"></a>00592       <span class="comment">//</span>
<a name="l00593"></a>00593       <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a>&amp; <a class="code" href="classlibecc_1_1bitset__iterator.html#ae1b6d3839ba058aca1abb054a6f74a51" title="Iterator addition.">operator+=</a>(<span class="keywordtype">int</span> n);
<a name="l00594"></a>00594       <span class="keyword">friend</span> <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a> operator+ &lt;&gt;(<a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a> <span class="keyword">const</span>&amp; i, <span class="keywordtype">int</span> n);
<a name="l00595"></a>00595       <span class="keyword">friend</span> <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a> operator+ &lt;&gt;(<span class="keywordtype">int</span> n, <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a> <span class="keyword">const</span>&amp; i);
<a name="l00596"></a>00596       <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a>&amp; <a class="code" href="classlibecc_1_1bitset__iterator.html#a1481955d27fbffb3996fc0d5f7652f2e" title="Iterator subtraction.">operator-=</a>(<span class="keywordtype">int</span> n);
<a name="l00597"></a>00597       <span class="keyword">friend</span> <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a> operator- &lt;&gt;(<a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a> <span class="keyword">const</span>&amp; i, <span class="keywordtype">int</span> n);
<a name="l00598"></a>00598       <span class="keyword">friend</span> <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a> operator- &lt;&gt;(<span class="keywordtype">int</span> n, <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a> <span class="keyword">const</span>&amp; i);
<a name="l00599"></a>00599       <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <a class="code" href="classlibecc_1_1bitset__iterator.html#aff852c4c0c478965f8e3624431d3a529" title="Element operator.">operator[]</a>(<span class="keywordtype">int</span> n) <span class="keyword">const</span>;
<a name="l00600"></a>00600 
<a name="l00601"></a>00601       <span class="comment">// Special</span>
<a name="l00602"></a>00602       <span class="comment">//</span>
<a name="l00603"></a>00603       <a class="code" href="classlibecc_1_1bitset__iterator.html#a97ac4cb1546799266c1daa2dfd8485be" title="Construct uninitialized bitset iterator.">bitset_iterator</a>(<a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;</a> <span class="keyword">const</span>* bitset_ptr, <span class="keywordtype">int</span> bit);
<a name="l00604"></a>00604       <span class="keywordtype">void</span> <a class="code" href="classlibecc_1_1bitset__iterator.html#a4b9b09473c5be7f70fd972f62bf72887" title="Return the first position for which the bit is set.">find1</a>(<span class="keywordtype">void</span>);
<a name="l00605"></a>00605 
<a name="l00606"></a>00606 <span class="preprocessor">#ifndef __i386__</span>
<a name="l00607"></a>00607 <span class="preprocessor"></span>    <span class="keyword">private</span>:
<a name="l00608"></a>00608       <span class="keywordtype">void</span> find1_forward(<span class="keywordtype">void</span>);
<a name="l00609"></a>00609       <span class="keywordtype">void</span> find1_backward(<span class="keywordtype">void</span>);
<a name="l00610"></a>00610 <span class="preprocessor">#endif</span>
<a name="l00611"></a>00611 <span class="preprocessor"></span>  };
<a name="l00612"></a>00612 
<a name="l00622"></a>00622 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l00623"></a><a class="code" href="structlibecc_1_1bitset__base.html">00623</a>   <span class="keyword">struct</span><a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base</a> {
<a name="l00624"></a>00624     <span class="keyword">public</span>:
<a name="l00625"></a>00625       <span class="comment">// Fix this if you add members in front of vector.</span>
<a name="l00626"></a>00626       <span class="keyword">static</span> <span class="keywordtype">size_t</span> <span class="keyword">const</span> offsetof_vector = 0; <span class="comment">//sizeof(bitset_digit_t);</span>
<a name="l00627"></a>00627 
<a name="l00628"></a>00628     <span class="keyword">public</span>:
<a name="l00632"></a><a class="code" href="structlibecc_1_1bitset__base.html#ae1949a3688cffc314c5db855b6ea86a4">00632</a>       <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> <a class="code" href="structlibecc_1_1bitset__base.html#ae1949a3688cffc314c5db855b6ea86a4" title="The number of bits in the bitset.">number_of_bits</a> = N;
<a name="l00633"></a>00633 
<a name="l00635"></a><a class="code" href="structlibecc_1_1bitset__base.html#a70219fdf047ad3dcd08b3332c6ff843a">00635</a>       <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> <a class="code" href="structlibecc_1_1bitset__base.html#a70219fdf047ad3dcd08b3332c6ff843a" title="The minimum number of digits needed to store N bits.">digits</a> = (N == 0) ? 0 : ((N - 1) / bitset_digit_bits + 1);
<a name="l00636"></a>00636 
<a name="l00637"></a>00637       <span class="comment">// ! The number of valid bits in the most significant digit.</span>
<a name="l00638"></a>00638       <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> number_of_valid_bits = bitset_digit_bits - (<a class="code" href="structlibecc_1_1bitset__base.html#a70219fdf047ad3dcd08b3332c6ff843a" title="The minimum number of digits needed to store N bits.">digits</a> * bitset_digit_bits - N);
<a name="l00639"></a>00639 
<a name="l00641"></a><a class="code" href="structlibecc_1_1bitset__base.html#a0277a1dc4424a320a2125df0232fb70e">00641</a>       <span class="keyword">static</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <span class="keyword">const</span> <a class="code" href="structlibecc_1_1bitset__base.html#a0277a1dc4424a320a2125df0232fb70e" title="A mask marking the valid bits in the most significant digit.">valid_bits</a> = ((<span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a><span class="keyword">&gt;</span>(1) &lt;&lt; (number_of_valid_bits - 1)) &lt;&lt; 1) - 1;
<a name="l00642"></a>00642 
<a name="l00644"></a><a class="code" href="structlibecc_1_1bitset__base.html#af50573b231d7ef059a0b38fddfb7277e">00644</a>       <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> <a class="code" href="structlibecc_1_1bitset__base.html#af50573b231d7ef059a0b38fddfb7277e" title="True when not all bits in the most significant digit are valid.">has_excess_bits</a> = ((<a class="code" href="structlibecc_1_1bitset__base.html#a70219fdf047ad3dcd08b3332c6ff843a" title="The minimum number of digits needed to store N bits.">digits</a> * bitset_digit_bits) != N);
<a name="l00645"></a>00645 
<a name="l00646"></a>00646     <span class="keyword">protected</span>:
<a name="l00653"></a>00653       <span class="comment">//bitset_digit_t empty_space1;</span>
<a name="l00654"></a><a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e">00654</a>       <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[<a class="code" href="structlibecc_1_1bitset__base.html#a70219fdf047ad3dcd08b3332c6ff843a" title="The minimum number of digits needed to store N bits.">digits</a>];
<a name="l00655"></a>00655       <span class="comment">//bitset_digit_t empty_space2;</span>
<a name="l00656"></a>00656 
<a name="l00657"></a>00657       <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n1, <span class="keywordtype">bool</span> i1, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n2, <span class="keywordtype">bool</span> i2&gt;
<a name="l00658"></a>00658         <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==(<a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;n1, i1&gt;</a> <span class="keyword">const</span>&amp;, <a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;n2, i2&gt;</a> <span class="keyword">const</span>&amp;);
<a name="l00659"></a>00659 
<a name="l00660"></a>00660       <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n1, <span class="keywordtype">bool</span> i1, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n2, <span class="keywordtype">bool</span> i2&gt;
<a name="l00661"></a>00661         <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator!=(<a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;n1, i1&gt;</a> <span class="keyword">const</span>&amp;, <a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;n2, i2&gt;</a> <span class="keyword">const</span>&amp;);
<a name="l00662"></a>00662 
<a name="l00663"></a>00663     <span class="keyword">public</span>:
<a name="l00664"></a>00664       <span class="comment">// Digit representation</span>
<a name="l00665"></a>00665       <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>&amp; rawdigit(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d) { <span class="keywordflow">return</span> this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d]; }
<a name="l00666"></a>00666       <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> rawdigit(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d)<span class="keyword"> const</span>{ <span class="keywordflow">return</span> this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d]; }
<a name="l00667"></a>00667       <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>* digits_ptr(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>; }
<a name="l00668"></a>00668       <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <span class="keyword">const</span>* digits_ptr(<span class="keywordtype">void</span>)<span class="keyword"> const</span>{ <span class="keywordflow">return</span> this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>; }
<a name="l00669"></a>00669       uint32_t digit32(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d32)<span class="keyword"> const</span>
<a name="l00670"></a>00670 <span class="keyword">     </span>{
<a name="l00671"></a>00671         <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>) == 4)
<a name="l00672"></a>00672           <span class="keywordflow">return</span> this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d32];
<a name="l00673"></a>00673         <span class="keywordflow">else</span>
<a name="l00674"></a>00674         {
<a name="l00675"></a>00675           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = d32 / (<span class="keyword">sizeof</span>(bitset_digit_t) / 4);
<a name="l00676"></a>00676           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r = d32 % (<span class="keyword">sizeof</span>(bitset_digit_t) / 4);
<a name="l00677"></a>00677 <span class="preprocessor">#if __BYTE_ORDER == __LITTLE_ENDIAN</span>
<a name="l00678"></a>00678 <span class="preprocessor"></span>          <span class="keywordflow">return</span> (this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d] &gt;&gt; (r * 32));
<a name="l00679"></a>00679 <span class="preprocessor">#elif __BYTE_ORDER == __BIG_ENDIAN</span>
<a name="l00680"></a>00680 <span class="preprocessor"></span>          <span class="keywordflow">return</span> (this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d] &gt;&gt; (bitset_digit_bits - 32 - (r * 32)));
<a name="l00681"></a>00681 <span class="preprocessor">#endif</span>
<a name="l00682"></a>00682 <span class="preprocessor"></span>        }
<a name="l00683"></a>00683       }
<a name="l00684"></a>00684 
<a name="l00685"></a>00685     <span class="keyword">public</span>:
<a name="l00686"></a>00686       <span class="comment">// Iterator stuff.</span>
<a name="l00688"></a><a class="code" href="structlibecc_1_1bitset__base.html#a3306f60b23bc38be15377647583a707c">00688</a> <span class="comment"></span>      <span class="keyword">typedef</span> <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, forwards_iterating&gt;</a> <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">const_iterator</a>;
<a name="l00690"></a><a class="code" href="structlibecc_1_1bitset__base.html#a5f39f2f1e89241d2243ed5e3b1a22f14">00690</a>       <span class="keyword">typedef</span> <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, backwards_iterating&gt;</a> <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">const_reverse_iterator</a>;
<a name="l00692"></a><a class="code" href="structlibecc_1_1bitset__base.html#aaab8909d92a318e62c3f372221457fa3">00692</a>       <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">const_iterator</a> <a class="code" href="structlibecc_1_1bitset__base.html#aaab8909d92a318e62c3f372221457fa3" title="Return an iterator to the first bit.">begin</a>(<span class="keywordtype">void</span>)<span class="keyword"> const</span>{ <span class="keywordflow">return</span> <a class="code" href="structlibecc_1_1bitset__base.html#a3306f60b23bc38be15377647583a707c" title="Non-mutable iterator.">const_iterator</a>(<span class="keyword">this</span>, 0); }
<a name="l00694"></a><a class="code" href="structlibecc_1_1bitset__base.html#a02e747ee68ea39329a8023c52b2de1e3">00694</a>       <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">const_iterator</a> <a class="code" href="structlibecc_1_1bitset__base.html#a02e747ee68ea39329a8023c52b2de1e3" title="Return an iterator one past the last bit.">end</a>(<span class="keywordtype">void</span>)<span class="keyword"> const</span>{ <span class="keywordflow">return</span> <a class="code" href="structlibecc_1_1bitset__base.html#a3306f60b23bc38be15377647583a707c" title="Non-mutable iterator.">const_iterator</a>(<span class="keyword">this</span>, N); }
<a name="l00696"></a><a class="code" href="structlibecc_1_1bitset__base.html#a4a8b1ec5cd0e596877f8613f2644a869">00696</a>       <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">const_reverse_iterator</a> <a class="code" href="structlibecc_1_1bitset__base.html#a4a8b1ec5cd0e596877f8613f2644a869" title="Return a reverse iterator to bit N-1.">rbegin</a>(<span class="keywordtype">void</span>)<span class="keyword"> const</span>{ <span class="keywordflow">return</span> <a class="code" href="structlibecc_1_1bitset__base.html#a5f39f2f1e89241d2243ed5e3b1a22f14" title="Reverse non-mutable iterator.">const_reverse_iterator</a>(<span class="keyword">this</span>, N - 1); }
<a name="l00698"></a><a class="code" href="structlibecc_1_1bitset__base.html#a7e78eee6d318980bb8a1b1b3a7fc6b9f">00698</a>       <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">const_reverse_iterator</a> <a class="code" href="structlibecc_1_1bitset__base.html#a7e78eee6d318980bb8a1b1b3a7fc6b9f" title="Return a reverse iterator one before the first bit.">rend</a>(<span class="keywordtype">void</span>)<span class="keyword"> const</span>{ <span class="keywordflow">return</span> <a class="code" href="structlibecc_1_1bitset__base.html#a5f39f2f1e89241d2243ed5e3b1a22f14" title="Reverse non-mutable iterator.">const_reverse_iterator</a>(<span class="keyword">this</span>, -1); }
<a name="l00699"></a>00699 
<a name="l00700"></a>00700       <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m&gt;
<a name="l00701"></a>00701         <span class="keywordtype">void</span> <a class="code" href="structlibecc_1_1bitset__base.html#a327ea5e576b58dc6154179c40d030983" title="Shift bitset left or right and XOR with this bitset.">xor_with_zero_padded</a>(<a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;m&gt;</a> <span class="keyword">const</span>&amp; <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset</a>, <span class="keywordtype">int</span> lsb, <span class="keywordtype">int</span> msb, <span class="keywordtype">int</span> shift);
<a name="l00702"></a>00702 
<a name="l00703"></a>00703       <span class="comment">// Slower functions for shifting an arbitrary distance.</span>
<a name="l00704"></a>00704       <span class="keywordtype">void</span> operator&lt;&lt;=(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shift);
<a name="l00705"></a>00705       <span class="keywordtype">void</span> operator&gt;&gt;=(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shift);
<a name="l00706"></a>00706 
<a name="l00707"></a>00707       <span class="comment">// Single bit operations</span>
<a name="l00708"></a>00708       <span class="keywordtype">bool</span> <a class="code" href="structlibecc_1_1bitset__base.html#a01a13f277f84abee29e8af9c0ac9d6ad" title="Test a bit at a fixed position.">test</a>(<span class="keywordtype">size_t</span> n) <span class="keyword">const</span>;                                        <span class="comment">// Return true if bit `n&#39; is set.</span>
<a name="l00709"></a>00709       <span class="keywordtype">bool</span> <a class="code" href="structlibecc_1_1bitset__base.html#afb0f9064c525944efa025eb309ec473c" title="Returns true when the bitset contains an odd number of bits.">odd</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;                                             <span class="comment">// Return true if the vector has an odd number of bits set.</span>
<a name="l00710"></a>00710       <span class="keywordtype">void</span> <span class="keyword">set</span>(<span class="keywordtype">size_t</span> n);                                               <span class="comment">// Set bit `n&#39;.</span>
<a name="l00711"></a>00711       <span class="keywordtype">void</span> <a class="code" href="structlibecc_1_1bitset__base.html#ac2f5e92ab953a43c76ca664b23add1cf" title="Clear a bit at a fixed position.">clear</a>(<span class="keywordtype">size_t</span> n);                                             <span class="comment">// Clear bit `n&#39;.</span>
<a name="l00712"></a>00712       <span class="keywordtype">void</span> <a class="code" href="structlibecc_1_1bitset__base.html#a2c449fc9ce728be63620635f5acb39ce" title="Toggle a bit at a fixed position.">flip</a>(<span class="keywordtype">size_t</span> n);                                              <span class="comment">// Toggle bit `n&#39;.</span>
<a name="l00713"></a>00713 
<a name="l00714"></a>00714       <span class="comment">// Single bit operations using iterators.</span>
<a name="l00715"></a>00715       <span class="keywordtype">bool</span> <a class="code" href="structlibecc_1_1bitset__base.html#a01a13f277f84abee29e8af9c0ac9d6ad" title="Test a bit at a fixed position.">test</a>(<a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; index) <span class="keyword">const</span>;                       <span class="comment">// Return true if bit refered to by `index&#39; is set.</span>
<a name="l00716"></a>00716       <span class="keywordtype">void</span> <span class="keyword">set</span>(<a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; index);                              <span class="comment">// Set bit refered to by `index&#39;.</span>
<a name="l00717"></a>00717       <span class="keywordtype">void</span> <a class="code" href="structlibecc_1_1bitset__base.html#ac2f5e92ab953a43c76ca664b23add1cf" title="Clear a bit at a fixed position.">clear</a>(<a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; index);                            <span class="comment">// Clear bit refered to by `index&#39;.</span>
<a name="l00718"></a>00718       <span class="keywordtype">void</span> <a class="code" href="structlibecc_1_1bitset__base.html#a2c449fc9ce728be63620635f5acb39ce" title="Toggle a bit at a fixed position.">flip</a>(<a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; index);                             <span class="comment">// Toggle bit refered to by `index&#39;.</span>
<a name="l00719"></a>00719 
<a name="l00720"></a>00720       <span class="comment">// Single bit operations at a constant position</span>
<a name="l00721"></a>00721       <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos&gt;
<a name="l00722"></a>00722         <span class="keywordtype">bool</span> <a class="code" href="structlibecc_1_1bitset__base.html#a01a13f277f84abee29e8af9c0ac9d6ad" title="Test a bit at a fixed position.">test</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;                                          <span class="comment">// Return true if bit `pos&#39; is set.</span>
<a name="l00723"></a>00723       <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos&gt;
<a name="l00724"></a>00724         <span class="keywordtype">void</span> <span class="keyword">set</span>(void);                                                 <span class="comment">// Set bit `pos&#39;.</span>
<a name="l00725"></a>00725       <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos&gt;
<a name="l00726"></a>00726         <span class="keywordtype">void</span> <a class="code" href="structlibecc_1_1bitset__base.html#ac2f5e92ab953a43c76ca664b23add1cf" title="Clear a bit at a fixed position.">clear</a>(<span class="keywordtype">void</span>);                                               <span class="comment">// Clear bit `pos&#39;.</span>
<a name="l00727"></a>00727       <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos&gt;
<a name="l00728"></a>00728         <span class="keywordtype">void</span> <a class="code" href="structlibecc_1_1bitset__base.html#a2c449fc9ce728be63620635f5acb39ce" title="Toggle a bit at a fixed position.">flip</a>(<span class="keywordtype">void</span>);                                                <span class="comment">// Toggle bit `pos&#39;.</span>
<a name="l00729"></a>00729 
<a name="l00730"></a>00730       <span class="comment">// Other functions</span>
<a name="l00731"></a>00731       <span class="keywordtype">void</span> <a class="code" href="structlibecc_1_1bitset__base.html#a546fff5ea210a08046d3429642bd0cf4" title="Reset all bits to 0.">reset</a>(<span class="keywordtype">void</span>);
<a name="l00732"></a>00732       <span class="keywordtype">void</span> <a class="code" href="structlibecc_1_1bitset__base.html#af61ddb78b0980f28e6262160f88bf38e" title="Set all bits to 1.">setall</a>(<span class="keywordtype">void</span>);
<a name="l00733"></a>00733       <span class="keywordtype">bool</span> <a class="code" href="structlibecc_1_1bitset__base.html#a27238b6dcce248896546f144b5500f7b" title="Return true if any bit is set.">any</a>(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00734"></a>00734   };
<a name="l00735"></a>00735 
<a name="l00752"></a>00752 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l00753"></a>00753   <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m&gt;
<a name="l00754"></a>00754 <span class="preprocessor">#if defined(__i386__) &amp;&amp; defined(HAVE_NASM)</span>
<a name="l00755"></a>00755 <span class="preprocessor"></span>  <span class="keyword">inline</span>
<a name="l00756"></a>00756 <span class="preprocessor">#endif</span>
<a name="l00757"></a>00757 <span class="preprocessor"></span>  <span class="keywordtype">void</span>
<a name="l00758"></a><a class="code" href="structlibecc_1_1bitset__base.html#a327ea5e576b58dc6154179c40d030983">00758</a>   <a class="code" href="structlibecc_1_1bitset__base.html#a327ea5e576b58dc6154179c40d030983" title="Shift bitset left or right and XOR with this bitset.">bitset_base&lt;N&gt;::xor_with_zero_padded</a>(<a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;m&gt;</a> <span class="keyword">const</span>&amp; <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset</a>, <span class="keywordtype">int</span> lsb, <span class="keywordtype">int</span> msb, <span class="keywordtype">int</span> shift)
<a name="l00759"></a>00759   {
<a name="l00760"></a>00760 <span class="preprocessor">#if defined(__i386__) &amp;&amp; defined(HAVE_NASM)</span>
<a name="l00761"></a>00761 <span class="preprocessor"></span>    libecc_shift_xorassign(this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>, bitset.digits_ptr(), lsb, msb, shift);
<a name="l00762"></a>00762 <span class="preprocessor">#else</span>
<a name="l00763"></a>00763 <span class="preprocessor"></span>    <span class="keywordtype">int</span> digit1 = lsb &gt;&gt; bitset_digit_bits_log2;
<a name="l00764"></a>00764     <span class="keywordtype">int</span> digit2 = msb &gt;&gt; bitset_digit_bits_log2;
<a name="l00765"></a>00765     <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> d1 = 0;
<a name="l00766"></a>00766     <span class="comment">// We can&#39;t use bitset.digit() because we need access to negative indexes.</span>
<a name="l00767"></a>00767     <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <span class="keyword">const</span>* <span class="keyword">const</span> digits_ptr = bitset.digits_ptr();
<a name="l00768"></a>00768     <span class="keywordflow">if</span> (shift &lt; 0)
<a name="l00769"></a>00769     {
<a name="l00770"></a>00770       <span class="keywordtype">int</span> bitshift = (-shift) &amp; (bitset_digit_bits - 1);
<a name="l00771"></a>00771       <span class="keywordtype">int</span> digitshift = (-shift) &gt;&gt; bitset_digit_bits_log2;
<a name="l00772"></a>00772       <span class="keywordflow">if</span> (bitshift == 0)
<a name="l00773"></a>00773       {
<a name="l00774"></a>00774         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> digit = digit2; digit &gt;= digit1; --digit)
<a name="l00775"></a>00775         {
<a name="l00776"></a>00776           <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> d2 = digits_ptr[digit];
<a name="l00777"></a>00777           this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[digit - digitshift] ^= d2;
<a name="l00778"></a>00778         }
<a name="l00779"></a>00779       }
<a name="l00780"></a>00780       <span class="keywordflow">else</span>
<a name="l00781"></a>00781       {
<a name="l00782"></a>00782         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> digit = digit2; digit &gt;= digit1; --digit)
<a name="l00783"></a>00783         {
<a name="l00784"></a>00784           <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> d2 = digits_ptr[digit];
<a name="l00785"></a>00785           this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[digit - digitshift] ^= (d2 &gt;&gt; bitshift) | (d1 &lt;&lt; (bitset_digit_bits - bitshift));
<a name="l00786"></a>00786           d1 = d2;
<a name="l00787"></a>00787         }
<a name="l00788"></a>00788         this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[digit1 - 1 - digitshift] ^= (d1 &lt;&lt; (bitset_digit_bits - bitshift));
<a name="l00789"></a>00789       }
<a name="l00790"></a>00790     }
<a name="l00791"></a>00791     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shift &gt; 0)
<a name="l00792"></a>00792     {
<a name="l00793"></a>00793       <span class="keywordtype">int</span> bitshift = shift &amp; (bitset_digit_bits - 1);
<a name="l00794"></a>00794       <span class="keywordtype">int</span> digitshift = shift &gt;&gt; bitset_digit_bits_log2;
<a name="l00795"></a>00795       <span class="keywordflow">if</span> (bitshift == 0)
<a name="l00796"></a>00796       {
<a name="l00797"></a>00797         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> digit = digit1; digit &lt;= digit2; ++digit)
<a name="l00798"></a>00798         {
<a name="l00799"></a>00799           <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> d2 = digits_ptr[digit];
<a name="l00800"></a>00800           this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[digit + digitshift] ^= d2;
<a name="l00801"></a>00801           d1 = d2;
<a name="l00802"></a>00802         }
<a name="l00803"></a>00803       }
<a name="l00804"></a>00804       <span class="keywordflow">else</span>
<a name="l00805"></a>00805       {
<a name="l00806"></a>00806         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> digit = digit1; digit &lt;= digit2; ++digit)
<a name="l00807"></a>00807         {
<a name="l00808"></a>00808           <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> d2 = digits_ptr[digit];
<a name="l00809"></a>00809           this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[digit + digitshift] ^= (d2 &lt;&lt; bitshift) | (d1 &gt;&gt; (bitset_digit_bits - bitshift));
<a name="l00810"></a>00810           d1 = d2;
<a name="l00811"></a>00811         }
<a name="l00812"></a>00812         this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[digit2 + 1 + digitshift] ^= (d1 &gt;&gt; (bitset_digit_bits - bitshift));
<a name="l00813"></a>00813       }
<a name="l00814"></a>00814     }
<a name="l00815"></a>00815     <span class="keywordflow">else</span>
<a name="l00816"></a>00816     {
<a name="l00817"></a>00817       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> digit = digit1; digit &lt;= digit2; ++digit)
<a name="l00818"></a>00818         this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[digit] ^= digits_ptr[digit];
<a name="l00819"></a>00819     }
<a name="l00820"></a>00820 <span class="preprocessor">#endif</span>
<a name="l00821"></a>00821 <span class="preprocessor"></span>  }
<a name="l00822"></a>00822 
<a name="l00823"></a>00823 <span class="preprocessor">#ifndef HIDE_FROM_DOXYGEN</span>
<a name="l00824"></a>00824 <span class="preprocessor"></span><span class="keyword">namespace</span>Operator {
<a name="l00825"></a>00825 
<a name="l00826"></a>00826 <span class="preprocessor">#ifdef __i386__</span>
<a name="l00827"></a>00827 <span class="preprocessor"></span>
<a name="l00828"></a>00828 <span class="comment">//</span>
<a name="l00829"></a>00829 <span class="comment">// Due to heavily broken inlining heuristics of gcc,</span>
<a name="l00830"></a>00830 <span class="comment">// we are forced to use macros to do the assembly</span>
<a name="l00831"></a>00831 <span class="comment">// inlining.  There is no alternative, I tried everything.</span>
<a name="l00832"></a>00832 <span class="comment">//</span>
<a name="l00833"></a>00833 
<a name="l00834"></a>00834 <span class="preprocessor">#define LIBECC_INVERT &quot;xorl $-1,%%eax\n\t&quot;</span>
<a name="l00835"></a>00835 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_NOTHING &quot;&quot;</span>
<a name="l00836"></a>00836 <span class="preprocessor"></span>
<a name="l00837"></a>00837 <span class="preprocessor">#define LIBECC_ASMLOOP(destination, source, count, OPCODE, OPTIONAL_INVERT)     \</span>
<a name="l00838"></a>00838 <span class="preprocessor">  do {                                                  \</span>
<a name="l00839"></a>00839 <span class="preprocessor">    int __d0, __d1, __d2;                               \</span>
<a name="l00840"></a>00840 <span class="preprocessor">    __asm__ __volatile__ (                              \</span>
<a name="l00841"></a>00841 <span class="preprocessor">      &quot;\n1:\n\t&quot;                                        \</span>
<a name="l00842"></a>00842 <span class="preprocessor">        &quot;movl (%5,%%ecx,4),%%eax\n\t&quot;                   \</span>
<a name="l00843"></a>00843 <span class="preprocessor">        OPTIONAL_INVERT                                 \</span>
<a name="l00844"></a>00844 <span class="preprocessor">        OPCODE &quot; %%eax,(%4,%%ecx,4)\n\t&quot;                \</span>
<a name="l00845"></a>00845 <span class="preprocessor">        &quot;decl %%ecx\n\t&quot;                                \</span>
<a name="l00846"></a>00846 <span class="preprocessor">        &quot;jnz 1b&quot;                                        \</span>
<a name="l00847"></a>00847 <span class="preprocessor">        : &quot;=c&quot; (__d0), &quot;=&amp;r&quot; (__d1), &quot;=&amp;r&quot; (__d2)       \</span>
<a name="l00848"></a>00848 <span class="preprocessor">        : &quot;0&quot; (count),                                  \</span>
<a name="l00849"></a>00849 <span class="preprocessor">          &quot;1&quot; ((destination) - 1),                      \</span>
<a name="l00850"></a>00850 <span class="preprocessor">          &quot;2&quot; ((source) - 1)                            \</span>
<a name="l00851"></a>00851 <span class="preprocessor">        : &quot;%eax&quot;, &quot;memory&quot;                              \</span>
<a name="l00852"></a>00852 <span class="preprocessor">    );                                                  \</span>
<a name="l00853"></a>00853 <span class="preprocessor">  } while(0)</span>
<a name="l00854"></a>00854 <span class="preprocessor"></span>
<a name="l00855"></a>00855 <span class="preprocessor">#define LIBECC_ASMLOOP_BODY(OPCODE, destination, source, count, inverted) \</span>
<a name="l00856"></a>00856 <span class="preprocessor">  do { \</span>
<a name="l00857"></a>00857 <span class="preprocessor">    if (inverted) \</span>
<a name="l00858"></a>00858 <span class="preprocessor">      LIBECC_ASMLOOP(destination, source, count, OPCODE, LIBECC_INVERT); \</span>
<a name="l00859"></a>00859 <span class="preprocessor">    else \</span>
<a name="l00860"></a>00860 <span class="preprocessor">      LIBECC_ASMLOOP(destination, source, count, OPCODE, LIBECC_NOTHING); \</span>
<a name="l00861"></a>00861 <span class="preprocessor">  } while(0)</span>
<a name="l00862"></a>00862 <span class="preprocessor"></span>
<a name="l00863"></a>00863 <span class="preprocessor">#define LIBECC_ASMLOOP2(destination, source1, source2, count, OPCODE, OPTIONAL_INVERT1, OPCODE2, OPTIONAL_INVERT3)              \</span>
<a name="l00864"></a>00864 <span class="preprocessor">  do {                                                          \</span>
<a name="l00865"></a>00865 <span class="preprocessor">    int __d0, __d1, __d2, __d3;                                 \</span>
<a name="l00866"></a>00866 <span class="preprocessor">    __asm__ __volatile__ (                                      \</span>
<a name="l00867"></a>00867 <span class="preprocessor">      &quot;\n1:\n\t&quot;                                                \</span>
<a name="l00868"></a>00868 <span class="preprocessor">        &quot;movl (%6,%%ecx,4),%%eax\n\t&quot;                           \</span>
<a name="l00869"></a>00869 <span class="preprocessor">        OPTIONAL_INVERT1                                        \</span>
<a name="l00870"></a>00870 <span class="preprocessor">        OPCODE2 &quot; (%7,%%ecx,4),%%eax\n\t&quot;                       \</span>
<a name="l00871"></a>00871 <span class="preprocessor">        OPTIONAL_INVERT3                                        \</span>
<a name="l00872"></a>00872 <span class="preprocessor">        OPCODE &quot; %%eax,(%5,%%ecx,4)\n\t&quot;                        \</span>
<a name="l00873"></a>00873 <span class="preprocessor">        &quot;decl %%ecx\n\t&quot;                                        \</span>
<a name="l00874"></a>00874 <span class="preprocessor">        &quot;jnz 1b&quot;                                                \</span>
<a name="l00875"></a>00875 <span class="preprocessor">        : &quot;=c&quot; (__d0), &quot;=&amp;r&quot; (__d1), &quot;=&amp;r&quot; (__d2), &quot;=&amp;r&quot; (__d3) \</span>
<a name="l00876"></a>00876 <span class="preprocessor">        : &quot;0&quot; (count),                                          \</span>
<a name="l00877"></a>00877 <span class="preprocessor">          &quot;1&quot; ((destination) - 1),                              \</span>
<a name="l00878"></a>00878 <span class="preprocessor">          &quot;2&quot; ((source1) - 1),                                  \</span>
<a name="l00879"></a>00879 <span class="preprocessor">          &quot;3&quot; ((source2) - 1)                                   \</span>
<a name="l00880"></a>00880 <span class="preprocessor">        : &quot;%eax&quot;, &quot;memory&quot;                                      \</span>
<a name="l00881"></a>00881 <span class="preprocessor">    );                                                          \</span>
<a name="l00882"></a>00882 <span class="preprocessor">  } while(0)</span>
<a name="l00883"></a>00883 <span class="preprocessor"></span>
<a name="l00884"></a>00884 <span class="preprocessor">#define LIBECC_ASMLOOP2_BODY(OPCODE, OPERATOR, inverted1, inverted2, destination, source1, source2, count) \</span>
<a name="l00885"></a>00885 <span class="preprocessor">  do { \</span>
<a name="l00886"></a>00886 <span class="preprocessor">    if (OPERATOR::id == libecc::Operator::bitsetAND::id) \</span>
<a name="l00887"></a>00887 <span class="preprocessor">    { \</span>
<a name="l00888"></a>00888 <span class="preprocessor">      if (inverted1 &amp;&amp; inverted2) \</span>
<a name="l00889"></a>00889 <span class="preprocessor">        LIBECC_ASMLOOP2(destination, source1, source2, count, OPCODE, LIBECC_NOTHING, &quot;orl&quot;, LIBECC_INVERT); \</span>
<a name="l00890"></a>00890 <span class="preprocessor">      else if (inverted1) \</span>
<a name="l00891"></a>00891 <span class="preprocessor">        LIBECC_ASMLOOP2(destination, source1, source2, count, OPCODE, LIBECC_INVERT, &quot;andl&quot;, LIBECC_NOTHING); \</span>
<a name="l00892"></a>00892 <span class="preprocessor">      else if (inverted2) \</span>
<a name="l00893"></a>00893 <span class="preprocessor">        LIBECC_ASMLOOP2(destination, source2, source1, count, OPCODE, LIBECC_INVERT, &quot;andl&quot;, LIBECC_NOTHING); \</span>
<a name="l00894"></a>00894 <span class="preprocessor">      else \</span>
<a name="l00895"></a>00895 <span class="preprocessor">        LIBECC_ASMLOOP2(destination, source1, source2, count, OPCODE, LIBECC_NOTHING, &quot;andl&quot;, LIBECC_NOTHING); \</span>
<a name="l00896"></a>00896 <span class="preprocessor">    } \</span>
<a name="l00897"></a>00897 <span class="preprocessor">    else if (OPERATOR::id == libecc::Operator::bitsetOR::id) \</span>
<a name="l00898"></a>00898 <span class="preprocessor">    { \</span>
<a name="l00899"></a>00899 <span class="preprocessor">      if (inverted1 &amp;&amp; inverted2) \</span>
<a name="l00900"></a>00900 <span class="preprocessor">        LIBECC_ASMLOOP2(destination, source1, source2, count, OPCODE, LIBECC_NOTHING, &quot;andl&quot;, LIBECC_INVERT); \</span>
<a name="l00901"></a>00901 <span class="preprocessor">      else if (inverted1) \</span>
<a name="l00902"></a>00902 <span class="preprocessor">        LIBECC_ASMLOOP2(destination, source1, source2, count, OPCODE, LIBECC_INVERT, &quot;orl&quot;, LIBECC_NOTHING); \</span>
<a name="l00903"></a>00903 <span class="preprocessor">      else if (inverted2) \</span>
<a name="l00904"></a>00904 <span class="preprocessor">        LIBECC_ASMLOOP2(destination, source2, source1, count, OPCODE, LIBECC_INVERT, &quot;orl&quot;, LIBECC_NOTHING); \</span>
<a name="l00905"></a>00905 <span class="preprocessor">      else \</span>
<a name="l00906"></a>00906 <span class="preprocessor">        LIBECC_ASMLOOP2(destination, source1, source2, count, OPCODE, LIBECC_NOTHING, &quot;orl&quot;, LIBECC_NOTHING); \</span>
<a name="l00907"></a>00907 <span class="preprocessor">    } \</span>
<a name="l00908"></a>00908 <span class="preprocessor">    else if (OPERATOR::id == libecc::Operator::bitsetXOR::id) \</span>
<a name="l00909"></a>00909 <span class="preprocessor">    { \</span>
<a name="l00910"></a>00910 <span class="preprocessor">      if (inverted1 == inverted2) \</span>
<a name="l00911"></a>00911 <span class="preprocessor">        LIBECC_ASMLOOP2(destination, source1, source2, count, OPCODE, LIBECC_NOTHING, &quot;xorl&quot;, LIBECC_NOTHING); \</span>
<a name="l00912"></a>00912 <span class="preprocessor">      else \</span>
<a name="l00913"></a>00913 <span class="preprocessor">        LIBECC_ASMLOOP2(destination, source1, source2, count, OPCODE, LIBECC_NOTHING, &quot;xorl&quot;, LIBECC_INVERT); \</span>
<a name="l00914"></a>00914 <span class="preprocessor">    } \</span>
<a name="l00915"></a>00915 <span class="preprocessor">  } while(0)</span>
<a name="l00916"></a>00916 <span class="preprocessor"></span>
<a name="l00917"></a>00917 <span class="preprocessor">#define LIBECC_INLINE_ASMLOOP(ID, destination, source, count, inverted) \</span>
<a name="l00918"></a>00918 <span class="preprocessor">    do { \</span>
<a name="l00919"></a>00919 <span class="preprocessor">      if (ID == libecc::Operator::bitsetAssign::id) \</span>
<a name="l00920"></a>00920 <span class="preprocessor">      { \</span>
<a name="l00921"></a>00921 <span class="preprocessor">        LIBECC_ASMLOOP_BODY(&quot;movl&quot;, destination, source, count, inverted); \</span>
<a name="l00922"></a>00922 <span class="preprocessor">      } \</span>
<a name="l00923"></a>00923 <span class="preprocessor">      else if (ID == libecc::Operator::bitsetANDAssign::id) \</span>
<a name="l00924"></a>00924 <span class="preprocessor">      { \</span>
<a name="l00925"></a>00925 <span class="preprocessor">        LIBECC_ASMLOOP_BODY(&quot;andl&quot;, destination, source, count, inverted); \</span>
<a name="l00926"></a>00926 <span class="preprocessor">      } \</span>
<a name="l00927"></a>00927 <span class="preprocessor">      else if (ID == libecc::Operator::bitsetORAssign::id) \</span>
<a name="l00928"></a>00928 <span class="preprocessor">      { \</span>
<a name="l00929"></a>00929 <span class="preprocessor">        LIBECC_ASMLOOP_BODY(&quot;orl&quot;, destination, source, count, inverted); \</span>
<a name="l00930"></a>00930 <span class="preprocessor">      } \</span>
<a name="l00931"></a>00931 <span class="preprocessor">      else if (ID == libecc::Operator::bitsetXORAssign::id) \</span>
<a name="l00932"></a>00932 <span class="preprocessor">      { \</span>
<a name="l00933"></a>00933 <span class="preprocessor">        LIBECC_ASMLOOP_BODY(&quot;xorl&quot;, destination, source, count, inverted); \</span>
<a name="l00934"></a>00934 <span class="preprocessor">      } \</span>
<a name="l00935"></a>00935 <span class="preprocessor">    } while(0)</span>
<a name="l00936"></a>00936 <span class="preprocessor"></span>
<a name="l00937"></a>00937 <span class="preprocessor">#define LIBECC_INLINE_ASMLOOP2(ID, OPERATOR, inverted1, inverted2, destination, source1, source2, count) \</span>
<a name="l00938"></a>00938 <span class="preprocessor">    do { \</span>
<a name="l00939"></a>00939 <span class="preprocessor">      if (ID == libecc::Operator::bitsetAssign::id) \</span>
<a name="l00940"></a>00940 <span class="preprocessor">      { \</span>
<a name="l00941"></a>00941 <span class="preprocessor">        LIBECC_ASMLOOP2_BODY(&quot;movl&quot;, OPERATOR, inverted1, inverted2, destination, source1, source2, count); \</span>
<a name="l00942"></a>00942 <span class="preprocessor">      } \</span>
<a name="l00943"></a>00943 <span class="preprocessor">      else if (ID == libecc::Operator::bitsetANDAssign::id) \</span>
<a name="l00944"></a>00944 <span class="preprocessor">      { \</span>
<a name="l00945"></a>00945 <span class="preprocessor">        LIBECC_ASMLOOP2_BODY(&quot;andl&quot;, OPERATOR, inverted1, inverted2, destination, source1, source2, count); \</span>
<a name="l00946"></a>00946 <span class="preprocessor">      } \</span>
<a name="l00947"></a>00947 <span class="preprocessor">      else if (ID == libecc::Operator::bitsetORAssign::id) \</span>
<a name="l00948"></a>00948 <span class="preprocessor">      { \</span>
<a name="l00949"></a>00949 <span class="preprocessor">        LIBECC_ASMLOOP2_BODY(&quot;orl&quot;, OPERATOR, inverted1, inverted2, destination, source1, source2, count); \</span>
<a name="l00950"></a>00950 <span class="preprocessor">      } \</span>
<a name="l00951"></a>00951 <span class="preprocessor">      else if (ID == libecc::Operator::bitsetXORAssign::id) \</span>
<a name="l00952"></a>00952 <span class="preprocessor">      { \</span>
<a name="l00953"></a>00953 <span class="preprocessor">        LIBECC_ASMLOOP2_BODY(&quot;xorl&quot;, OPERATOR, inverted1, inverted2, destination, source1, source2, count); \</span>
<a name="l00954"></a>00954 <span class="preprocessor">      } \</span>
<a name="l00955"></a>00955 <span class="preprocessor">    } while(0)</span>
<a name="l00956"></a>00956 <span class="preprocessor"></span>
<a name="l00957"></a>00957 <span class="preprocessor">#define LIBECC_ASMSHIFTRIGHT0(OP1)                      \</span>
<a name="l00958"></a>00958 <span class="preprocessor">              __asm__ __volatile__ (                    \</span>
<a name="l00959"></a>00959 <span class="preprocessor">                  &quot;movl 4(%%esi),%%edx\n\t&quot;             \</span>
<a name="l00960"></a>00960 <span class="preprocessor">                  &quot;shrl $1,%%edx\n\t&quot;                   \</span>
<a name="l00961"></a>00961 <span class="preprocessor">                  OP1                                   \</span>
<a name="l00962"></a>00962 <span class="preprocessor">                  &quot;movl %%edx,4(%%edi)&quot;                 \</span>
<a name="l00963"></a>00963 <span class="preprocessor">                : &quot;=&amp;S&quot; (ptr1),                         \</span>
<a name="l00964"></a>00964 <span class="preprocessor">                  &quot;=&amp;D&quot; (ptr2)                          \</span>
<a name="l00965"></a>00965 <span class="preprocessor">                : &quot;0&quot; (&amp;this-&gt;vector[initial - count]), \</span>
<a name="l00966"></a>00966 <span class="preprocessor">                  &quot;1&quot; (&amp;result.vector[initial - count]) \</span>
<a name="l00967"></a>00967 <span class="preprocessor">                : &quot;%eax&quot;, &quot;%edx&quot;, &quot;memory&quot;, &quot;cc&quot;        \</span>
<a name="l00968"></a>00968 <span class="preprocessor">              )</span>
<a name="l00969"></a>00969 <span class="preprocessor"></span>
<a name="l00970"></a>00970 <span class="preprocessor">#if 0   // NOT faster.</span>
<a name="l00971"></a>00971 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_OP1_SOURCE &quot;(%%esi)&quot;</span>
<a name="l00972"></a>00972 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_OP2_SOURCE &quot;(%%esi)&quot;</span>
<a name="l00973"></a>00973 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_OP1_DESTINATION &quot;(%%edi)&quot;</span>
<a name="l00974"></a>00974 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_OP2_DESTINATION &quot;(%%edi)&quot;</span>
<a name="l00975"></a>00975 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_WORKREG &quot;%%eax&quot;</span>
<a name="l00976"></a>00976 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_CLOBBER &quot;%eax&quot;</span>
<a name="l00977"></a>00977 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_INIT &quot;std\n\t&quot;</span>
<a name="l00978"></a>00978 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_LOAD1 &quot;lodsl\n\t&quot;</span>
<a name="l00979"></a>00979 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_SHIFT &quot;shrl $1,&quot; LIBECC_WORKREG &quot;\n\t&quot;</span>
<a name="l00980"></a>00980 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_STORE1 &quot;stosl\n\t&quot;</span>
<a name="l00981"></a>00981 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_LOAD2 &quot;lodsl\n\t&quot;</span>
<a name="l00982"></a>00982 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_ROTATE &quot;rcrl $1,&quot; LIBECC_WORKREG &quot;\n\t&quot;</span>
<a name="l00983"></a>00983 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_STORE2 &quot;stosl\n\t&quot;</span>
<a name="l00984"></a>00984 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_DEINIT &quot;cld\n\t&quot;</span>
<a name="l00985"></a>00985 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_RIGHT_PRESERVE_CF(OPERAND) &quot;setc %%edx\n\t&quot; OPERAND &quot;\n\tbt $0,%%edx\n\t&quot;</span>
<a name="l00986"></a>00986 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_PRESERVE_CF_CLOBBER LIBECC_CLOBBER,&quot;%edx&quot;</span>
<a name="l00987"></a>00987 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_INITIAL_ESI &amp;this-&gt;vector[initial]</span>
<a name="l00988"></a>00988 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_INITIAL_EDI &amp;result.vector[initial]</span>
<a name="l00989"></a>00989 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00990"></a>00990 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_OP1_SOURCE &quot;4(%%esi,%%ecx,4)&quot;</span>
<a name="l00991"></a>00991 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_OP2_SOURCE &quot;(%%esi,%%ecx,4)&quot;</span>
<a name="l00992"></a>00992 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_OP1_DESTINATION &quot;4(%%edi,%%ecx,4)&quot;</span>
<a name="l00993"></a>00993 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_OP2_DESTINATION &quot;(%%edi,%%ecx,4)&quot;</span>
<a name="l00994"></a>00994 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_WORKREG &quot;%%edx&quot;</span>
<a name="l00995"></a>00995 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_CLOBBER &quot;%edx&quot;</span>
<a name="l00996"></a>00996 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_INIT</span>
<a name="l00997"></a>00997 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_LOAD1 &quot;movl &quot; LIBECC_OP1_SOURCE &quot;,&quot; LIBECC_WORKREG &quot;\n\t&quot;</span>
<a name="l00998"></a>00998 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_SHIFT &quot;shrl $1,&quot; LIBECC_WORKREG &quot;\n\t&quot;</span>
<a name="l00999"></a>00999 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_STORE1 &quot;movl &quot; LIBECC_WORKREG &quot;,&quot; LIBECC_OP1_DESTINATION &quot;\n\t&quot;</span>
<a name="l01000"></a>01000 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_LOAD2 &quot;movl &quot; LIBECC_OP2_SOURCE &quot;,&quot; LIBECC_WORKREG &quot;\n\t&quot;</span>
<a name="l01001"></a>01001 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_ROTATE &quot;rcrl $1,&quot; LIBECC_WORKREG &quot;\n\t&quot;</span>
<a name="l01002"></a>01002 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_STORE2 &quot;movl &quot; LIBECC_WORKREG &quot;,&quot; LIBECC_OP2_DESTINATION &quot;\n\t&quot;</span>
<a name="l01003"></a>01003 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_DEINIT</span>
<a name="l01004"></a>01004 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_RIGHT_PRESERVE_CF(OPERAND) &quot;lahf\n\t&quot; OPERAND &quot;\n\tsahf\n\t&quot;</span>
<a name="l01005"></a>01005 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_PRESERVE_CF_CLOBBER LIBECC_CLOBBER,&quot;%eax&quot;</span>
<a name="l01006"></a>01006 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_INITIAL_ESI &amp;this-&gt;vector[initial - count]</span>
<a name="l01007"></a>01007 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_INITIAL_EDI &amp;result.vector[initial - count]</span>
<a name="l01008"></a>01008 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01009"></a>01009 <span class="preprocessor"></span>
<a name="l01010"></a>01010 <span class="preprocessor">#define LIBECC_ASMSHIFTRIGHT1(OP1, OP2, CLOBBER)        \</span>
<a name="l01011"></a>01011 <span class="preprocessor">              __asm__ __volatile__ (                    \</span>
<a name="l01012"></a>01012 <span class="preprocessor">                  LIBECC_INIT                           \</span>
<a name="l01013"></a>01013 <span class="preprocessor">                  LIBECC_LOAD1                          \</span>
<a name="l01014"></a>01014 <span class="preprocessor">                  LIBECC_SHIFT                          \</span>
<a name="l01015"></a>01015 <span class="preprocessor">                  OP1                                   \</span>
<a name="l01016"></a>01016 <span class="preprocessor">                  LIBECC_STORE1                         \</span>
<a name="l01017"></a>01017 <span class="preprocessor">                &quot;1:\n\t&quot;                                \</span>
<a name="l01018"></a>01018 <span class="preprocessor">                  LIBECC_LOAD2                          \</span>
<a name="l01019"></a>01019 <span class="preprocessor">                  LIBECC_ROTATE                         \</span>
<a name="l01020"></a>01020 <span class="preprocessor">                  OP2                                   \</span>
<a name="l01021"></a>01021 <span class="preprocessor">                  LIBECC_STORE2                         \</span>
<a name="l01022"></a>01022 <span class="preprocessor">                  &quot;decl %%ecx\n\t&quot;                      \</span>
<a name="l01023"></a>01023 <span class="preprocessor">                  &quot;jnz 1b\n\t&quot;                          \</span>
<a name="l01024"></a>01024 <span class="preprocessor">                  LIBECC_DEINIT                         \</span>
<a name="l01025"></a>01025 <span class="preprocessor">                : &quot;=&amp;S&quot; (ptr1),                         \</span>
<a name="l01026"></a>01026 <span class="preprocessor">                  &quot;=&amp;D&quot; (ptr2),                         \</span>
<a name="l01027"></a>01027 <span class="preprocessor">                  &quot;=&amp;c&quot; (c)                             \</span>
<a name="l01028"></a>01028 <span class="preprocessor">                : &quot;0&quot; (LIBECC_INITIAL_ESI),             \</span>
<a name="l01029"></a>01029 <span class="preprocessor">                  &quot;1&quot; (LIBECC_INITIAL_EDI),             \</span>
<a name="l01030"></a>01030 <span class="preprocessor">                  &quot;2&quot; (count - 1)                       \</span>
<a name="l01031"></a>01031 <span class="preprocessor">                : &quot;memory&quot;, &quot;cc&quot;, CLOBBER               \</span>
<a name="l01032"></a>01032 <span class="preprocessor">              )</span>
<a name="l01033"></a>01033 <span class="preprocessor"></span>
<a name="l01034"></a>01034 <span class="preprocessor">#define LIBECC_ASMSHIFTLEFT(OP1, OP2, FINISH)           \</span>
<a name="l01035"></a>01035 <span class="preprocessor">              __asm__ __volatile__ (                    \</span>
<a name="l01036"></a>01036 <span class="preprocessor">                  &quot;movl -4(%%esi),%%edx\n\t&quot;            \</span>
<a name="l01037"></a>01037 <span class="preprocessor">                  &quot;shll $1,%%edx\n\t&quot;                   \</span>
<a name="l01038"></a>01038 <span class="preprocessor">                  OP1                                   \</span>
<a name="l01039"></a>01039 <span class="preprocessor">                  &quot;movl %%edx,-4(%%edi)\n\t&quot;            \</span>
<a name="l01040"></a>01040 <span class="preprocessor">                  &quot;jecxz 2f\n&quot;                          \</span>
<a name="l01041"></a>01041 <span class="preprocessor">                &quot;1:\n\t&quot;                                \</span>
<a name="l01042"></a>01042 <span class="preprocessor">                  &quot;movl (%%esi),%%edx\n\t&quot;              \</span>
<a name="l01043"></a>01043 <span class="preprocessor">                  &quot;rcll $1,%%edx\n\t&quot;                   \</span>
<a name="l01044"></a>01044 <span class="preprocessor">                  OP2                                   \</span>
<a name="l01045"></a>01045 <span class="preprocessor">                  &quot;movl %%edx,(%%edi)\n\t&quot;              \</span>
<a name="l01046"></a>01046 <span class="preprocessor">                  &quot;leal 4(%%esi),%%esi\n\t&quot;             \</span>
<a name="l01047"></a>01047 <span class="preprocessor">                  &quot;leal 4(%%edi),%%edi\n\t&quot;             \</span>
<a name="l01048"></a>01048 <span class="preprocessor">                  &quot;decl %%ecx\n\t&quot;                      \</span>
<a name="l01049"></a>01049 <span class="preprocessor">                  &quot;jnz 1b\n&quot;                            \</span>
<a name="l01050"></a>01050 <span class="preprocessor">                &quot;2:\n\t&quot;                                \</span>
<a name="l01051"></a>01051 <span class="preprocessor">                  FINISH                                \</span>
<a name="l01052"></a>01052 <span class="preprocessor">                : &quot;=&amp;S&quot; (ptr1),                         \</span>
<a name="l01053"></a>01053 <span class="preprocessor">                  &quot;=&amp;D&quot; (ptr2),                         \</span>
<a name="l01054"></a>01054 <span class="preprocessor">                  &quot;=&amp;c&quot; (c)                             \</span>
<a name="l01055"></a>01055 <span class="preprocessor">                : &quot;0&quot; (&amp;this-&gt;vector[initial + 1]),     \</span>
<a name="l01056"></a>01056 <span class="preprocessor">                  &quot;1&quot; (&amp;result.vector[initial + 1]),    \</span>
<a name="l01057"></a>01057 <span class="preprocessor">                  &quot;2&quot; (count - 1),                      \</span>
<a name="l01058"></a>01058 <span class="preprocessor">                  &quot;n&quot; (bitset_base&lt;N&gt;::valid_bits)      \</span>
<a name="l01059"></a>01059 <span class="preprocessor">                : &quot;%eax&quot;, &quot;%edx&quot;, &quot;memory&quot;, &quot;cc&quot;        \</span>
<a name="l01060"></a>01060 <span class="preprocessor">              )</span>
<a name="l01061"></a>01061 <span class="preprocessor"></span>
<a name="l01062"></a>01062 <span class="preprocessor">#define LIBECC_ASMSHIFTLEFT_FINISH(OP)                  \</span>
<a name="l01063"></a>01063 <span class="preprocessor">                  &quot;movl (%%esi),%%edx\n\t&quot;              \</span>
<a name="l01064"></a>01064 <span class="preprocessor">                  &quot;rcll $1,%%edx\n\t&quot;                   \</span>
<a name="l01065"></a>01065 <span class="preprocessor">                  &quot;andl %6,%%edx\n\t&quot;                   \</span>
<a name="l01066"></a>01066 <span class="preprocessor">                  OP                                    \</span>
<a name="l01067"></a>01067 <span class="preprocessor">                  &quot;movl %%edx,(%%edi)&quot;</span>
<a name="l01068"></a>01068 <span class="preprocessor"></span>
<a name="l01069"></a>01069 <span class="preprocessor">#define LIBECC_LEFT_PRESERVE_CF(OPERAND) &quot;lahf\n\t&quot; OPERAND &quot;\n\tsahf\n\t&quot;</span>
<a name="l01070"></a>01070 <span class="preprocessor"></span>
<a name="l01071"></a>01071 <span class="preprocessor">#endif // __i386__</span>
<a name="l01072"></a>01072 <span class="preprocessor"></span>
<a name="l01073"></a>01073 <span class="comment">// Functors.</span>
<a name="l01074"></a>01074 
<a name="l01075"></a>01075 <span class="comment">// Functor for &#39;&amp;&#39;.</span>
<a name="l01076"></a>01076 <span class="keyword">struct</span>bitsetAND {
<a name="l01077"></a>01077   <span class="keyword">static</span> <span class="keywordtype">int</span> <span class="keyword">const</span> <span class="keywordtype">id</span> = 1;
<a name="l01078"></a>01078   <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> exec(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> digit1, <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> digit2) { <span class="keywordflow">return</span> digit1 &amp; digit2; }
<a name="l01079"></a>01079   <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> inverted1, <span class="keywordtype">bool</span> inverted2&gt;
<a name="l01080"></a>01080    <span class="keyword">struct</span>execbool {
<a name="l01081"></a>01081      <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> value = inverted1 &amp;&amp; inverted2;
<a name="l01082"></a>01082    };
<a name="l01083"></a>01083 };
<a name="l01084"></a>01084 
<a name="l01085"></a>01085 <span class="comment">// Functor for &#39;|&#39;.</span>
<a name="l01086"></a>01086 <span class="keyword">struct</span>bitsetOR {
<a name="l01087"></a>01087   <span class="keyword">static</span> <span class="keywordtype">int</span> <span class="keyword">const</span> <span class="keywordtype">id</span> = 2;
<a name="l01088"></a>01088   <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> exec(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> digit1, <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> digit2) { <span class="keywordflow">return</span> digit1 | digit2; }
<a name="l01089"></a>01089   <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> inverted1, <span class="keywordtype">bool</span> inverted2&gt;
<a name="l01090"></a>01090    <span class="keyword">struct</span>execbool {
<a name="l01091"></a>01091      <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> value = inverted1 || inverted2;
<a name="l01092"></a>01092    };
<a name="l01093"></a>01093 };
<a name="l01094"></a>01094 
<a name="l01095"></a>01095 <span class="comment">// Functor for &#39;^&#39;.</span>
<a name="l01096"></a>01096 <span class="keyword">struct</span>bitsetXOR {
<a name="l01097"></a>01097   <span class="keyword">static</span> <span class="keywordtype">int</span> <span class="keyword">const</span> <span class="keywordtype">id</span> = 3;
<a name="l01098"></a>01098   <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> exec(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> digit1, <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> digit2) { <span class="keywordflow">return</span> digit1 ^ digit2; }
<a name="l01099"></a>01099   <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> inverted1, <span class="keywordtype">bool</span> inverted2&gt;
<a name="l01100"></a>01100    <span class="keyword">struct</span>execbool {
<a name="l01101"></a>01101      <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> value = (inverted1 != inverted2);
<a name="l01102"></a>01102    };
<a name="l01103"></a>01103 };
<a name="l01104"></a>01104 
<a name="l01105"></a>01105 <span class="comment">// Functor for &#39;=&#39;.</span>
<a name="l01106"></a>01106 <span class="keyword">struct</span>bitsetAssign {
<a name="l01107"></a>01107   <span class="keyword">static</span> <span class="keywordtype">int</span> <span class="keyword">const</span> <span class="keywordtype">id</span> = 1;
<a name="l01108"></a>01108   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> sets_excess_bits = <span class="keyword">true</span>;
<a name="l01109"></a>01109   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> with_zero_sets_zero = <span class="keyword">true</span>;
<a name="l01110"></a>01110   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> with_ones_sets_ones = <span class="keyword">true</span>;
<a name="l01111"></a>01111   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> with_ones_inverts = <span class="keyword">false</span>;
<a name="l01112"></a>01112   <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> exec(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>&amp; out, <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> in) { out = in; }
<a name="l01113"></a>01113 };
<a name="l01114"></a>01114 
<a name="l01115"></a>01115 <span class="comment">// Functor for &#39;&amp;=&#39;.</span>
<a name="l01116"></a>01116 <span class="keyword">struct</span>bitsetANDAssign {
<a name="l01117"></a>01117   <span class="keyword">static</span> <span class="keywordtype">int</span> <span class="keyword">const</span> <span class="keywordtype">id</span> = 2;
<a name="l01118"></a>01118   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> sets_excess_bits = <span class="keyword">false</span>;
<a name="l01119"></a>01119   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> with_zero_sets_zero = <span class="keyword">true</span>;
<a name="l01120"></a>01120   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> with_ones_sets_ones = <span class="keyword">false</span>;
<a name="l01121"></a>01121   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> with_ones_inverts = <span class="keyword">false</span>;
<a name="l01122"></a>01122   <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> exec(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>&amp; out, <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> in) { out &amp;= in; }
<a name="l01123"></a>01123 };
<a name="l01124"></a>01124 
<a name="l01125"></a>01125 <span class="comment">// Functor for &#39;|=&#39;.</span>
<a name="l01126"></a>01126 <span class="keyword">struct</span>bitsetORAssign {
<a name="l01127"></a>01127   <span class="keyword">static</span> <span class="keywordtype">int</span> <span class="keyword">const</span> <span class="keywordtype">id</span> = 3;
<a name="l01128"></a>01128   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> sets_excess_bits = <span class="keyword">true</span>;
<a name="l01129"></a>01129   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> with_zero_sets_zero = <span class="keyword">false</span>;
<a name="l01130"></a>01130   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> with_ones_sets_ones = <span class="keyword">true</span>;
<a name="l01131"></a>01131   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> with_ones_inverts = <span class="keyword">false</span>;
<a name="l01132"></a>01132   <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> exec(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>&amp; out, <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> in) { out |= in; }
<a name="l01133"></a>01133 };
<a name="l01134"></a>01134 
<a name="l01135"></a>01135 <span class="comment">// Functor for &#39;^=&#39;.</span>
<a name="l01136"></a>01136 <span class="keyword">struct</span>bitsetXORAssign {
<a name="l01137"></a>01137   <span class="keyword">static</span> <span class="keywordtype">int</span> <span class="keyword">const</span> <span class="keywordtype">id</span> = 4;
<a name="l01138"></a>01138   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> sets_excess_bits = <span class="keyword">true</span>;
<a name="l01139"></a>01139   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> with_zero_sets_zero = <span class="keyword">false</span>;
<a name="l01140"></a>01140   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> with_ones_sets_ones = <span class="keyword">false</span>;
<a name="l01141"></a>01141   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> with_ones_inverts = <span class="keyword">true</span>;
<a name="l01142"></a>01142   <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> exec(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>&amp; out, <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> in) { out ^= in; }
<a name="l01143"></a>01143 };
<a name="l01144"></a>01144 
<a name="l01145"></a>01145 <span class="preprocessor">#if LIBECC_TRACK_EXPR_TEMPORARIES</span>
<a name="l01146"></a>01146 <span class="preprocessor"></span><span class="keyword">extern</span> std::multiset&lt;void const*&gt; bitsetExpression_bitset_invertible_pointers;
<a name="l01147"></a>01147 <span class="preprocessor">#endif</span>
<a name="l01148"></a>01148 <span class="preprocessor"></span>
<a name="l01149"></a>01149 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">bool</span> inverted1, <span class="keywordtype">bool</span> inverted2, <span class="keyword">typename</span> OP&gt;
<a name="l01150"></a>01150   <span class="keyword">struct</span>bitsetExpression
<a name="l01151"></a>01151   {
<a name="l01152"></a>01152     bitset_invertible&lt;N, inverted1&gt; <span class="keyword">const</span>&amp; first;
<a name="l01153"></a>01153     bitset_invertible&lt;N, inverted2&gt; <span class="keyword">const</span>&amp; second;
<a name="l01154"></a>01154     OP op;
<a name="l01155"></a>01155 
<a name="l01156"></a>01156     bitsetExpression(bitset_invertible&lt;N, inverted1&gt; <span class="keyword">const</span>&amp; arg1, bitset_invertible&lt;N, inverted2&gt; <span class="keyword">const</span>&amp; arg2) :
<a name="l01157"></a>01157         first(arg1), second(arg2)
<a name="l01158"></a>01158     {
<a name="l01159"></a>01159       <span class="comment">// I found a problem with a destructed temporary that was still in use.</span>
<a name="l01160"></a>01160       <span class="comment">// It seems that the pointer to this destructed temporary is stored in</span>
<a name="l01161"></a>01161       <span class="comment">// this object.  The following code is added in order to debug this</span>
<a name="l01162"></a>01162       <span class="comment">// problem.</span>
<a name="l01163"></a>01163 <span class="preprocessor">#if LIBECC_TRACK_EXPR_TEMPORARIES</span>
<a name="l01164"></a>01164 <span class="preprocessor"></span>      bitsetExpression_bitset_invertible_pointers.insert(&amp;arg1);
<a name="l01165"></a>01165       bitsetExpression_bitset_invertible_pointers.insert(&amp;arg2);
<a name="l01166"></a>01166       LibEccDout(dc::notice, <span class="stringliteral">&quot;Constructed a bitsetExpression with arguments &quot;</span> &lt;&lt;
<a name="l01167"></a>01167           (<span class="keywordtype">void</span> <span class="keyword">const</span>*)&amp;first &lt;&lt; <span class="stringliteral">&quot; and &quot;</span> &lt;&lt; (<span class="keywordtype">void</span> <span class="keyword">const</span>*)&amp;second);
<a name="l01168"></a>01168 <span class="preprocessor">#endif</span>
<a name="l01169"></a>01169 <span class="preprocessor"></span>    }
<a name="l01170"></a>01170 <span class="preprocessor">#if LIBECC_TRACK_EXPR_TEMPORARIES</span>
<a name="l01171"></a>01171 <span class="preprocessor"></span>    ~bitsetExpression();
<a name="l01172"></a>01172 <span class="preprocessor">#endif</span>
<a name="l01173"></a>01173 <span class="preprocessor"></span>  };
<a name="l01174"></a>01174 
<a name="l01175"></a>01175 <span class="preprocessor">#if LIBECC_TRACK_EXPR_TEMPORARIES</span>
<a name="l01176"></a>01176 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">bool</span> inverted1, <span class="keywordtype">bool</span> inverted2, <span class="keyword">typename</span> OP&gt;
<a name="l01177"></a>01177   bitsetExpression&lt;N, inverted1, inverted2, OP&gt;::~bitsetExpression()
<a name="l01178"></a>01178   {
<a name="l01179"></a>01179     bitsetExpression_bitset_invertible_pointers.erase(bitsetExpression_bitset_invertible_pointers.find(&amp;first));
<a name="l01180"></a>01180     bitsetExpression_bitset_invertible_pointers.erase(bitsetExpression_bitset_invertible_pointers.find(&amp;second));
<a name="l01181"></a>01181     LibEccDout(dc::notice, <span class="stringliteral">&quot;Destructed bitsetExpression with arguments &quot;</span> &lt;&lt;
<a name="l01182"></a>01182         (<span class="keywordtype">void</span> <span class="keyword">const</span>*)&amp;first &lt;&lt; <span class="stringliteral">&quot; and &quot;</span> &lt;&lt; (<span class="keywordtype">void</span> <span class="keyword">const</span>*)&amp;second);
<a name="l01183"></a>01183   }
<a name="l01184"></a>01184 <span class="preprocessor">#endif</span>
<a name="l01185"></a>01185 <span class="preprocessor"></span>
<a name="l01186"></a>01186 } <span class="comment">// namespace Operator</span>
<a name="l01187"></a>01187 <span class="preprocessor">#endif // HIDE_FROM_DOXYGEN</span>
<a name="l01188"></a>01188 <span class="preprocessor"></span>
<a name="l01206"></a>01206 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">bool</span> inverted&gt;
<a name="l01207"></a><a class="code" href="classlibecc_1_1bitset__invertible.html">01207</a>   <span class="keyword">class</span><a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible</a> : <span class="keyword">public</span> <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base</a>&lt;N&gt; {
<a name="l01208"></a>01208     <span class="keyword">public</span>:
<a name="l01209"></a>01209       <span class="comment">// Constructors</span>
<a name="l01210"></a>01210       <a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible</a>(<span class="keywordtype">void</span>);
<a name="l01211"></a>01211       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Expression&gt;
<a name="l01212"></a>01212         <span class="keyword">explicit</span> <a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible</a>(Expression <span class="keyword">const</span>&amp;);
<a name="l01213"></a>01213 
<a name="l01214"></a>01214 <span class="preprocessor">#if LIBECC_TRACK_EXPR_TEMPORARIES</span>
<a name="l01215"></a>01215 <span class="preprocessor"></span>      ~<a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible</a>();
<a name="l01216"></a>01216 <span class="preprocessor">#endif</span>
<a name="l01217"></a>01217 <span class="preprocessor"></span>
<a name="l01218"></a>01218     <span class="keyword">protected</span>:
<a name="l01219"></a>01219       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> OP, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x, <span class="keywordtype">bool</span> invertedx&gt;
<a name="l01220"></a>01220         <span class="keywordtype">void</span> <a class="code" href="structlibecc_1_1assign.html" title="Operation used with libecc::bitset::shift_op.">assign</a>(<a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;x, invertedx&gt;</a> <span class="keyword">const</span>&amp;, OP);
<a name="l01221"></a>01221       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> OP1, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x, <span class="keywordtype">bool</span> inverted1, <span class="keywordtype">bool</span> inverted2, <span class="keyword">typename</span> OP2&gt;
<a name="l01222"></a>01222         <span class="keywordtype">void</span> assign(Operator::bitsetExpression&lt;x, inverted1, inverted2, OP2&gt; <span class="keyword">const</span>&amp;, OP1);
<a name="l01223"></a>01223 
<a name="l01224"></a>01224     <span class="keyword">private</span>:
<a name="l01225"></a>01225       <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m, <span class="keywordtype">bool</span> i&gt;
<a name="l01226"></a>01226         <span class="keyword">friend</span> <span class="keyword">class</span><a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible</a>;
<a name="l01227"></a>01227 
<a name="l01228"></a>01228     <span class="keyword">public</span>:
<a name="l01230"></a>01230       <span class="keywordtype">void</span> base2_print_on(std::ostream&amp; os) <span class="keyword">const</span>;
<a name="l01231"></a>01231 
<a name="l01233"></a><a class="code" href="classlibecc_1_1bitset__invertible.html#a9bf8dafb22ff7f9dd53721fadea6f1bb">01233</a>       <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <a class="code" href="classlibecc_1_1bitset__invertible.html#a9bf8dafb22ff7f9dd53721fadea6f1bb" title="Access digit number d.">digit</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d)<span class="keyword"> const</span>{ <span class="keywordflow">return</span> inverted ? ~this-&gt;vector[d] : this-&gt;vector[d]; }
<a name="l01234"></a>01234   };
<a name="l01235"></a>01235 
<a name="l01236"></a>01236 <span class="preprocessor">#if LIBECC_TRACK_EXPR_TEMPORARIES</span>
<a name="l01237"></a>01237 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">bool</span> inverted&gt;
<a name="l01238"></a>01238   bitset_invertible&lt;N, inverted&gt;::~bitset_invertible()
<a name="l01239"></a>01239   {
<a name="l01240"></a>01240     LibEccDout(dc::notice, <span class="stringliteral">&quot;Destructing bitset_invertible at &quot;</span> &lt;&lt; (<span class="keywordtype">void</span>*)<span class="keyword">this</span>);
<a name="l01241"></a>01241     <span class="keywordflow">if</span> (Operator::bitsetExpression_bitset_invertible_pointers.find(<span class="keyword">this</span>) !=
<a name="l01242"></a>01242         Operator::bitsetExpression_bitset_invertible_pointers.end())
<a name="l01243"></a>01243       LibEccDoutFatal(dc::core, <span class="stringliteral">&quot;This object is still in use by a bitsetExpression!&quot;</span>);
<a name="l01244"></a>01244   }
<a name="l01245"></a>01245 <span class="preprocessor">#endif</span>
<a name="l01246"></a>01246 <span class="preprocessor"></span>
<a name="l01258"></a>01258 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">bool</span> inverted&gt;
<a name="l01259"></a>01259   <span class="keywordtype">void</span>
<a name="l01260"></a><a class="code" href="classlibecc_1_1bitset__invertible.html#add8cd27ec1fdbf33c41aa617e50c4302">01260</a>   <a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;N, inverted&gt;::base2_print_on</a>(std::ostream&amp; os)<span class="keyword"> const</span>
<a name="l01261"></a>01261 <span class="keyword"> </span>{
<a name="l01262"></a>01262     <span class="comment">// Binary representation</span>
<a name="l01263"></a>01263     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> d = <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;::digits</a> - 1; d &gt;= 0; --d)
<a name="l01264"></a>01264       <span class="keywordflow">for</span> (<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> mask = (~static_cast&lt;bitset_digit_t&gt;(0) &gt;&gt; 1) + 1; mask != 0; mask &gt;&gt;= 1)
<a name="l01265"></a>01265         <span class="keywordflow">if</span> (d != <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;::digits</a> - 1 || (mask &amp; <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;::valid_bits</a>))
<a name="l01266"></a>01266         {
<a name="l01267"></a>01267           <span class="keywordflow">if</span> ((this-&gt;<a class="code" href="classlibecc_1_1bitset__invertible.html#a9bf8dafb22ff7f9dd53721fadea6f1bb" title="Access digit number d.">digit</a>(d) &amp; mask) == inverted)
<a name="l01268"></a>01268             os &lt;&lt; <span class="charliteral">&#39;0&#39;</span>;
<a name="l01269"></a>01269           <span class="keywordflow">else</span>
<a name="l01270"></a>01270             os &lt;&lt; <span class="charliteral">&#39;1&#39;</span>;
<a name="l01271"></a>01271         }
<a name="l01272"></a>01272   }
<a name="l01273"></a>01273 
<a name="l01274"></a>01274 <span class="comment">// Default constructor.</span>
<a name="l01275"></a>01275 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">bool</span> inverted&gt;
<a name="l01276"></a>01276   <span class="keyword">inline</span>
<a name="l01277"></a>01277   <a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;N, inverted&gt;::bitset_invertible</a>(<span class="keywordtype">void</span>)
<a name="l01278"></a>01278   {
<a name="l01279"></a>01279     <span class="keywordflow">if</span> (<a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;::has_excess_bits</a>)
<a name="l01280"></a>01280       this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[<a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;::digits</a> - 1] = 0;                     <span class="comment">// Reset the excess bits!</span>
<a name="l01281"></a>01281   }
<a name="l01282"></a>01282 
<a name="l01283"></a>01283 <span class="comment">// Copy constructor.</span>
<a name="l01284"></a>01284 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">bool</span> inverted&gt;
<a name="l01285"></a>01285   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Expression&gt;
<a name="l01286"></a>01286     <span class="keyword">inline</span>
<a name="l01287"></a>01287     bitset_invertible&lt;N, inverted&gt;::bitset_invertible(Expression <span class="keyword">const</span>&amp; expr)
<a name="l01288"></a>01288     {
<a name="l01289"></a>01289       this-&gt;assign(expr, Operator::bitsetAssign());
<a name="l01290"></a>01290     }
<a name="l01291"></a>01291 
<a name="l01292"></a>01292 <span class="comment">//</span>
<a name="l01293"></a>01293 <span class="comment">// Assignment function.</span>
<a name="l01294"></a>01294 <span class="comment">// This function handles:</span>
<a name="l01295"></a>01295 <span class="comment">//</span>
<a name="l01296"></a>01296 <span class="comment">// a = b;</span>
<a name="l01297"></a>01297 <span class="comment">// a = ~b;</span>
<a name="l01298"></a>01298 <span class="comment">// a &amp;= b;</span>
<a name="l01299"></a>01299 <span class="comment">// a &amp;= ~b;</span>
<a name="l01300"></a>01300 <span class="comment">// a |= b;</span>
<a name="l01301"></a>01301 <span class="comment">// a |= ~b;</span>
<a name="l01302"></a>01302 <span class="comment">// a ^= b;</span>
<a name="l01303"></a>01303 <span class="comment">// a ^= ~b;</span>
<a name="l01304"></a>01304 <span class="comment">//</span>
<a name="l01305"></a>01305 <span class="comment">// ASSIGNMENT_OPERATOR is one of bitsetAssign, bitsetANDAssign, bitsetORAssign or bitsetXORAssign.</span>
<a name="l01306"></a>01306 <span class="comment">//</span>
<a name="l01307"></a>01307 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">bool</span> inverted&gt;
<a name="l01308"></a>01308   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ASSIGNMENT_OPERATOR, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x, <span class="keywordtype">bool</span> inverted_argument&gt;
<a name="l01309"></a>01309     <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l01310"></a>01310     bitset_invertible&lt;N, inverted&gt;::assign(bitset_invertible&lt;x, inverted_argument&gt; <span class="keyword">const</span>&amp; bits, ASSIGNMENT_OPERATOR)
<a name="l01311"></a>01311     {
<a name="l01312"></a>01312       <span class="comment">// Handle excess digits.</span>
<a name="l01313"></a>01313       <span class="keywordflow">if</span> (bitset_base&lt;N&gt;::digits &gt; bitset_base&lt;x&gt;::digits)
<a name="l01314"></a>01314       {
<a name="l01315"></a>01315         <span class="keywordflow">if</span> (!inverted_argument)
<a name="l01316"></a>01316         {
<a name="l01317"></a>01317           <span class="comment">// Fill excess digits with 0&#39;s when needed.</span>
<a name="l01318"></a>01318           <span class="keywordflow">if</span> (ASSIGNMENT_OPERATOR::with_zero_sets_zero)
<a name="l01319"></a>01319             std::memset(&amp;this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[bitset_base&lt;x&gt;::digits], 0, (bitset_base&lt;N&gt;::digits - bitset_base&lt;x&gt;::digits) * <span class="keyword">sizeof</span>(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>));
<a name="l01320"></a>01320         }
<a name="l01321"></a>01321         <span class="keywordflow">else</span>
<a name="l01322"></a>01322         {
<a name="l01323"></a>01323           <span class="comment">// Fill excess digits with 1&#39;s when needed.</span>
<a name="l01324"></a>01324           <span class="keywordflow">if</span> (ASSIGNMENT_OPERATOR::with_ones_sets_ones)
<a name="l01325"></a>01325           {
<a name="l01326"></a>01326             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> count = bitset_base&lt;N&gt;::digits - bitset_base&lt;x&gt;::digits - 1;
<a name="l01327"></a>01327             <span class="keywordflow">if</span> (count)
<a name="l01328"></a>01328               std::memset(&amp;this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[bitset_base&lt;x&gt;::digits], 0xff, count * <span class="keyword">sizeof</span>(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>));
<a name="l01329"></a>01329             this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[bitset_base&lt;N&gt;::digits - 1] = bitset_base&lt;N&gt;::valid_bits;
<a name="l01330"></a>01330           }
<a name="l01331"></a>01331           <span class="comment">// Or invert them.</span>
<a name="l01332"></a>01332           <span class="keywordflow">if</span> (ASSIGNMENT_OPERATOR::with_ones_inverts)
<a name="l01333"></a>01333           {
<a name="l01334"></a>01334 <span class="preprocessor">#ifdef __i386__</span>
<a name="l01335"></a>01335 <span class="preprocessor"></span>            <span class="keywordtype">int</span> __d0, __d1;
<a name="l01336"></a>01336             __asm__ __volatile__ (
<a name="l01337"></a>01337                 <span class="stringliteral">&quot;xorl %4,(%1)\n\t&quot;</span>
<a name="l01338"></a>01338                 <span class="stringliteral">&quot;jecxz 2f\n\t&quot;</span>
<a name="l01339"></a>01339                 <span class="stringliteral">&quot;subl %5,%1\n&quot;</span>
<a name="l01340"></a>01340         <span class="stringliteral">&quot;1:\n\t&quot;</span>
<a name="l01341"></a>01341                 <span class="stringliteral">&quot;xorl $-1,(%1,%%ecx,4)\n\t&quot;</span>
<a name="l01342"></a>01342                 <span class="stringliteral">&quot;decl %%ecx\n\t&quot;</span>
<a name="l01343"></a>01343                 <span class="stringliteral">&quot;jnz 1b\n&quot;</span>
<a name="l01344"></a>01344         <span class="stringliteral">&quot;2:&quot;</span>
<a name="l01345"></a>01345                 : <span class="stringliteral">&quot;=&amp;c&quot;</span> (__d0), <span class="stringliteral">&quot;=&amp;r&quot;</span> (__d1)
<a name="l01346"></a>01346                 : <span class="stringliteral">&quot;0&quot;</span> (bitset_base&lt;N&gt;::digits - bitset_base&lt;x&gt;::digits - 1), <span class="stringliteral">&quot;1&quot;</span> (&amp;this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[bitset_base&lt;N&gt;::digits - 1]),
<a name="l01347"></a>01347                   <span class="stringliteral">&quot;n&quot;</span> (bitset_base&lt;N&gt;::valid_bits), <span class="stringliteral">&quot;n&quot;</span> ((bitset_base&lt;N&gt;::digits - bitset_base&lt;x&gt;::digits) * 4)
<a name="l01348"></a>01348                 : <span class="stringliteral">&quot;memory&quot;</span>, <span class="stringliteral">&quot;cc&quot;</span>
<a name="l01349"></a>01349             );
<a name="l01350"></a>01350 <span class="preprocessor">#else</span>
<a name="l01351"></a>01351 <span class="preprocessor"></span>            this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[bitset_base&lt;N&gt;::digits - 1] ^= bitset_base&lt;N&gt;::valid_bits;
<a name="l01352"></a>01352             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count = bitset_base&lt;N&gt;::digits - bitset_base&lt;x&gt;::digits;
<a name="l01353"></a>01353             <span class="keywordflow">while</span>(--count) { this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[count + bitset_base&lt;x&gt;::digits - 1] ^= ~static_cast&lt;<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>&gt;(0); }
<a name="l01354"></a>01354 <span class="preprocessor">#endif</span>
<a name="l01355"></a>01355 <span class="preprocessor"></span>          }
<a name="l01356"></a>01356         }
<a name="l01357"></a>01357       }
<a name="l01358"></a>01358 
<a name="l01359"></a>01359       <span class="comment">// Handle other digits.</span>
<a name="l01360"></a>01360 <span class="preprocessor">#ifdef __i386__</span>
<a name="l01361"></a>01361 <span class="preprocessor"></span>      LIBECC_INLINE_ASMLOOP(ASSIGNMENT_OPERATOR::id,
<a name="l01362"></a>01362           this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>, bits.digits_ptr(),
<a name="l01363"></a>01363           ((bitset_base&lt;N&gt;::digits &gt; bitset_base&lt;x&gt;::digits) ? bitset_base&lt;x&gt;::digits : bitset_base&lt;N&gt;::digits),
<a name="l01364"></a>01364           inverted_argument);
<a name="l01365"></a>01365 <span class="preprocessor">#else</span>
<a name="l01366"></a>01366 <span class="preprocessor"></span>      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d;
<a name="l01367"></a>01367       <span class="keywordflow">if</span> (bitset_base&lt;N&gt;::digits &gt; bitset_base&lt;x&gt;::digits)
<a name="l01368"></a>01368         d = bitset_base&lt;x&gt;::digits - 1;
<a name="l01369"></a>01369       <span class="keywordflow">else</span>
<a name="l01370"></a>01370         d = bitset_base&lt;N&gt;::digits - 1;
<a name="l01371"></a>01371       ASSIGNMENT_OPERATOR::exec(this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d], inverted_argument ? ~bits.rawdigit(d) : bits.rawdigit(d));
<a name="l01372"></a>01372       <span class="keywordflow">while</span>(d) { --d; ASSIGNMENT_OPERATOR::exec(this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d], inverted_argument ? ~bits.rawdigit(d) : bits.rawdigit(d)); }
<a name="l01373"></a>01373 <span class="preprocessor">#endif</span>
<a name="l01374"></a>01374 <span class="preprocessor"></span>
<a name="l01375"></a>01375       <span class="comment">// Reset excess bits if needed.</span>
<a name="l01376"></a>01376       <span class="keywordflow">if</span> (((!inverted_argument &amp;&amp; x &gt; N) ||
<a name="l01377"></a>01377             (inverted_argument &amp;&amp; bitset_base&lt;N&gt;::digits &lt;= bitset_base&lt;x&gt;::digits)) &amp;&amp;
<a name="l01378"></a>01378           bitset_base&lt;N&gt;::has_excess_bits &amp;&amp; ASSIGNMENT_OPERATOR::sets_excess_bits)
<a name="l01379"></a>01379         this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[bitset_base&lt;N&gt;::digits - 1] &amp;= bitset_base&lt;N&gt;::valid_bits;
<a name="l01380"></a>01380     }
<a name="l01381"></a>01381 
<a name="l01382"></a>01382 <span class="comment">//</span>
<a name="l01383"></a>01383 <span class="comment">// Assignment function for expressions.</span>
<a name="l01384"></a>01384 <span class="comment">// This function handles:</span>
<a name="l01385"></a>01385 <span class="comment">//</span>
<a name="l01386"></a>01386 <span class="comment">// a = b &amp; c;</span>
<a name="l01387"></a>01387 <span class="comment">// a = b &amp; ~c;</span>
<a name="l01388"></a>01388 <span class="comment">// a = ~b &amp; c;</span>
<a name="l01389"></a>01389 <span class="comment">// a = ~b &amp; ~b;</span>
<a name="l01390"></a>01390 <span class="comment">// a = b | c;</span>
<a name="l01391"></a>01391 <span class="comment">// a = b | ~c;</span>
<a name="l01392"></a>01392 <span class="comment">// a = ~b | c;</span>
<a name="l01393"></a>01393 <span class="comment">// a = ~b | ~b;</span>
<a name="l01394"></a>01394 <span class="comment">// a = b ^ c;</span>
<a name="l01395"></a>01395 <span class="comment">// a = b ^ ~c;</span>
<a name="l01396"></a>01396 <span class="comment">// a = ~b ^ c;</span>
<a name="l01397"></a>01397 <span class="comment">// a = ~b ^ ~b;</span>
<a name="l01398"></a>01398 <span class="comment">// a &amp;= b &amp; c;</span>
<a name="l01399"></a>01399 <span class="comment">// a &amp;= b &amp; ~c;</span>
<a name="l01400"></a>01400 <span class="comment">// a &amp;= ~b &amp; c;</span>
<a name="l01401"></a>01401 <span class="comment">// a &amp;= ~b &amp; ~b;</span>
<a name="l01402"></a>01402 <span class="comment">// a &amp;= b | c;</span>
<a name="l01403"></a>01403 <span class="comment">// a &amp;= b | ~c;</span>
<a name="l01404"></a>01404 <span class="comment">// a &amp;= ~b | c;</span>
<a name="l01405"></a>01405 <span class="comment">// a &amp;= ~b | ~b;</span>
<a name="l01406"></a>01406 <span class="comment">// a &amp;= b ^ c;</span>
<a name="l01407"></a>01407 <span class="comment">// a &amp;= b ^ ~c;</span>
<a name="l01408"></a>01408 <span class="comment">// a &amp;= ~b ^ c;</span>
<a name="l01409"></a>01409 <span class="comment">// a &amp;= ~b ^ ~b;</span>
<a name="l01410"></a>01410 <span class="comment">// a |= b &amp; c;</span>
<a name="l01411"></a>01411 <span class="comment">// a |= b &amp; ~c;</span>
<a name="l01412"></a>01412 <span class="comment">// a |= ~b &amp; c;</span>
<a name="l01413"></a>01413 <span class="comment">// a |= ~b &amp; ~b;</span>
<a name="l01414"></a>01414 <span class="comment">// a |= b | c;</span>
<a name="l01415"></a>01415 <span class="comment">// a |= b | ~c;</span>
<a name="l01416"></a>01416 <span class="comment">// a |= ~b | c;</span>
<a name="l01417"></a>01417 <span class="comment">// a |= ~b | ~b;</span>
<a name="l01418"></a>01418 <span class="comment">// a |= b ^ c;</span>
<a name="l01419"></a>01419 <span class="comment">// a |= b ^ ~c;</span>
<a name="l01420"></a>01420 <span class="comment">// a |= ~b ^ c;</span>
<a name="l01421"></a>01421 <span class="comment">// a |= ~b ^ ~b;</span>
<a name="l01422"></a>01422 <span class="comment">// a ^= b &amp; c;</span>
<a name="l01423"></a>01423 <span class="comment">// a ^= b &amp; ~c;</span>
<a name="l01424"></a>01424 <span class="comment">// a ^= ~b &amp; c;</span>
<a name="l01425"></a>01425 <span class="comment">// a ^= ~b &amp; ~b;</span>
<a name="l01426"></a>01426 <span class="comment">// a ^= b | c;</span>
<a name="l01427"></a>01427 <span class="comment">// a ^= b | ~c;</span>
<a name="l01428"></a>01428 <span class="comment">// a ^= ~b | c;</span>
<a name="l01429"></a>01429 <span class="comment">// a ^= ~b | ~b;</span>
<a name="l01430"></a>01430 <span class="comment">// a ^= b ^ c;</span>
<a name="l01431"></a>01431 <span class="comment">// a ^= b ^ ~c;</span>
<a name="l01432"></a>01432 <span class="comment">// a ^= ~b ^ c;</span>
<a name="l01433"></a>01433 <span class="comment">// a ^= ~b ^ ~b;</span>
<a name="l01434"></a>01434 <span class="comment">//</span>
<a name="l01435"></a>01435 <span class="comment">// ASSIGNMENT_OPERATOR is one of bitsetAssign, bitsetANDAssign, bitsetORAssign or bitsetXORAssign.</span>
<a name="l01436"></a>01436 <span class="comment">// OPERATOR is one of bitsetAND, bitsetOR or bitsetXOR.</span>
<a name="l01437"></a>01437 <span class="comment">//</span>
<a name="l01438"></a>01438 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">bool</span> inverted&gt;
<a name="l01439"></a>01439   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ASSIGNMENT_OPERATOR, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x, <span class="keywordtype">bool</span> inverted1, <span class="keywordtype">bool</span> inverted2, <span class="keyword">typename</span> OPERATOR&gt;
<a name="l01440"></a>01440     <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l01441"></a>01441     bitset_invertible&lt;N, inverted&gt;::assign(Operator::bitsetExpression&lt;x, inverted1, inverted2, OPERATOR&gt; <span class="keyword">const</span>&amp; expr, ASSIGNMENT_OPERATOR)
<a name="l01442"></a>01442     {
<a name="l01443"></a>01443       <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> argument_has_leading_ones = OPERATOR::template execbool&lt;inverted1, inverted2&gt;::value;
<a name="l01444"></a>01444 
<a name="l01445"></a>01445       <span class="comment">// Handle excess digits.</span>
<a name="l01446"></a>01446       <span class="keywordflow">if</span> (bitset_base&lt;N&gt;::digits &gt; bitset_base&lt;x&gt;::digits)
<a name="l01447"></a>01447       {
<a name="l01448"></a>01448         <span class="keywordflow">if</span> (!argument_has_leading_ones)
<a name="l01449"></a>01449         {
<a name="l01450"></a>01450           <span class="comment">// Fill excess digits with 0&#39;s when needed.</span>
<a name="l01451"></a>01451           <span class="keywordflow">if</span> (ASSIGNMENT_OPERATOR::with_zero_sets_zero)
<a name="l01452"></a>01452             std::memset(&amp;this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[bitset_base&lt;x&gt;::digits], 0, (bitset_base&lt;N&gt;::digits - bitset_base&lt;x&gt;::digits) * <span class="keyword">sizeof</span>(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>));
<a name="l01453"></a>01453         }
<a name="l01454"></a>01454         <span class="keywordflow">else</span>
<a name="l01455"></a>01455         {
<a name="l01456"></a>01456           <span class="comment">// Fill excess digits with 1&#39;s when needed.</span>
<a name="l01457"></a>01457           <span class="keywordflow">if</span> (ASSIGNMENT_OPERATOR::with_ones_sets_ones)
<a name="l01458"></a>01458           {
<a name="l01459"></a>01459             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> count = bitset_base&lt;N&gt;::digits - bitset_base&lt;x&gt;::digits - 1;
<a name="l01460"></a>01460             <span class="keywordflow">if</span> (count)
<a name="l01461"></a>01461               std::memset(&amp;this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[bitset_base&lt;x&gt;::digits], 0xff, count * <span class="keyword">sizeof</span>(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>));
<a name="l01462"></a>01462             this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[bitset_base&lt;N&gt;::digits - 1] = bitset_base&lt;N&gt;::valid_bits;
<a name="l01463"></a>01463           }
<a name="l01464"></a>01464           <span class="comment">// Or invert them.</span>
<a name="l01465"></a>01465           <span class="keywordflow">if</span> (ASSIGNMENT_OPERATOR::with_ones_inverts)
<a name="l01466"></a>01466           {
<a name="l01467"></a>01467 <span class="preprocessor">#ifdef __i386__</span>
<a name="l01468"></a>01468 <span class="preprocessor"></span>            <span class="keywordtype">int</span> __d0, __d1;
<a name="l01469"></a>01469             __asm__ __volatile__ (
<a name="l01470"></a>01470                 <span class="stringliteral">&quot;xorl %4,(%1)\n\t&quot;</span>
<a name="l01471"></a>01471                 <span class="stringliteral">&quot;jecxz 2f\n\t&quot;</span>
<a name="l01472"></a>01472                 <span class="stringliteral">&quot;subl %5,%1\n&quot;</span>
<a name="l01473"></a>01473         <span class="stringliteral">&quot;1:\n\t&quot;</span>
<a name="l01474"></a>01474                 <span class="stringliteral">&quot;xorl $-1,(%1,%%ecx,4)\n\t&quot;</span>
<a name="l01475"></a>01475                 <span class="stringliteral">&quot;decl %%ecx\n\t&quot;</span>
<a name="l01476"></a>01476                 <span class="stringliteral">&quot;jnz 1b\n&quot;</span>
<a name="l01477"></a>01477         <span class="stringliteral">&quot;2:&quot;</span>
<a name="l01478"></a>01478                 : <span class="stringliteral">&quot;=&amp;c&quot;</span> (__d0), <span class="stringliteral">&quot;=&amp;r&quot;</span> (__d1)
<a name="l01479"></a>01479                 : <span class="stringliteral">&quot;0&quot;</span> (bitset_base&lt;N&gt;::digits - bitset_base&lt;x&gt;::digits - 1), <span class="stringliteral">&quot;1&quot;</span> (&amp;this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[bitset_base&lt;N&gt;::digits - 1]),
<a name="l01480"></a>01480                   <span class="stringliteral">&quot;n&quot;</span> (bitset_base&lt;N&gt;::valid_bits), <span class="stringliteral">&quot;n&quot;</span> ((bitset_base&lt;N&gt;::digits - bitset_base&lt;x&gt;::digits) * 4)
<a name="l01481"></a>01481                 : <span class="stringliteral">&quot;memory&quot;</span>, <span class="stringliteral">&quot;cc&quot;</span>
<a name="l01482"></a>01482             );
<a name="l01483"></a>01483 <span class="preprocessor">#else</span>
<a name="l01484"></a>01484 <span class="preprocessor"></span>            this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[bitset_base&lt;N&gt;::digits - 1] ^= bitset_base&lt;N&gt;::valid_bits;
<a name="l01485"></a>01485             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count = bitset_base&lt;N&gt;::digits - bitset_base&lt;x&gt;::digits;
<a name="l01486"></a>01486             <span class="keywordflow">while</span>(--count) { this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[count + bitset_base&lt;x&gt;::digits - 1] ^= ~static_cast&lt;<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>&gt;(0); }
<a name="l01487"></a>01487 <span class="preprocessor">#endif</span>
<a name="l01488"></a>01488 <span class="preprocessor"></span>          }
<a name="l01489"></a>01489         }
<a name="l01490"></a>01490       }
<a name="l01491"></a>01491 
<a name="l01492"></a>01492       <span class="comment">// Handle other digits.</span>
<a name="l01493"></a>01493 <span class="preprocessor">#ifdef __i386__</span>
<a name="l01494"></a>01494 <span class="preprocessor"></span>      LIBECC_INLINE_ASMLOOP2(ASSIGNMENT_OPERATOR::id, OPERATOR, inverted1, inverted2,
<a name="l01495"></a>01495           this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>, expr.first.digits_ptr(), expr.second.digits_ptr(),
<a name="l01496"></a>01496           ((bitset_base&lt;N&gt;::digits &gt; bitset_base&lt;x&gt;::digits) ? bitset_base&lt;x&gt;::digits : bitset_base&lt;N&gt;::digits));
<a name="l01497"></a>01497 <span class="preprocessor">#else</span>
<a name="l01498"></a>01498 <span class="preprocessor"></span>      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d;
<a name="l01499"></a>01499       <span class="keywordflow">if</span> (bitset_base&lt;N&gt;::digits &lt; bitset_base&lt;x&gt;::digits)
<a name="l01500"></a>01500         d = bitset_base&lt;N&gt;::digits - 1;
<a name="l01501"></a>01501       <span class="keywordflow">else</span>
<a name="l01502"></a>01502         d = bitset_base&lt;x&gt;::digits - 1;
<a name="l01503"></a>01503       <span class="keywordflow">for</span>(;;)
<a name="l01504"></a>01504       {
<a name="l01505"></a>01505         ASSIGNMENT_OPERATOR::exec(this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d],
<a name="l01506"></a>01506             OPERATOR::exec(inverted1 ? ~expr.first.rawdigit(d) : expr.first.rawdigit(d),
<a name="l01507"></a>01507                            inverted2 ? ~expr.second.rawdigit(d) : expr.second.rawdigit(d)));
<a name="l01508"></a>01508         <span class="keywordflow">if</span> (!d)
<a name="l01509"></a>01509           <span class="keywordflow">break</span>;
<a name="l01510"></a>01510         --d;
<a name="l01511"></a>01511       }
<a name="l01512"></a>01512 <span class="preprocessor">#endif</span>
<a name="l01513"></a>01513 <span class="preprocessor"></span>
<a name="l01514"></a>01514       <span class="comment">// Reset excess bits if needed.</span>
<a name="l01515"></a>01515       <span class="keywordflow">if</span> (((!argument_has_leading_ones &amp;&amp; x &gt; N) ||
<a name="l01516"></a>01516             (argument_has_leading_ones &amp;&amp; bitset_base&lt;N&gt;::digits &lt;= bitset_base&lt;x&gt;::digits)) &amp;&amp;
<a name="l01517"></a>01517           bitset_base&lt;N&gt;::has_excess_bits &amp;&amp; ASSIGNMENT_OPERATOR::sets_excess_bits)
<a name="l01518"></a>01518         this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[bitset_base&lt;N&gt;::digits - 1] &amp;= bitset_base&lt;N&gt;::valid_bits;
<a name="l01519"></a>01519     }
<a name="l01520"></a>01520 
<a name="l01547"></a>01547 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">bool</span> inverted&gt;
<a name="l01548"></a>01548   <span class="keyword">inline</span> bitset_invertible&lt;N, !inverted&gt; <span class="keyword">const</span>&amp;
<a name="l01549"></a><a class="code" href="namespacelibecc.html#a235eedb20a11ff426c5d6a1e63fe04b0">01549</a>   <a class="code" href="namespacelibecc.html#a235eedb20a11ff426c5d6a1e63fe04b0" title="Invert a bitset.">operator~</a>(<a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;N, inverted&gt;</a> <span class="keyword">const</span>&amp; bits)
<a name="l01550"></a>01550   {
<a name="l01551"></a>01551     <span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span><a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;N, !inverted&gt;</a> const*<span class="keyword">&gt;</span>(&amp;bits);
<a name="l01552"></a>01552   }
<a name="l01553"></a>01553 
<a name="l01554"></a>01554 <span class="preprocessor">#ifndef __i386__</span>
<a name="l01555"></a>01555 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01556"></a>01556   <span class="keywordtype">void</span>
<a name="l01557"></a>01557   bitset_iterator&lt;N, DIRECTION&gt;::find1_forward(<span class="keywordtype">void</span>)
<a name="l01558"></a>01558   {
<a name="l01559"></a>01559     <span class="keywordflow">if</span> (this-&gt;M_digit &lt; (<span class="keywordtype">int</span>)bitset_base&lt;N&gt;::digits - 1 || (this-&gt;M_mask &amp; bitset_base&lt;N&gt;::valid_bits))
<a name="l01560"></a>01560     {
<a name="l01561"></a>01561       <span class="keyword">register</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> mask = this-&gt;M_mask;
<a name="l01562"></a>01562       <span class="keywordflow">while</span>(!(M_bitset_ptr-&gt;rawdigit(this-&gt;M_digit) &amp; mask)) 
<a name="l01563"></a>01563       {
<a name="l01564"></a>01564         <span class="keywordflow">if</span> ((mask &lt;&lt;= 1))
<a name="l01565"></a>01565           <span class="keywordflow">continue</span>;
<a name="l01566"></a>01566         mask = 1;
<a name="l01567"></a>01567         <span class="keywordflow">while</span>(++(this-&gt;M_digit) &lt; (int)bitset_base&lt;N&gt;::digits)
<a name="l01568"></a>01568           <span class="keywordflow">if</span> (M_bitset_ptr-&gt;rawdigit(this-&gt;M_digit))
<a name="l01569"></a>01569             <span class="keywordflow">break</span>;
<a name="l01570"></a>01570         <span class="keywordflow">if</span> (this-&gt;M_digit == (<span class="keywordtype">int</span>)bitset_base&lt;N&gt;::digits)
<a name="l01571"></a>01571         {
<a name="l01572"></a>01572           this-&gt;M_digit = (N &gt;&gt; bitset_digit_bits_log2);
<a name="l01573"></a>01573           mask = <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a><span class="keyword">&gt;</span>(1) &lt;&lt; (N &amp; (bitset_digit_bits - 1));
<a name="l01574"></a>01574           <span class="keywordflow">break</span>;
<a name="l01575"></a>01575         }
<a name="l01576"></a>01576       }
<a name="l01577"></a>01577       this-&gt;M_mask = mask;
<a name="l01578"></a>01578     }
<a name="l01579"></a>01579   }
<a name="l01580"></a>01580 
<a name="l01581"></a>01581 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01582"></a>01582   <span class="keywordtype">void</span>
<a name="l01583"></a>01583   bitset_iterator&lt;N, DIRECTION&gt;::find1_backward(<span class="keywordtype">void</span>)
<a name="l01584"></a>01584   {
<a name="l01585"></a>01585     LibEccDout(dc::bitsetfind1, <span class="stringliteral">&quot;Entering find1_backward with: &quot;</span> &lt;&lt; 
<a name="l01586"></a>01586         libcwd::cwprint_using(*<span class="keyword">static_cast&lt;</span>bitset_invertible&lt;N, false&gt; const*<span class="keyword">&gt;</span>(M_bitset_ptr), &amp;<a class="code" href="classlibecc_1_1bitset__invertible.html#add8cd27ec1fdbf33c41aa617e50c4302" title="Print the bitset in binary form to os.">bitset_invertible&lt;N, false&gt;::base2_print_on</a>));
<a name="l01587"></a>01587     LibEccDout(dc::bitsetfind1, <span class="stringliteral">&quot;Input: &quot;</span> &lt;&lt; *<span class="keyword">this</span>);
<a name="l01588"></a>01588     <span class="keywordflow">if</span> (this-&gt;M_digit &gt;= 0)
<a name="l01589"></a>01589     {
<a name="l01590"></a>01590       <span class="keyword">register</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> mask = this-&gt;M_mask;
<a name="l01591"></a>01591       <span class="keywordflow">if</span> (!(M_bitset_ptr-&gt;rawdigit(this-&gt;M_digit) &amp; (mask | (mask - 1))))
<a name="l01592"></a>01592       {
<a name="l01593"></a>01593         mask = <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a><span class="keyword">&gt;</span>(1) &lt;&lt; (bitset_digit_bits - 1);
<a name="l01594"></a>01594         <span class="keywordflow">do</span>
<a name="l01595"></a>01595         {
<a name="l01596"></a>01596           <span class="keywordflow">if</span> (--(this-&gt;M_digit) &lt; 0)
<a name="l01597"></a>01597           {
<a name="l01598"></a>01598             this-&gt;M_mask = mask;
<a name="l01599"></a>01599             <span class="keywordflow">return</span>;
<a name="l01600"></a>01600           }
<a name="l01601"></a>01601         }
<a name="l01602"></a>01602         <span class="keywordflow">while</span> (!M_bitset_ptr-&gt;rawdigit(this-&gt;M_digit));
<a name="l01603"></a>01603       }
<a name="l01604"></a>01604       <span class="keywordflow">while</span>(!(M_bitset_ptr-&gt;rawdigit(this-&gt;M_digit) &amp; mask)) 
<a name="l01605"></a>01605         mask &gt;&gt;= 1;
<a name="l01606"></a>01606       this-&gt;M_mask = mask;
<a name="l01607"></a>01607     }
<a name="l01608"></a>01608     LibEccDout(dc::bitsetfind1|flush_cf, <span class="stringliteral">&quot;Output: &quot;</span> &lt;&lt; *<span class="keyword">this</span>);
<a name="l01609"></a>01609   }
<a name="l01610"></a>01610 <span class="preprocessor">#endif</span>
<a name="l01611"></a>01611 <span class="preprocessor"></span>
<a name="l01615"></a>01615 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01616"></a>01616   <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l01617"></a><a class="code" href="classlibecc_1_1bitset__iterator.html#a4b9b09473c5be7f70fd972f62bf72887">01617</a>   <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, DIRECTION&gt;::find1</a>(<span class="keywordtype">void</span>)
<a name="l01618"></a>01618   {
<a name="l01619"></a>01619     LibEccDout(dc::bitsetfind1, <span class="stringliteral">&quot;Input: &quot;</span> &lt;&lt; *<span class="keyword">this</span>);
<a name="l01620"></a>01620     LibEccDout(dc::bitsetfind1, <span class="stringliteral">&quot;Entering find1 with: &quot;</span> &lt;&lt; 
<a name="l01621"></a>01621         libcwd::cwprint_using(*<span class="keyword">static_cast&lt;</span><a class="code" href="classlibecc_1_1bitset__invertible.html">bitset_invertible&lt;N, false&gt;</a> const*<span class="keyword">&gt;</span>(M_bitset_ptr), &amp;<a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;N, false&gt;::base2_print_on</a>));
<a name="l01622"></a>01622 <span class="preprocessor">#ifdef __i386__</span>
<a name="l01623"></a>01623 <span class="preprocessor"></span>    <span class="keywordtype">int</span> bit_index, digit, ptr;
<a name="l01624"></a>01624     <span class="keywordflow">if</span> (DIRECTION == backwards_iterating)
<a name="l01625"></a>01625     {
<a name="l01626"></a>01626       __asm__ __volatile__ (
<a name="l01627"></a>01627           <span class="comment">// %eax: M_index (input) and work variable.</span>
<a name="l01628"></a>01628           <span class="comment">// %ecx: bit_index (work variable).</span>
<a name="l01629"></a>01629           <span class="comment">// %edi: &amp;M_bitset_ptr-&gt;rawdigit(M_index/32 - 1) (input) and ptr (work variable).</span>
<a name="l01630"></a>01630           <span class="comment">// %2  : digit (work variable).</span>
<a name="l01631"></a>01631 
<a name="l01632"></a>01632           <span class="comment">// Make a copy of M_index into %ecx, last time we used M_index.</span>
<a name="l01633"></a>01633           <span class="stringliteral">&quot;movl %%eax,%%ecx\n\t&quot;</span>
<a name="l01634"></a>01634           <span class="comment">// Set %eax to its correct value by deviding it by 32.</span>
<a name="l01635"></a>01635           <span class="stringliteral">&quot;sarl $5,%%eax\n\t&quot;</span>
<a name="l01636"></a>01636           <span class="comment">// Set bit_index to its correct value by taking the modulo 32 of it.</span>
<a name="l01637"></a>01637           <span class="stringliteral">&quot;andl $31,%%ecx\n\t&quot;</span>
<a name="l01638"></a>01638           <span class="comment">// If M_index is -1, do nothing.</span>
<a name="l01639"></a>01639           <span class="stringliteral">&quot;js 1f\n\t&quot;</span>
<a name="l01640"></a>01640           <span class="comment">// Copy the most significant digit, the digit with the</span>
<a name="l01641"></a>01641           <span class="comment">// bit at which we will start the search, into %2.</span>
<a name="l01642"></a>01642           <span class="comment">// digit = M_bitset_ptr-&gt;rawdigit(%eax)</span>
<a name="l01643"></a>01643           <span class="stringliteral">&quot;movl 4(%%edi),%2\n\t&quot;</span>
<a name="l01644"></a>01644           <span class="comment">// Shift this digit left until the first bit comes at position 31.</span>
<a name="l01645"></a>01645           <span class="comment">// bit_index = 31 - bit_index</span>
<a name="l01646"></a>01646           <span class="stringliteral">&quot;xorl $31,%%ecx\n\t&quot;</span>
<a name="l01647"></a>01647           <span class="comment">// digit &lt;&lt;= bit_index</span>
<a name="l01648"></a>01648           <span class="stringliteral">&quot;shll %%cl,%2\n\t&quot;</span>
<a name="l01649"></a>01649           <span class="comment">// See http://fatphil.org/x86/pentopt/19.html, chapter 19.3 for why we need the orl.</span>
<a name="l01650"></a>01650           <span class="comment">// This is not needed for the athlon for that reason, but we also need this orl</span>
<a name="l01651"></a>01651           <span class="comment">// for the case that %cl equals zero in which case the ZF is cleared!</span>
<a name="l01652"></a>01652           <span class="stringliteral">&quot;orl %2,%2\n\t&quot;</span>                       
<a name="l01653"></a>01653           <span class="comment">// If there is no bit set in the current digit, goto digit_search.</span>
<a name="l01654"></a>01654           <span class="stringliteral">&quot;jz 5f\n\t&quot;</span>
<a name="l01655"></a>01655           <span class="comment">// Search for the (next) most significant bit set.</span>
<a name="l01656"></a>01656           <span class="comment">// This is slow on i[345]86: 11 + 2*N cycles; only generates 2 uops on a pentium though.</span>
<a name="l01657"></a>01657           <span class="stringliteral">&quot;bsrl %2,%2\n\t&quot;</span>
<a name="l01658"></a>01658           <span class="comment">// Correct M_index to point to this bit.</span>
<a name="l01659"></a>01659           <span class="comment">// %eax &lt;&lt;= 5</span>
<a name="l01660"></a>01660           <span class="stringliteral">&quot;sall $5,%%eax\n\t&quot;</span>
<a name="l01661"></a>01661           <span class="comment">// %2 -= bit_index</span>
<a name="l01662"></a>01662           <span class="stringliteral">&quot;subl %%ecx,%2\n\t&quot;</span>
<a name="l01663"></a>01663           <span class="comment">// M_index = %eax + %2</span>
<a name="l01664"></a>01664           <span class="stringliteral">&quot;addl %2,%%eax\n\t&quot;</span>
<a name="l01665"></a>01665           <span class="comment">// Done.</span>
<a name="l01666"></a>01666           <span class="comment">// goto exit</span>
<a name="l01667"></a>01667           <span class="stringliteral">&quot;jmp 1f\n\t&quot;</span>
<a name="l01668"></a>01668           <span class="stringliteral">&quot;.align 16\n&quot;</span>
<a name="l01669"></a>01669        <span class="stringliteral">&quot;7:\n\t&quot;</span>                         <span class="comment">// Main loop.</span>
<a name="l01670"></a>01670           <span class="stringliteral">&quot;movl (%%edi),%2\n\t&quot;</span>
<a name="l01671"></a>01671           <span class="stringliteral">&quot;subl $4,%%edi\n\t&quot;</span>
<a name="l01672"></a>01672           <span class="stringliteral">&quot;testl %2,%2\n\t&quot;</span>
<a name="l01673"></a>01673           <span class="stringliteral">&quot;jnz 6f\n\t&quot;</span>
<a name="l01674"></a>01674        <span class="stringliteral">&quot;5:\n\t&quot;</span>                         <span class="comment">// digit_search:</span>
<a name="l01675"></a>01675           <span class="stringliteral">&quot;decl %%eax\n\t&quot;</span>
<a name="l01676"></a>01676           <span class="comment">// Repeat main loop.</span>
<a name="l01677"></a>01677           <span class="stringliteral">&quot;jns 7b\n&quot;</span>    
<a name="l01678"></a>01678        <span class="stringliteral">&quot;4:\n\t&quot;</span>                         <span class="comment">// reached_end:</span>
<a name="l01679"></a>01679           <span class="comment">// No set bit found at all.  Set M_index to -1.</span>
<a name="l01680"></a>01680           <span class="stringliteral">&quot;movl $-1,%%eax\n\t&quot;</span>
<a name="l01681"></a>01681           <span class="comment">// Done.</span>
<a name="l01682"></a>01682           <span class="comment">// goto exit</span>
<a name="l01683"></a>01683           <span class="stringliteral">&quot;jmp 1f\n&quot;</span>
<a name="l01684"></a>01684           <span class="comment">// Search for the most significant bit set in this digit.</span>
<a name="l01685"></a>01685        <span class="stringliteral">&quot;6:\n\t&quot;</span>
<a name="l01686"></a>01686           <span class="stringliteral">&quot;bsrl %2,%2\n\t&quot;</span>
<a name="l01687"></a>01687           <span class="comment">// Correct M_index to point to this bit.</span>
<a name="l01688"></a>01688           <span class="stringliteral">&quot;sall $5,%%eax\n\t&quot;</span>
<a name="l01689"></a>01689           <span class="stringliteral">&quot;addl %2,%%eax\n&quot;</span>
<a name="l01690"></a>01690        <span class="stringliteral">&quot;1:&quot;</span>                             <span class="comment">// exit:</span>
<a name="l01691"></a>01691 
<a name="l01692"></a>01692           : <span class="stringliteral">&quot;=a&quot;</span> (this-&gt;<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a>), <span class="stringliteral">&quot;=&amp;c&quot;</span> (bit_index), <span class="stringliteral">&quot;=r&quot;</span> (digit), <span class="stringliteral">&quot;=&amp;D&quot;</span> (ptr)
<a name="l01693"></a>01693           : <span class="stringliteral">&quot;0&quot;</span> (this-&gt;<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a>), <span class="stringliteral">&quot;3&quot;</span> (M_bitset_ptr-&gt;digits_ptr() - 1 + (this-&gt;<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a> &gt;&gt; 5))
<a name="l01694"></a>01694           : <span class="stringliteral">&quot;cc&quot;</span>
<a name="l01695"></a>01695       );
<a name="l01696"></a>01696     }
<a name="l01697"></a>01697     <span class="keywordflow">else</span>
<a name="l01698"></a>01698     {
<a name="l01699"></a>01699       __asm__ __volatile__ (
<a name="l01700"></a>01700           <span class="comment">// %eax: M_index (input) and work variable.</span>
<a name="l01701"></a>01701           <span class="comment">// %ecx: bit_index (work variable).</span>
<a name="l01702"></a>01702           <span class="comment">// %edi: &amp;M_bitset_ptr-&gt;rawdigit(M_index/32 + 1) (input) and ptr (work variable).</span>
<a name="l01703"></a>01703           <span class="comment">// %2  : digit (work variable).</span>
<a name="l01704"></a>01704 
<a name="l01705"></a>01705           <span class="comment">// if (M_index &gt;= N) then goto exit</span>
<a name="l01706"></a>01706           <span class="stringliteral">&quot;cmpl %6,%%eax\n\t&quot;</span>
<a name="l01707"></a>01707           <span class="stringliteral">&quot;jge 1f\n\t&quot;</span>
<a name="l01708"></a>01708           <span class="comment">// Make a copy of M_index into %ecx, last time we used M_index.</span>
<a name="l01709"></a>01709           <span class="stringliteral">&quot;movl %%eax,%%ecx\n\t&quot;</span>
<a name="l01710"></a>01710           <span class="comment">// Set %eax to its correct value by deviding it by 32.</span>
<a name="l01711"></a>01711           <span class="stringliteral">&quot;sarl $5,%%eax\n\t&quot;</span>
<a name="l01712"></a>01712           <span class="comment">// Set bit_index to its correct value by taking the modulo 32 of it.</span>
<a name="l01713"></a>01713           <span class="stringliteral">&quot;andl $31,%%ecx\n\t&quot;</span>
<a name="l01714"></a>01714           <span class="comment">// Copy the least significant digit, the digit with the</span>
<a name="l01715"></a>01715           <span class="comment">// bit at which we will start the search, into %2.</span>
<a name="l01716"></a>01716           <span class="comment">// digit = M_bitset_ptr-&gt;rawdigit(%eax)</span>
<a name="l01717"></a>01717           <span class="stringliteral">&quot;movl -4(%%edi),%2\n\t&quot;</span>
<a name="l01718"></a>01718           <span class="comment">// Shift this digit right until the first bit comes at position 0.</span>
<a name="l01719"></a>01719           <span class="comment">// digit &gt;&gt;= bit_index</span>
<a name="l01720"></a>01720           <span class="stringliteral">&quot;shrl %%cl,%2\n\t&quot;</span>
<a name="l01721"></a>01721           <span class="comment">// See http://fatphil.org/x86/pentopt/19.html, chapter 19.3 for why we need the orl.</span>
<a name="l01722"></a>01722           <span class="comment">// This is not needed for the athlon for that reason, but we also need this orl</span>
<a name="l01723"></a>01723           <span class="comment">// for the case that %cl equals zero in which case the ZF is cleared!</span>
<a name="l01724"></a>01724           <span class="stringliteral">&quot;orl %2,%2\n\t&quot;</span>                       
<a name="l01725"></a>01725           <span class="comment">// If there is no bit set in the current digit, goto digit_search.</span>
<a name="l01726"></a>01726           <span class="stringliteral">&quot;jz 5f\n\t&quot;</span>
<a name="l01727"></a>01727           <span class="comment">// Search for the (next) most significant bit set.</span>
<a name="l01728"></a>01728           <span class="comment">// This is slow on i[345]86: 11 + 2*N cycles; only generates 2 uops on a pentium though.</span>
<a name="l01729"></a>01729           <span class="stringliteral">&quot;bsfl %2,%2\n\t&quot;</span>
<a name="l01730"></a>01730           <span class="comment">// Correct M_index to point to this bit.</span>
<a name="l01731"></a>01731           <span class="comment">// %eax &lt;&lt;= 5</span>
<a name="l01732"></a>01732           <span class="stringliteral">&quot;sall $5,%%eax\n\t&quot;</span>
<a name="l01733"></a>01733           <span class="comment">// %2 -= bit_index</span>
<a name="l01734"></a>01734           <span class="stringliteral">&quot;addl %%ecx,%2\n\t&quot;</span>
<a name="l01735"></a>01735           <span class="comment">// M_index = %eax + %2</span>
<a name="l01736"></a>01736           <span class="stringliteral">&quot;addl %2,%%eax\n\t&quot;</span>
<a name="l01737"></a>01737           <span class="comment">// Done.</span>
<a name="l01738"></a>01738           <span class="comment">// goto exit</span>
<a name="l01739"></a>01739           <span class="stringliteral">&quot;jmp 1f\n\t&quot;</span>
<a name="l01740"></a>01740           <span class="stringliteral">&quot;.align 16\n&quot;</span>
<a name="l01741"></a>01741        <span class="stringliteral">&quot;7:\n\t&quot;</span>                         <span class="comment">// Main loop.</span>
<a name="l01742"></a>01742           <span class="stringliteral">&quot;movl (%%edi),%2\n\t&quot;</span>
<a name="l01743"></a>01743           <span class="stringliteral">&quot;addl $4,%%edi\n\t&quot;</span>
<a name="l01744"></a>01744           <span class="stringliteral">&quot;testl %2,%2\n\t&quot;</span>
<a name="l01745"></a>01745           <span class="stringliteral">&quot;jnz 6f\n\t&quot;</span>
<a name="l01746"></a>01746        <span class="stringliteral">&quot;5:\n\t&quot;</span>                         <span class="comment">// digit_search:</span>
<a name="l01747"></a>01747           <span class="stringliteral">&quot;incl %%eax\n\t&quot;</span>
<a name="l01748"></a>01748           <span class="stringliteral">&quot;cmpl %7, %%eax\n\t&quot;</span>
<a name="l01749"></a>01749           <span class="comment">// Repeat main loop.</span>
<a name="l01750"></a>01750           <span class="stringliteral">&quot;jnz 7b\n&quot;</span>            
<a name="l01751"></a>01751        <span class="stringliteral">&quot;4:\n\t&quot;</span>                         <span class="comment">// reached_end:</span>
<a name="l01752"></a>01752           <span class="comment">// No set bit found at all.  Set M_index to N.</span>
<a name="l01753"></a>01753           <span class="stringliteral">&quot;movl %6,%%eax\n\t&quot;</span>
<a name="l01754"></a>01754           <span class="comment">// Done.</span>
<a name="l01755"></a>01755           <span class="comment">// goto exit</span>
<a name="l01756"></a>01756           <span class="stringliteral">&quot;jmp 1f\n&quot;</span>
<a name="l01757"></a>01757           <span class="comment">// Search for the least significant bit set in this digit.</span>
<a name="l01758"></a>01758        <span class="stringliteral">&quot;6:\n\t&quot;</span>
<a name="l01759"></a>01759           <span class="stringliteral">&quot;bsfl %2,%2\n\t&quot;</span>
<a name="l01760"></a>01760           <span class="comment">// Correct M_index to point to this bit.</span>
<a name="l01761"></a>01761           <span class="stringliteral">&quot;sall $5,%%eax\n\t&quot;</span>
<a name="l01762"></a>01762           <span class="stringliteral">&quot;addl %2,%%eax\n&quot;</span>
<a name="l01763"></a>01763        <span class="stringliteral">&quot;1:&quot;</span>                             <span class="comment">// exit:</span>
<a name="l01764"></a>01764 
<a name="l01765"></a>01765           : <span class="stringliteral">&quot;=a&quot;</span> (this-&gt;<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a>), <span class="stringliteral">&quot;=&amp;c&quot;</span> (bit_index), <span class="stringliteral">&quot;=r&quot;</span> (digit), <span class="stringliteral">&quot;=&amp;D&quot;</span> (ptr)
<a name="l01766"></a>01766           : <span class="stringliteral">&quot;0&quot;</span> (this-&gt;<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a>), <span class="stringliteral">&quot;3&quot;</span> (M_bitset_ptr-&gt;digits_ptr() + 1 + (this-&gt;<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a> &gt;&gt; 5)),
<a name="l01767"></a>01767             <span class="stringliteral">&quot;n&quot;</span> (N), <span class="stringliteral">&quot;n&quot;</span> (bitset_base&lt;N&gt;::digits)
<a name="l01768"></a>01768           : <span class="stringliteral">&quot;cc&quot;</span>
<a name="l01769"></a>01769       );
<a name="l01770"></a>01770     }
<a name="l01771"></a>01771 <span class="preprocessor">#else</span>
<a name="l01772"></a>01772 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (DIRECTION == forwards_iterating)
<a name="l01773"></a>01773       find1_forward();
<a name="l01774"></a>01774     <span class="keywordflow">else</span>
<a name="l01775"></a>01775       find1_backward();
<a name="l01776"></a>01776 <span class="preprocessor">#endif</span>
<a name="l01777"></a>01777 <span class="preprocessor"></span>    LibEccDout(dc::bitsetfind1|flush_cf, <span class="stringliteral">&quot;Output: &quot;</span> &lt;&lt; *<span class="keyword">this</span>);
<a name="l01778"></a>01778     <span class="keywordflow">return</span>;
<a name="l01779"></a>01779   }
<a name="l01780"></a>01780 
<a name="l01781"></a>01781 
<a name="l01785"></a>01785 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01786"></a>01786   <span class="keyword">inline</span>
<a name="l01787"></a><a class="code" href="classlibecc_1_1bitset__iterator.html#a97ac4cb1546799266c1daa2dfd8485be">01787</a>   <a class="code" href="classlibecc_1_1bitset__iterator.html#a97ac4cb1546799266c1daa2dfd8485be" title="Construct uninitialized bitset iterator.">bitset_iterator&lt;N, DIRECTION&gt;::bitset_iterator</a>(<span class="keywordtype">void</span>)
<a name="l01788"></a>01788   {
<a name="l01789"></a>01789   }
<a name="l01790"></a>01790 
<a name="l01794"></a>01794 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01795"></a>01795   <span class="keyword">inline</span>
<a name="l01796"></a><a class="code" href="classlibecc_1_1bitset__iterator.html#af5f2f7bcd4827f8b210a944874ed9888">01796</a>   <a class="code" href="classlibecc_1_1bitset__iterator.html#a97ac4cb1546799266c1daa2dfd8485be" title="Construct uninitialized bitset iterator.">bitset_iterator&lt;N, DIRECTION&gt;::bitset_iterator</a>(<a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;</a> <span class="keyword">const</span>* bitset_ptr, <span class="keywordtype">int</span> bit) :
<a name="l01797"></a>01797       <a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator</a>&lt;DIRECTION&gt;(bit), M_bitset_ptr(bitset_ptr)
<a name="l01798"></a>01798   {
<a name="l01799"></a>01799   }
<a name="l01800"></a>01800 
<a name="l01804"></a>01804 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01805"></a>01805   <span class="keyword">inline</span>
<a name="l01806"></a><a class="code" href="classlibecc_1_1bitset__iterator.html#a4e99b076b7b634285d5f0bdb9491038c">01806</a>   <a class="code" href="classlibecc_1_1bitset__iterator.html#a97ac4cb1546799266c1daa2dfd8485be" title="Construct uninitialized bitset iterator.">bitset_iterator&lt;N, DIRECTION&gt;::bitset_iterator</a>(<a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a> <span class="keyword">const</span>&amp; iter) :
<a name="l01807"></a>01807       <a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator</a>&lt;DIRECTION&gt;(iter), M_bitset_ptr(iter.M_bitset_ptr)
<a name="l01808"></a>01808   {
<a name="l01809"></a>01809   }
<a name="l01810"></a>01810 
<a name="l01814"></a>01814 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01815"></a>01815   <span class="keyword">inline</span> <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, DIRECTION&gt;</a>&amp;
<a name="l01816"></a><a class="code" href="classlibecc_1_1bitset__iterator.html#accae9dfd64443671078b59da557796cd">01816</a>   <a class="code" href="classlibecc_1_1bitset__iterator.html#accae9dfd64443671078b59da557796cd" title="Assignment operator.">bitset_iterator&lt;N, DIRECTION&gt;::operator=</a>(<a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, DIRECTION&gt;</a> <span class="keyword">const</span>&amp; iter)
<a name="l01817"></a>01817   {
<a name="l01818"></a>01818 <span class="preprocessor">#ifdef __i386__</span>
<a name="l01819"></a>01819 <span class="preprocessor"></span>    this-&gt;<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a> = iter.<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a>;
<a name="l01820"></a>01820 <span class="preprocessor">#else</span>
<a name="l01821"></a>01821 <span class="preprocessor"></span>    this-&gt;M_digit = iter.M_digit;
<a name="l01822"></a>01822     this-&gt;M_mask = iter.M_mask;
<a name="l01823"></a>01823 <span class="preprocessor">#endif</span>
<a name="l01824"></a>01824 <span class="preprocessor"></span>    M_bitset_ptr = iter.M_bitset_ptr;
<a name="l01825"></a>01825     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01826"></a>01826   }
<a name="l01827"></a>01827 
<a name="l01828"></a>01828 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01829"></a>01829   <span class="keyword">inline</span> <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, DIRECTION&gt;</a>&amp;
<a name="l01830"></a>01830   <a class="code" href="classlibecc_1_1bitset__iterator.html#accae9dfd64443671078b59da557796cd" title="Assignment operator.">bitset_iterator&lt;N, DIRECTION&gt;::operator=</a>(<a class="code" href="classlibecc_1_1bitset__index__iterator.html" title="A bitset index with increment/decrement methods.">bitset_index_iterator&lt;DIRECTION&gt;</a> <span class="keyword">const</span>&amp; index)
<a name="l01831"></a>01831   {
<a name="l01832"></a>01832 <span class="preprocessor">#ifdef __i386__</span>
<a name="l01833"></a>01833 <span class="preprocessor"></span>    this-&gt;<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a> = index.<a class="code" href="classlibecc_1_1bitset__index.html#ad97d9d24247e358eb528fd82b41976df">get_index</a>();
<a name="l01834"></a>01834 <span class="preprocessor">#else</span>
<a name="l01835"></a>01835 <span class="preprocessor"></span>    this-&gt;M_digit = index.get_digit();
<a name="l01836"></a>01836     this-&gt;M_mask = index.get_mask();
<a name="l01837"></a>01837 <span class="preprocessor">#endif</span>
<a name="l01838"></a>01838 <span class="preprocessor"></span>    <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01839"></a>01839   }
<a name="l01840"></a>01840 
<a name="l01844"></a>01844 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01845"></a>01845   <span class="keyword">inline</span> bitset_iterator&lt;N, DIRECTION&gt;&amp;
<a name="l01846"></a><a class="code" href="classlibecc_1_1bitset__iterator.html#a18a2223300db3bb6a5055d8034e6f0c6">01846</a>   <a class="code" href="classlibecc_1_1bitset__iterator.html#a18a2223300db3bb6a5055d8034e6f0c6" title="Preincrement.">bitset_iterator&lt;N, DIRECTION&gt;::operator++</a>()
<a name="l01847"></a>01847   {
<a name="l01848"></a>01848     this-&gt;<a class="code" href="classlibecc_1_1bitset__index__iterator.html#ac9b8e11ec8aea7cceb114c11c8f25d06" title="Advance to the next bit.">increment</a>();
<a name="l01849"></a>01849     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01850"></a>01850   }
<a name="l01851"></a>01851 
<a name="l01855"></a>01855 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01856"></a>01856   <span class="keyword">inline</span> <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, DIRECTION&gt;</a>
<a name="l01857"></a><a class="code" href="classlibecc_1_1bitset__iterator.html#a42a8aa123c5836e1fdc4868179cf8804">01857</a>   <a class="code" href="classlibecc_1_1bitset__iterator.html#a18a2223300db3bb6a5055d8034e6f0c6" title="Preincrement.">bitset_iterator&lt;N, DIRECTION&gt;::operator++</a>(<span class="keywordtype">int</span>)
<a name="l01858"></a>01858   {
<a name="l01859"></a>01859     <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a> prev(*<span class="keyword">this</span>);
<a name="l01860"></a>01860     this-&gt;<a class="code" href="classlibecc_1_1bitset__index__iterator.html#ac9b8e11ec8aea7cceb114c11c8f25d06" title="Advance to the next bit.">increment</a>();
<a name="l01861"></a>01861     <span class="keywordflow">return</span> prev;
<a name="l01862"></a>01862   }
<a name="l01863"></a>01863 
<a name="l01867"></a>01867 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01868"></a>01868   <span class="keyword">inline</span> <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, DIRECTION&gt;</a>&amp;
<a name="l01869"></a><a class="code" href="classlibecc_1_1bitset__iterator.html#a60249dc7d3d1a0082f6231a16d6a6bff">01869</a>   <a class="code" href="classlibecc_1_1bitset__iterator.html#a60249dc7d3d1a0082f6231a16d6a6bff" title="Predecrement.">bitset_iterator&lt;N, DIRECTION&gt;::operator--</a>()
<a name="l01870"></a>01870   {
<a name="l01871"></a>01871     this-&gt;<a class="code" href="classlibecc_1_1bitset__index__iterator.html#a138672930b0bc541f15c946f15766b9c" title="Backup to the previous bit.">decrement</a>();
<a name="l01872"></a>01872     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01873"></a>01873   }
<a name="l01874"></a>01874 
<a name="l01878"></a>01878 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01879"></a>01879   <span class="keyword">inline</span> <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, DIRECTION&gt;</a>
<a name="l01880"></a><a class="code" href="classlibecc_1_1bitset__iterator.html#af342bf4cda51559b360a6b226a672676">01880</a>   <a class="code" href="classlibecc_1_1bitset__iterator.html#a60249dc7d3d1a0082f6231a16d6a6bff" title="Predecrement.">bitset_iterator&lt;N, DIRECTION&gt;::operator--</a>(<span class="keywordtype">int</span>)
<a name="l01881"></a>01881   {
<a name="l01882"></a>01882     <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator</a> prev(*<span class="keyword">this</span>);
<a name="l01883"></a>01883     this-&gt;<a class="code" href="classlibecc_1_1bitset__index__iterator.html#a138672930b0bc541f15c946f15766b9c" title="Backup to the previous bit.">decrement</a>();
<a name="l01884"></a>01884     <span class="keywordflow">return</span> prev;
<a name="l01885"></a>01885   }
<a name="l01886"></a>01886 
<a name="l01893"></a>01893 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01894"></a>01894   <span class="keyword">inline</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>
<a name="l01895"></a><a class="code" href="classlibecc_1_1bitset__iterator.html#ab4bdc12c0463536e7a56b93d4d7a68e3">01895</a>   <a class="code" href="classlibecc_1_1bitset__iterator.html#ab4bdc12c0463536e7a56b93d4d7a68e3" title="Access bit as zero or bitmask.">bitset_iterator&lt;N, DIRECTION&gt;::operator*</a>()<span class="keyword"> const</span>
<a name="l01896"></a>01896 <span class="keyword"> </span>{
<a name="l01897"></a>01897 <span class="preprocessor">#ifdef __i386__</span>
<a name="l01898"></a>01898 <span class="preprocessor"></span>    <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> digit = this-&gt;<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a>;
<a name="l01899"></a>01899     <span class="keyword">register</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> mask = 1;
<a name="l01900"></a>01900     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> shift = this-&gt;<a class="code" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab" title="The bit number that this index points to.">M_index</a> &amp; (ECC_BITS - 1);
<a name="l01901"></a>01901     digit &gt;&gt;= bitset_digit_bits_log2;
<a name="l01902"></a>01902     mask &lt;&lt;= shift;
<a name="l01903"></a>01903     <span class="keywordflow">return</span> (M_bitset_ptr-&gt;rawdigit(digit) &amp; mask);
<a name="l01904"></a>01904 <span class="preprocessor">#else</span>
<a name="l01905"></a>01905 <span class="preprocessor"></span>    <span class="keywordflow">return</span> (M_bitset_ptr-&gt;rawdigit(this-&gt;M_digit) &amp; this-&gt;M_mask);
<a name="l01906"></a>01906 <span class="preprocessor">#endif</span>
<a name="l01907"></a>01907 <span class="preprocessor"></span>  }
<a name="l01908"></a>01908 
<a name="l01912"></a>01912 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01913"></a>01913   <span class="keyword">inline</span> <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, DIRECTION&gt;</a>&amp;
<a name="l01914"></a><a class="code" href="classlibecc_1_1bitset__iterator.html#ae1b6d3839ba058aca1abb054a6f74a51">01914</a>   <a class="code" href="classlibecc_1_1bitset__iterator.html#ae1b6d3839ba058aca1abb054a6f74a51" title="Iterator addition.">bitset_iterator&lt;N, DIRECTION&gt;::operator+=</a>(<span class="keywordtype">int</span> d)
<a name="l01915"></a>01915   {
<a name="l01916"></a>01916     this-&gt;<a class="code" href="classlibecc_1_1bitset__index__iterator.html#ac9b8e11ec8aea7cceb114c11c8f25d06" title="Advance to the next bit.">increment</a>(d);
<a name="l01917"></a>01917     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01918"></a>01918   }
<a name="l01919"></a>01919 
<a name="l01923"></a>01923 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01924"></a>01924   <span class="keyword">inline</span> <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, DIRECTION&gt;</a>&amp;
<a name="l01925"></a><a class="code" href="classlibecc_1_1bitset__iterator.html#a1481955d27fbffb3996fc0d5f7652f2e">01925</a>   <a class="code" href="classlibecc_1_1bitset__iterator.html#a1481955d27fbffb3996fc0d5f7652f2e" title="Iterator subtraction.">bitset_iterator&lt;N, DIRECTION&gt;::operator-=</a>(<span class="keywordtype">int</span> d)
<a name="l01926"></a>01926   {
<a name="l01927"></a>01927     this-&gt;<a class="code" href="classlibecc_1_1bitset__index__iterator.html#a138672930b0bc541f15c946f15766b9c" title="Backup to the previous bit.">decrement</a>(d);
<a name="l01928"></a>01928     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01929"></a>01929   }
<a name="l01930"></a>01930 
<a name="l01934"></a>01934 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01935"></a>01935   <span class="keyword">inline</span> <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, DIRECTION&gt;</a>
<a name="l01936"></a><a class="code" href="namespacelibecc.html#a36b6c0536e6dc391140e676cb2315c53">01936</a>   <a class="code" href="namespacelibecc.html#a36b6c0536e6dc391140e676cb2315c53" title="Iterator addition.">operator+</a>(<a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, DIRECTION&gt;</a> <span class="keyword">const</span>&amp; i, <span class="keywordtype">int</span> d)
<a name="l01937"></a>01937   {
<a name="l01938"></a>01938     <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, DIRECTION&gt;</a> result(i);
<a name="l01939"></a>01939     <span class="keywordflow">return</span> result += d;
<a name="l01940"></a>01940   }
<a name="l01941"></a>01941 
<a name="l01945"></a>01945 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01946"></a>01946   <span class="keyword">inline</span> bitset_iterator&lt;N, DIRECTION&gt;
<a name="l01947"></a><a class="code" href="namespacelibecc.html#a7bcecfdcf3f7e1fc4f175eb7215815a8">01947</a>   <a class="code" href="namespacelibecc.html#a36b6c0536e6dc391140e676cb2315c53" title="Iterator addition.">operator+</a>(<span class="keywordtype">int</span> d, <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, DIRECTION&gt;</a> <span class="keyword">const</span>&amp; i)
<a name="l01948"></a>01948   {
<a name="l01949"></a>01949     <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, DIRECTION&gt;</a> result(i);
<a name="l01950"></a>01950     <span class="keywordflow">return</span> result += d;
<a name="l01951"></a>01951   }
<a name="l01952"></a>01952 
<a name="l01956"></a>01956 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01957"></a>01957   <span class="keyword">inline</span> bitset_iterator&lt;N, DIRECTION&gt;
<a name="l01958"></a><a class="code" href="namespacelibecc.html#a0b71c59d918245ddafffcfcb3a823ee6">01958</a>   operator-(<a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, DIRECTION&gt;</a> <span class="keyword">const</span>&amp; i, <span class="keywordtype">int</span> d)
<a name="l01959"></a>01959   {
<a name="l01960"></a>01960     <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, DIRECTION&gt;</a> result(i);
<a name="l01961"></a>01961     <span class="keywordflow">return</span> result -= d;
<a name="l01962"></a>01962   }
<a name="l01963"></a>01963 
<a name="l01967"></a>01967 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01968"></a>01968   <span class="keyword">inline</span> bitset_iterator&lt;N, DIRECTION&gt;
<a name="l01969"></a><a class="code" href="namespacelibecc.html#ab7b21143e0373255d40d4b81a566c7bc">01969</a>   operator-(<span class="keywordtype">int</span> d, <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, DIRECTION&gt;</a> <span class="keyword">const</span>&amp; i)
<a name="l01970"></a>01970   {
<a name="l01971"></a>01971     <a class="code" href="classlibecc_1_1bitset__iterator.html" title="A non-mutable bitset-iterator.">bitset_iterator&lt;N, DIRECTION&gt;</a> result(i);
<a name="l01972"></a>01972     <span class="keywordflow">return</span> result -= d;
<a name="l01973"></a>01973   }
<a name="l01974"></a>01974 
<a name="l01978"></a>01978 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> DIRECTION&gt;
<a name="l01979"></a>01979   <span class="keyword">inline</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>
<a name="l01980"></a><a class="code" href="classlibecc_1_1bitset__iterator.html#aff852c4c0c478965f8e3624431d3a529">01980</a>   <a class="code" href="classlibecc_1_1bitset__iterator.html#aff852c4c0c478965f8e3624431d3a529" title="Element operator.">bitset_iterator&lt;N, DIRECTION&gt;::operator[]</a>(<span class="keywordtype">int</span> d)<span class="keyword"> const</span>
<a name="l01981"></a>01981 <span class="keyword"> </span>{
<a name="l01982"></a>01982     <span class="keywordflow">return</span> *(*<span class="keyword">this</span> + d);
<a name="l01983"></a>01983   }
<a name="l01984"></a>01984 
<a name="l01985"></a>01985 <span class="comment">//--------------------------------------------------------------------------------------------------------------------------</span>
<a name="l01992"></a>01992 <span class="comment"></span><span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l01993"></a><a class="code" href="classlibecc_1_1bitset.html">01993</a>   <span class="keyword">class</span><a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset</a> : <span class="keyword">public</span> <a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible</a>&lt;N, false&gt; {
<a name="l01994"></a>01994     <span class="keyword">public</span>:
<a name="l01995"></a>01995       <span class="comment">// Constructors.</span>
<a name="l01996"></a>01996       <a class="code" href="classlibecc_1_1bitset.html#a2f7c44b72136449f89e87c9065a50453" title="Construct an uninitialized bitset of N bits.">bitset</a>(<span class="keywordtype">void</span>);
<a name="l01997"></a>01997       <a class="code" href="classlibecc_1_1bitset.html#a2f7c44b72136449f89e87c9065a50453" title="Construct an uninitialized bitset of N bits.">bitset</a>(std::string <span class="keyword">const</span>&amp;);
<a name="l01998"></a>01998       <span class="keyword">explicit</span> <a class="code" href="classlibecc_1_1bitset.html#a2f7c44b72136449f89e87c9065a50453" title="Construct an uninitialized bitset of N bits.">bitset</a>(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> low_bits);
<a name="l01999"></a>01999       <span class="comment">// This definition must be here, inside the template class declaration because</span>
<a name="l02000"></a>02000       <span class="comment">// otherwise the compiler (2.95 - 3.1) barfs.</span>
<a name="l02006"></a><a class="code" href="classlibecc_1_1bitset.html#aabd8efbff263c8de6eae78608714df1c">02006</a> <span class="comment"></span>      <a class="code" href="classlibecc_1_1bitset.html#a2f7c44b72136449f89e87c9065a50453" title="Construct an uninitialized bitset of N bits.">bitset</a>(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <span class="keyword">const</span> (&amp;v)[bitset_base&lt;N&gt;::digits])
<a name="l02007"></a>02007       {
<a name="l02008"></a>02008 <span class="preprocessor">#if ECC_DEBUG</span>
<a name="l02009"></a>02009 <span class="preprocessor"></span>        assert( (v[bitset_base&lt;N&gt;::digits - 1] &amp; ~bitset_base&lt;N&gt;::valid_bits) == 0 );
<a name="l02010"></a>02010 <span class="preprocessor">#endif</span>
<a name="l02011"></a>02011 <span class="preprocessor"></span>        std::memcpy(this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>, v, <span class="keyword">sizeof</span>(this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>));
<a name="l02012"></a>02012       }
<a name="l02013"></a>02013 
<a name="l02014"></a>02014       <span class="comment">// Copy constructors.</span>
<a name="l02015"></a>02015       <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m, <span class="keywordtype">bool</span> inverted&gt;
<a name="l02016"></a>02016         <a class="code" href="classlibecc_1_1bitset.html#a2f7c44b72136449f89e87c9065a50453" title="Construct an uninitialized bitset of N bits.">bitset</a>(<a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;m, inverted&gt;</a> <span class="keyword">const</span>&amp;);
<a name="l02017"></a>02017       <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m, <span class="keywordtype">bool</span> i1, <span class="keywordtype">bool</span> i2, <span class="keyword">typename</span> OP&gt;
<a name="l02018"></a>02018         <a class="code" href="classlibecc_1_1bitset.html#a2f7c44b72136449f89e87c9065a50453" title="Construct an uninitialized bitset of N bits.">bitset</a>(Operator::bitsetExpression&lt;m, i1, i2, OP&gt; <span class="keyword">const</span>&amp; expr);
<a name="l02019"></a>02019 
<a name="l02020"></a>02020       <span class="comment">// Assignment operators.</span>
<a name="l02021"></a>02021       <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset</a>&amp; operator=(<a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset</a> <span class="keyword">const</span>&amp;);
<a name="l02022"></a>02022       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Expression&gt;
<a name="l02023"></a>02023         <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset</a>&amp; operator=(Expression <span class="keyword">const</span>&amp;);
<a name="l02024"></a>02024 
<a name="l02025"></a>02025       <span class="comment">// Perform AND, OR, XOR operations</span>
<a name="l02026"></a>02026       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Expression&gt;
<a name="l02027"></a>02027         <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset</a>&amp; <a class="code" href="classlibecc_1_1bitset.html#ac0c6bda20427dcce74cd899bd46f43d0" title="Assignment operator with bitwise AND.">operator&amp;=</a>(Expression <span class="keyword">const</span>&amp;);
<a name="l02028"></a>02028       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Expression&gt;
<a name="l02029"></a>02029         <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset</a>&amp; <a class="code" href="classlibecc_1_1bitset.html#af6650b8defe1d4c5083405333b2171bc" title="Assignment operator with bitwise OR.">operator|=</a>(Expression <span class="keyword">const</span>&amp;);
<a name="l02030"></a>02030       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Expression&gt;
<a name="l02031"></a>02031         <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset</a>&amp; <a class="code" href="classlibecc_1_1bitset.html#a7cf1f21496f68eab1f803dc8d55402a6" title="Assignment operator with bitwise XOR.">operator^=</a>(Expression <span class="keyword">const</span>&amp;);
<a name="l02032"></a>02032 
<a name="l02033"></a>02033     <span class="keyword">public</span>:
<a name="l02034"></a>02034       <span class="comment">// Shift bitset left or right and perform operation with result.</span>
<a name="l02035"></a>02035       <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shift, <span class="keyword">class</span> DIRECTION, <span class="keyword">class</span> OPERATION&gt;
<a name="l02036"></a>02036         <span class="keywordtype">void</span> <a class="code" href="classlibecc_1_1bitset.html#a446a27809cd4cb9ed6e83629a3f328bc" title="Perform a shift operation followed by a bit operation.">shift_op</a>(<a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset</a>&amp; result) <span class="keyword">const</span>;
<a name="l02037"></a>02037 
<a name="l02039"></a><a class="code" href="classlibecc_1_1bitset.html#aa5a412d599bacae10b747be1d86f8510">02039</a>       <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset</a>&amp; <a class="code" href="classlibecc_1_1bitset.html#aa5a412d599bacae10b747be1d86f8510" title="Shift bitset shift bits to the left.&amp;nbsp; Use the faster bitset::shift_op for constant distance shif...">operator&lt;&lt;=</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shift) { this-&gt;<a class="code" href="classlibecc_1_1bitset.html#aa5a412d599bacae10b747be1d86f8510" title="Shift bitset shift bits to the left.&amp;nbsp; Use the faster bitset::shift_op for constant distance shif...">bitset_base&lt;N&gt;::operator&lt;&lt;=</a>(shift); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02041"></a><a class="code" href="classlibecc_1_1bitset.html#a12019bb8406e15d16ce7b31edc03d4ae">02041</a>       <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset</a>&amp; <a class="code" href="classlibecc_1_1bitset.html#a12019bb8406e15d16ce7b31edc03d4ae" title="Shift bitset shift bits to the right.&amp;nbsp; Use the faster bitset::shift_op for constant distance shi...">operator&gt;&gt;=</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shift) { this-&gt;<a class="code" href="classlibecc_1_1bitset.html#a12019bb8406e15d16ce7b31edc03d4ae" title="Shift bitset shift bits to the right.&amp;nbsp; Use the faster bitset::shift_op for constant distance shi...">bitset_base&lt;N&gt;::operator&gt;&gt;=</a>(shift); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02042"></a>02042 
<a name="l02043"></a>02043       <span class="comment">// Rotate left or right</span>
<a name="l02044"></a>02044       <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shift, <span class="keyword">class</span> DIRECTION&gt;                     <span class="comment">// Return a copy rotated `shift&#39; bits in `DIRECTION&#39;.</span>
<a name="l02045"></a>02045         <span class="keywordtype">void</span> <a class="code" href="classlibecc_1_1bitset.html#a67f603a1483afc9aee7fd9d076bc2c71" title="Rotate bitset.">rotate</a>(<a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset</a>&amp; result) <span class="keyword">const</span>;
<a name="l02046"></a>02046   };
<a name="l02047"></a>02047 
<a name="l02051"></a>02051 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02052"></a>02052   <span class="keyword">inline</span>
<a name="l02053"></a><a class="code" href="classlibecc_1_1bitset.html#a2f7c44b72136449f89e87c9065a50453">02053</a>   <a class="code" href="classlibecc_1_1bitset.html#a2f7c44b72136449f89e87c9065a50453" title="Construct an uninitialized bitset of N bits.">bitset&lt;N&gt;::bitset</a>(<span class="keywordtype">void</span>)
<a name="l02054"></a>02054   {
<a name="l02055"></a>02055   }
<a name="l02056"></a>02056 
<a name="l02062"></a>02062 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02063"></a>02063   <span class="keyword">inline</span>
<a name="l02064"></a><a class="code" href="classlibecc_1_1bitset.html#a16bd92d1be8fae9482e0058a8a7f8091">02064</a>   <a class="code" href="classlibecc_1_1bitset.html#a2f7c44b72136449f89e87c9065a50453" title="Construct an uninitialized bitset of N bits.">bitset&lt;N&gt;::bitset</a>(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> low_bits)
<a name="l02065"></a>02065   {
<a name="l02066"></a>02066 <span class="preprocessor">#if ECC_DEBUG</span>
<a name="l02067"></a>02067 <span class="preprocessor"></span>    assert( bitset_base&lt;N&gt;::digits &gt; 1 || (low_bits &amp; ~bitset_base&lt;N&gt;::valid_bits) == 0 );
<a name="l02068"></a>02068 <span class="preprocessor">#endif</span>
<a name="l02069"></a>02069 <span class="preprocessor"></span>    std::memset(this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>, 0, <span class="keyword">sizeof</span>(this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>));
<a name="l02070"></a>02070     this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[0] = low_bits;
<a name="l02071"></a>02071   }
<a name="l02072"></a>02072 
<a name="l02076"></a>02076 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02077"></a>02077   <span class="keywordtype">void</span>
<a name="l02078"></a><a class="code" href="structlibecc_1_1bitset__base.html#af61ddb78b0980f28e6262160f88bf38e">02078</a>   <a class="code" href="structlibecc_1_1bitset__base.html#af61ddb78b0980f28e6262160f88bf38e" title="Set all bits to 1.">bitset_base&lt;N&gt;::setall</a>(<span class="keywordtype">void</span>)
<a name="l02079"></a>02079   {
<a name="l02080"></a>02080     this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[bitset_base&lt;N&gt;::digits - 1] = bitset_base&lt;N&gt;::valid_bits;
<a name="l02081"></a>02081     <span class="keywordflow">if</span> (bitset_base&lt;N&gt;::digits &gt; 1)
<a name="l02082"></a>02082     {
<a name="l02083"></a>02083       <span class="keywordtype">int</span> d = bitset_base&lt;N&gt;::digits - 2;
<a name="l02084"></a>02084       <span class="keywordflow">do</span> { this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d] = ~static_cast&lt;<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>&gt;(0); } <span class="keywordflow">while</span>(--d &gt;= 0);
<a name="l02085"></a>02085     }
<a name="l02086"></a>02086   }
<a name="l02087"></a>02087 
<a name="l02112"></a>02112 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02113"></a>02113   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Expression&gt;
<a name="l02114"></a>02114     <span class="keyword">inline</span>
<a name="l02115"></a><a class="code" href="classlibecc_1_1bitset.html#a810b912f226ec3df16eb4bba784f387c">02115</a>     <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset&lt;N&gt;</a>&amp; <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset&lt;N&gt;::operator=</a>(Expression <span class="keyword">const</span>&amp; expr)
<a name="l02116"></a>02116     {
<a name="l02117"></a>02117       this-&gt;<a class="code" href="structlibecc_1_1assign.html" title="Operation used with libecc::bitset::shift_op.">assign</a>(expr, Operator::bitsetAssign());
<a name="l02118"></a>02118       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02119"></a>02119     }
<a name="l02120"></a>02120 
<a name="l02121"></a>02121 <span class="comment">// Special case, need to define this or else we&#39;d get a default assignment operator.</span>
<a name="l02122"></a>02122 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02123"></a>02123   <span class="keyword">inline</span> <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset&lt;N&gt;</a>&amp;
<a name="l02124"></a>02124   <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset&lt;N&gt;::operator=</a>(<a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset</a> <span class="keyword">const</span>&amp; expr)
<a name="l02125"></a>02125   {
<a name="l02126"></a>02126     this-&gt;<a class="code" href="structlibecc_1_1assign.html" title="Operation used with libecc::bitset::shift_op.">assign</a>(expr, Operator::bitsetAssign());
<a name="l02127"></a>02127     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02128"></a>02128   }
<a name="l02129"></a>02129 
<a name="l02146"></a>02146 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02147"></a>02147   <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m, <span class="keywordtype">bool</span> inverted&gt;
<a name="l02148"></a><a class="code" href="classlibecc_1_1bitset.html#a64e4720ffb677ab4fc72306407a58f87">02148</a>     <span class="keyword">inline</span> <a class="code" href="classlibecc_1_1bitset.html#a2f7c44b72136449f89e87c9065a50453" title="Construct an uninitialized bitset of N bits.">bitset&lt;N&gt;::bitset</a>(<a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;m, inverted&gt;</a> <span class="keyword">const</span>&amp; bits) : <a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible</a>&lt;N, false&gt;(bits)
<a name="l02149"></a>02149     {
<a name="l02150"></a>02150     }
<a name="l02151"></a>02151 
<a name="l02157"></a>02157 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02158"></a>02158   <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m, <span class="keywordtype">bool</span> i1, <span class="keywordtype">bool</span> i2, <span class="keyword">typename</span> OP&gt;
<a name="l02159"></a><a class="code" href="classlibecc_1_1bitset.html#a7d9babce747d7cd2ea411c42525b6db3">02159</a>     <span class="keyword">inline</span> <a class="code" href="classlibecc_1_1bitset.html#a2f7c44b72136449f89e87c9065a50453" title="Construct an uninitialized bitset of N bits.">bitset&lt;N&gt;::bitset</a>(Operator::bitsetExpression&lt;m, i1, i2, OP&gt; <span class="keyword">const</span>&amp; expr) : <a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible</a>&lt;N, false&gt;(expr)
<a name="l02160"></a>02160     {
<a name="l02161"></a>02161     }
<a name="l02162"></a>02162 
<a name="l02174"></a>02174 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n1, <span class="keywordtype">bool</span> inverted1, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n2, <span class="keywordtype">bool</span> inverted2&gt;
<a name="l02175"></a><a class="code" href="namespacelibecc.html#a342f4385a37ad89ff8b7d965392effb6">02175</a>   <span class="keywordtype">bool</span> <a class="code" href="namespacelibecc.html#a20e07c996961c9c66d64359e77443df4" title="Equality operator.">operator==</a>(<a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;n1, inverted1&gt;</a> <span class="keyword">const</span>&amp; bits1, <a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;n2, inverted2&gt;</a> <span class="keyword">const</span>&amp; bits2)
<a name="l02176"></a>02176   {
<a name="l02177"></a>02177     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d;
<a name="l02178"></a>02178     <span class="keywordflow">if</span> (<a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;n1, inverted1&gt;::digits</a> &gt; <a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;n2, inverted2&gt;::digits</a>)
<a name="l02179"></a>02179     {
<a name="l02180"></a>02180       d = <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;n1&gt;::digits</a> - 1;
<a name="l02181"></a>02181       <span class="keywordflow">do</span>
<a name="l02182"></a>02182       {
<a name="l02183"></a>02183         <span class="keywordflow">if</span> (bits1.<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d] != (inverted1 == inverted2 ? 0 : ~static_cast&lt;bitset_digit_t&gt;(0)))
<a name="l02184"></a>02184           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02185"></a>02185       }
<a name="l02186"></a>02186       <span class="keywordflow">while</span> (--d != <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;n2&gt;::digits</a> - 1);
<a name="l02187"></a>02187     }
<a name="l02188"></a>02188     <span class="keywordflow">if</span> (<a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;n2&gt;::digits</a> &gt; <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;n1&gt;::digits</a>)
<a name="l02189"></a>02189     {
<a name="l02190"></a>02190       d = <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;n2&gt;::digits</a> - 1;
<a name="l02191"></a>02191       <span class="keywordflow">do</span>
<a name="l02192"></a>02192       {
<a name="l02193"></a>02193         <span class="keywordflow">if</span> (bits2.<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d] != (inverted1 == inverted2 ? 0 : ~static_cast&lt;bitset_digit_t&gt;(0)))
<a name="l02194"></a>02194           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02195"></a>02195       }
<a name="l02196"></a>02196       <span class="keywordflow">while</span> (--d != <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;n1&gt;::digits</a> - 1);
<a name="l02197"></a>02197     }
<a name="l02198"></a>02198     <span class="keywordflow">if</span> (<a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;n1&gt;::digits</a> &gt; 1 &amp;&amp; <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;n2&gt;::digits</a> &gt; 1)
<a name="l02199"></a>02199     {
<a name="l02200"></a>02200       <span class="keywordflow">if</span> (<a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;n1&gt;::digits</a> == <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;n2&gt;::digits</a>)
<a name="l02201"></a>02201         d = <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;n1&gt;::digits</a> - 1;
<a name="l02202"></a>02202       <span class="keywordflow">do</span>
<a name="l02203"></a>02203       {
<a name="l02204"></a>02204         <span class="keywordflow">if</span> (inverted1 == inverted2)
<a name="l02205"></a>02205         {
<a name="l02206"></a>02206           <span class="keywordflow">if</span> (bits1.<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d] != bits2.<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d])
<a name="l02207"></a>02207             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02208"></a>02208         }
<a name="l02209"></a>02209         <span class="keywordflow">else</span>
<a name="l02210"></a>02210         {
<a name="l02211"></a>02211           <span class="keywordflow">if</span> (bits1.<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d] != ~(bits2.<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d]))
<a name="l02212"></a>02212             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02213"></a>02213         }
<a name="l02214"></a>02214       }
<a name="l02215"></a>02215       <span class="keywordflow">while</span>(--d != 0);
<a name="l02216"></a>02216     }
<a name="l02217"></a>02217     <span class="keywordflow">if</span> (inverted1 != inverted2)
<a name="l02218"></a>02218       <span class="keywordflow">return</span> (bits1.<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[0] == ~(bits2.<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[0]));
<a name="l02219"></a>02219     <span class="keywordflow">return</span> (bits1.<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[0] == bits2.<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[0]);
<a name="l02220"></a>02220   }
<a name="l02221"></a>02221 
<a name="l02227"></a>02227 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n1, <span class="keywordtype">bool</span> inverted1, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n2, <span class="keywordtype">bool</span> inverted2&gt;
<a name="l02228"></a>02228   <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l02229"></a><a class="code" href="namespacelibecc.html#ae9b836e6e5fa4c0089f9c6dda286e03b">02229</a>   <a class="code" href="namespacelibecc.html#ac394825c0221d5171fe495fb4cac3ef2" title="Inequality operator.">operator!=</a>(<a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;n1, inverted1&gt;</a> <span class="keyword">const</span>&amp; bits1, <a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;n2, inverted2&gt;</a> <span class="keyword">const</span>&amp; bits2)
<a name="l02230"></a>02230   {
<a name="l02231"></a>02231     <span class="keywordflow">return</span> !(bits1 == bits2);
<a name="l02232"></a>02232   }
<a name="l02233"></a>02233 
<a name="l02238"></a>02238 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02239"></a>02239   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Expression&gt;
<a name="l02240"></a>02240     <span class="keyword">inline</span> bitset&lt;N&gt;&amp;
<a name="l02241"></a><a class="code" href="classlibecc_1_1bitset.html#ac0c6bda20427dcce74cd899bd46f43d0">02241</a>     <a class="code" href="classlibecc_1_1bitset.html#ac0c6bda20427dcce74cd899bd46f43d0" title="Assignment operator with bitwise AND.">bitset&lt;N&gt;::operator&amp;=</a>(Expression <span class="keyword">const</span>&amp; expr)
<a name="l02242"></a>02242     {
<a name="l02243"></a>02243       this-&gt;<a class="code" href="structlibecc_1_1assign.html" title="Operation used with libecc::bitset::shift_op.">assign</a>(expr, Operator::bitsetANDAssign());
<a name="l02244"></a>02244       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02245"></a>02245     }
<a name="l02246"></a>02246 
<a name="l02251"></a>02251 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02252"></a>02252   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Expression&gt;
<a name="l02253"></a>02253     <span class="keyword">inline</span> <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset&lt;N&gt;</a>&amp;
<a name="l02254"></a><a class="code" href="classlibecc_1_1bitset.html#af6650b8defe1d4c5083405333b2171bc">02254</a>     <a class="code" href="classlibecc_1_1bitset.html#af6650b8defe1d4c5083405333b2171bc" title="Assignment operator with bitwise OR.">bitset&lt;N&gt;::operator|=</a>(Expression <span class="keyword">const</span>&amp; expr)
<a name="l02255"></a>02255     {
<a name="l02256"></a>02256       this-&gt;<a class="code" href="structlibecc_1_1assign.html" title="Operation used with libecc::bitset::shift_op.">assign</a>(expr, Operator::bitsetORAssign());
<a name="l02257"></a>02257       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02258"></a>02258     }
<a name="l02259"></a>02259 
<a name="l02264"></a>02264 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02265"></a>02265   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Expression&gt;
<a name="l02266"></a>02266     <span class="keyword">inline</span> <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset&lt;N&gt;</a>&amp;
<a name="l02267"></a><a class="code" href="classlibecc_1_1bitset.html#a7cf1f21496f68eab1f803dc8d55402a6">02267</a>     <a class="code" href="classlibecc_1_1bitset.html#a7cf1f21496f68eab1f803dc8d55402a6" title="Assignment operator with bitwise XOR.">bitset&lt;N&gt;::operator^=</a>(Expression <span class="keyword">const</span>&amp; expr)
<a name="l02268"></a>02268     {
<a name="l02269"></a>02269       this-&gt;<a class="code" href="structlibecc_1_1assign.html" title="Operation used with libecc::bitset::shift_op.">assign</a>(expr, Operator::bitsetXORAssign());
<a name="l02270"></a>02270       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02271"></a>02271     }
<a name="l02272"></a>02272 
<a name="l02277"></a>02277 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m, <span class="keywordtype">bool</span> inverted1, <span class="keywordtype">bool</span> inverted2&gt;
<a name="l02278"></a>02278   Operator::bitsetExpression&lt;m, inverted1, inverted2, Operator::bitsetAND&gt;
<a name="l02279"></a><a class="code" href="namespacelibecc.html#aadbb5397d68c20d4082c181578d17ed0">02279</a>   <a class="code" href="namespacelibecc.html#aadbb5397d68c20d4082c181578d17ed0" title="Assignment operator with bitwise AND for expressions.">operator&amp;</a>(<a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;m, inverted1&gt;</a> <span class="keyword">const</span>&amp; arg1, <a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;m, inverted2&gt;</a> <span class="keyword">const</span>&amp; arg2)
<a name="l02280"></a>02280     {
<a name="l02281"></a>02281       <span class="keywordflow">return</span> Operator::bitsetExpression&lt;m, inverted1, inverted2, Operator::bitsetAND&gt;(arg1, arg2);
<a name="l02282"></a>02282     }
<a name="l02283"></a>02283 
<a name="l02288"></a>02288 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m, <span class="keywordtype">bool</span> inverted1, <span class="keywordtype">bool</span> inverted2&gt;
<a name="l02289"></a>02289   Operator::bitsetExpression&lt;m, inverted1, inverted2, Operator::bitsetOR&gt;
<a name="l02290"></a><a class="code" href="namespacelibecc.html#a9c3499b2519e3394ff9fe3260bbab5e9">02290</a>   <a class="code" href="namespacelibecc.html#a9c3499b2519e3394ff9fe3260bbab5e9" title="Assignment operator with bitwise OR for expressions.">operator|</a>(<a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;m, inverted1&gt;</a> <span class="keyword">const</span>&amp; arg1, <a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;m, inverted2&gt;</a> <span class="keyword">const</span>&amp; arg2)
<a name="l02291"></a>02291     {
<a name="l02292"></a>02292       <span class="keywordflow">return</span> Operator::bitsetExpression&lt;m, inverted1, inverted2, Operator::bitsetOR&gt;(arg1, arg2);
<a name="l02293"></a>02293     }
<a name="l02294"></a>02294 
<a name="l02299"></a>02299 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m, <span class="keywordtype">bool</span> inverted1, <span class="keywordtype">bool</span> inverted2&gt;
<a name="l02300"></a>02300   Operator::bitsetExpression&lt;m, inverted1, inverted2, Operator::bitsetXOR&gt;
<a name="l02301"></a><a class="code" href="namespacelibecc.html#a6486d5676238ef8c129ca46cb197a989">02301</a>   <a class="code" href="namespacelibecc.html#a6486d5676238ef8c129ca46cb197a989" title="Assignment operator with bitwise XOR for expressions.">operator^</a>(<a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;m, inverted1&gt;</a> <span class="keyword">const</span>&amp; arg1, <a class="code" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&amp;#39;s...">bitset_invertible&lt;m, inverted2&gt;</a> <span class="keyword">const</span>&amp; arg2)
<a name="l02302"></a>02302     {
<a name="l02303"></a>02303       <span class="keywordflow">return</span> Operator::bitsetExpression&lt;m, inverted1, inverted2, Operator::bitsetXOR&gt;(arg1, arg2);
<a name="l02304"></a>02304     }
<a name="l02305"></a>02305 
<a name="l02309"></a><a class="code" href="structlibecc_1_1assign.html">02309</a> <span class="keyword">struct</span><a class="code" href="structlibecc_1_1assign.html" title="Operation used with libecc::bitset::shift_op.">assign</a> {
<a name="l02310"></a>02310   <span class="keyword">static</span> <span class="keywordtype">int</span> <span class="keyword">const</span> <span class="keywordtype">id</span> = 1;
<a name="l02311"></a>02311   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> __clear = <span class="keyword">true</span>;
<a name="l02312"></a>02312   <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> op(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>&amp; digit1, <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> digit2) { digit1 = digit2; }
<a name="l02313"></a>02313   <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> mixed_op(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>&amp; digit1, <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> digit2) { digit1 = digit2; }
<a name="l02314"></a>02314 };
<a name="l02315"></a>02315 
<a name="l02319"></a><a class="code" href="structlibecc_1_1exor.html">02319</a> <span class="keyword">struct</span><a class="code" href="structlibecc_1_1exor.html" title="Operation used with libecc::bitset::shift_op.">exor</a> {
<a name="l02320"></a>02320   <span class="keyword">static</span> <span class="keywordtype">int</span> <span class="keyword">const</span> <span class="keywordtype">id</span> = 2;
<a name="l02321"></a>02321   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> __clear = <span class="keyword">false</span>;
<a name="l02322"></a>02322   <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> op(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>&amp; digit1, <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> digit2) { digit1 ^= digit2; }
<a name="l02323"></a>02323   <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> mixed_op(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>&amp; digit1, <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> digit2) { digit1 ^= digit2; }
<a name="l02324"></a>02324 };
<a name="l02325"></a>02325 
<a name="l02326"></a>02326 <span class="preprocessor">#ifndef HIDE_FROM_DOXYGEN</span>
<a name="l02327"></a>02327 <span class="preprocessor"></span><span class="keyword">struct</span>rotate_phase1 {
<a name="l02328"></a>02328   <span class="keyword">static</span> <span class="keywordtype">int</span> <span class="keyword">const</span> <span class="keywordtype">id</span> = 3;
<a name="l02329"></a>02329   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> __clear = <span class="keyword">false</span>;
<a name="l02330"></a>02330   <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> op(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>&amp; digit1, <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> digit2) { digit1 = digit2; }
<a name="l02331"></a>02331   <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> mixed_op(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>&amp; digit1, <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> digit2) { digit1 = digit2; }
<a name="l02332"></a>02332 };
<a name="l02333"></a>02333 
<a name="l02334"></a>02334 <span class="keyword">struct</span>rotate_phase2 {
<a name="l02335"></a>02335 <span class="keyword">public</span>:
<a name="l02336"></a>02336   <span class="keyword">static</span> <span class="keywordtype">int</span> <span class="keyword">const</span> <span class="keywordtype">id</span> = 4;
<a name="l02337"></a>02337   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> __clear = <span class="keyword">false</span>;
<a name="l02338"></a>02338   <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> op(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>&amp; digit1, <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> digit2) { digit1 = digit2; }
<a name="l02339"></a>02339   <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> mixed_op(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>&amp; digit1, <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> digit2) { digit1 |= digit2; }
<a name="l02340"></a>02340 };
<a name="l02341"></a>02341 <span class="preprocessor">#endif</span>
<a name="l02342"></a>02342 <span class="preprocessor"></span>
<a name="l02353"></a>02353 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02354"></a>02354   <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shift, <span class="keyword">class</span> DIRECTION, <span class="keyword">class</span> OPERATION&gt;
<a name="l02355"></a>02355     <span class="keywordtype">void</span>
<a name="l02356"></a><a class="code" href="classlibecc_1_1bitset.html#a446a27809cd4cb9ed6e83629a3f328bc">02356</a>     <a class="code" href="classlibecc_1_1bitset.html#a446a27809cd4cb9ed6e83629a3f328bc" title="Perform a shift operation followed by a bit operation.">bitset&lt;N&gt;::shift_op</a>(<a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset</a>&amp; result)<span class="keyword"> const</span>
<a name="l02357"></a>02357 <span class="keyword">   </span>{
<a name="l02358"></a>02358       LibEccDout(dc::bitsetshift, <span class="stringliteral">&quot;Entering shift_op&lt;&quot;</span> &lt;&lt; shift &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; libcwd::type_info_of&lt;DIRECTION&gt;().demangled_name() &lt;&lt;
<a name="l02359"></a>02359           <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; type_info_of&lt;OPERATION&gt;().demangled_name() &lt;&lt; <span class="charliteral">&#39;&gt;&#39;</span>);
<a name="l02360"></a>02360       LibEccDout(dc::bitsetshift|flush_cf, <span class="stringliteral">&quot;Input : &quot;</span> &lt;&lt; cwprint_using(*<span class="keyword">this</span>, &amp;<a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset&lt;N&gt;::base2_print_on</a>));
<a name="l02361"></a>02361       <span class="keywordflow">if</span> (shift == 1)
<a name="l02362"></a>02362       {
<a name="l02363"></a>02363         <span class="comment">// Specialization for shift == 1.</span>
<a name="l02364"></a>02364         <span class="comment">// digit_shift = 0</span>
<a name="l02365"></a>02365         <span class="comment">// bit_shift = 1</span>
<a name="l02366"></a>02366         <span class="comment">// zeroed_digits = 0 (likely and if not - then assumed).</span>
<a name="l02367"></a>02367         <span class="comment">// Here we scan in the opposite direction of when shift &gt; 1.</span>
<a name="l02368"></a>02368         <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> initial = DIRECTION::__left ? 0 : bitset_base&lt;N&gt;::digits - 1;
<a name="l02369"></a>02369         <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> count = bitset_base&lt;N&gt;::digits - ((DIRECTION::__left &amp;&amp; <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;::has_excess_bits</a>) ? 1 : 0);
<a name="l02370"></a>02370 <span class="preprocessor">#ifdef __i386__</span>
<a name="l02371"></a>02371 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (count)
<a name="l02372"></a>02372         {
<a name="l02373"></a>02373           <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <span class="keyword">const</span> <span class="keyword">volatile</span>* ptr1;
<a name="l02374"></a>02374           <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <span class="keyword">volatile</span>* ptr2;
<a name="l02375"></a>02375           <span class="keywordtype">int</span> c;
<a name="l02376"></a>02376           <span class="keywordflow">if</span> (DIRECTION::__left)
<a name="l02377"></a>02377           {
<a name="l02378"></a>02378             <span class="keywordflow">if</span> (OPERATION::id == libecc::exor::id)
<a name="l02379"></a>02379             {
<a name="l02380"></a>02380               <span class="keywordflow">if</span> (<a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;::has_excess_bits</a>)
<a name="l02381"></a>02381                 LIBECC_ASMSHIFTLEFT(
<a name="l02382"></a>02382                     LIBECC_LEFT_PRESERVE_CF(<span class="stringliteral">&quot;xorl -4(%%edi), %%edx&quot;</span>),
<a name="l02383"></a>02383                     LIBECC_LEFT_PRESERVE_CF(<span class="stringliteral">&quot;xorl (%%edi), %%edx&quot;</span>),
<a name="l02384"></a>02384                     LIBECC_ASMSHIFTLEFT_FINISH(<span class="stringliteral">&quot;xorl (%%edi),%%edx\n\t&quot;</span>));
<a name="l02385"></a>02385               <span class="keywordflow">else</span>
<a name="l02386"></a>02386                 LIBECC_ASMSHIFTLEFT(
<a name="l02387"></a>02387                     LIBECC_LEFT_PRESERVE_CF(<span class="stringliteral">&quot;xorl -4(%%edi), %%edx&quot;</span>),
<a name="l02388"></a>02388                     LIBECC_LEFT_PRESERVE_CF(<span class="stringliteral">&quot;xorl (%%edi), %%edx&quot;</span>), <span class="stringliteral">&quot;&quot;</span>);
<a name="l02389"></a>02389             }
<a name="l02390"></a>02390             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (OPERATION::id == libecc::rotate_phase2::id)
<a name="l02391"></a>02391             {
<a name="l02392"></a>02392               <span class="keywordflow">if</span> (<a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;::has_excess_bits</a>)
<a name="l02393"></a>02393                 LIBECC_ASMSHIFTLEFT(
<a name="l02394"></a>02394                     LIBECC_LEFT_PRESERVE_CF(<span class="stringliteral">&quot;orl -4(%%edi), %%edx&quot;</span>), <span class="stringliteral">&quot;&quot;</span>, LIBECC_ASMSHIFTLEFT_FINISH(<span class="stringliteral">&quot;&quot;</span>));
<a name="l02395"></a>02395               <span class="keywordflow">else</span>
<a name="l02396"></a>02396                 LIBECC_ASMSHIFTLEFT(
<a name="l02397"></a>02397                     LIBECC_LEFT_PRESERVE_CF(<span class="stringliteral">&quot;orl -4(%%edi), %%edx&quot;</span>), <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>);
<a name="l02398"></a>02398             }
<a name="l02399"></a>02399             <span class="keywordflow">else</span>
<a name="l02400"></a>02400             {
<a name="l02401"></a>02401               <span class="keywordflow">if</span> (<a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;::has_excess_bits</a>)
<a name="l02402"></a>02402                 LIBECC_ASMSHIFTLEFT(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, LIBECC_ASMSHIFTLEFT_FINISH(<span class="stringliteral">&quot;&quot;</span>));
<a name="l02403"></a>02403               <span class="keywordflow">else</span>
<a name="l02404"></a>02404                 LIBECC_ASMSHIFTLEFT(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>);
<a name="l02405"></a>02405             }
<a name="l02406"></a>02406           }
<a name="l02407"></a>02407           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (count &gt; 1)
<a name="l02408"></a>02408           {
<a name="l02409"></a>02409             <span class="keywordflow">if</span> (OPERATION::id == libecc::exor::id)
<a name="l02410"></a>02410               LIBECC_ASMSHIFTRIGHT1(
<a name="l02411"></a>02411                   LIBECC_RIGHT_PRESERVE_CF(<span class="stringliteral">&quot;xorl &quot;</span> LIBECC_OP1_DESTINATION <span class="stringliteral">&quot;,&quot;</span> LIBECC_WORKREG),
<a name="l02412"></a>02412                   LIBECC_RIGHT_PRESERVE_CF(<span class="stringliteral">&quot;xorl &quot;</span> LIBECC_OP2_DESTINATION <span class="stringliteral">&quot;,&quot;</span> LIBECC_WORKREG),
<a name="l02413"></a>02413                   LIBECC_PRESERVE_CF_CLOBBER);
<a name="l02414"></a>02414             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (OPERATION::id == libecc::rotate_phase2::id)
<a name="l02415"></a>02415               LIBECC_ASMSHIFTRIGHT1(
<a name="l02416"></a>02416                   LIBECC_RIGHT_PRESERVE_CF(<span class="stringliteral">&quot;orl &quot;</span> LIBECC_OP1_DESTINATION <span class="stringliteral">&quot;,&quot;</span> LIBECC_WORKREG),
<a name="l02417"></a>02417                   <span class="stringliteral">&quot;&quot;</span>,
<a name="l02418"></a>02418                   LIBECC_PRESERVE_CF_CLOBBER);
<a name="l02419"></a>02419             <span class="keywordflow">else</span>
<a name="l02420"></a>02420               LIBECC_ASMSHIFTRIGHT1(
<a name="l02421"></a>02421                   <span class="stringliteral">&quot;&quot;</span>,
<a name="l02422"></a>02422                   <span class="stringliteral">&quot;&quot;</span>,
<a name="l02423"></a>02423                   LIBECC_CLOBBER);
<a name="l02424"></a>02424           }
<a name="l02425"></a>02425           <span class="keywordflow">else</span>
<a name="l02426"></a>02426           {
<a name="l02427"></a>02427             <span class="keywordflow">if</span> (OPERATION::id == libecc::exor::id)
<a name="l02428"></a>02428               LIBECC_ASMSHIFTRIGHT0(<span class="stringliteral">&quot;xorl 4(%%edi), %%edx\n\t&quot;</span>);
<a name="l02429"></a>02429             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (OPERATION::id == libecc::rotate_phase2::id)
<a name="l02430"></a>02430               LIBECC_ASMSHIFTRIGHT0(<span class="stringliteral">&quot;orl 4(%%edi), %%edx\n\t&quot;</span>);
<a name="l02431"></a>02431             <span class="keywordflow">else</span>
<a name="l02432"></a>02432               LIBECC_ASMSHIFTRIGHT0(<span class="stringliteral">&quot;&quot;</span>);
<a name="l02433"></a>02433           }
<a name="l02434"></a>02434         }
<a name="l02435"></a>02435         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DIRECTION::__left &amp;&amp; <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;::has_excess_bits</a>)
<a name="l02436"></a>02436           OPERATION::op(result.<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[0], ((this-&gt;vector[0] &lt;&lt; 1) &amp; bitset_base&lt;N&gt;::valid_bits));
<a name="l02437"></a>02437 <span class="preprocessor">#else</span>
<a name="l02438"></a>02438 <span class="preprocessor"></span>        <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> complement_shift = bitset_digit_bits - 1;
<a name="l02439"></a>02439         <span class="keyword">static</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <span class="keyword">const</span> mask1 = DIRECTION::__left ? (<span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a><span class="keyword">&gt;</span>(1) &lt;&lt; complement_shift) : <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a><span class="keyword">&gt;</span>(1);
<a name="l02440"></a>02440         <span class="keyword">static</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <span class="keyword">const</span> mask2 = DIRECTION::__right ? (<span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a><span class="keyword">&gt;</span>(1) &lt;&lt; complement_shift) : <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a><span class="keyword">&gt;</span>(1);
<a name="l02441"></a>02441         <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <span class="keyword">const</span>* ptr1 = &amp;this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[initial];
<a name="l02442"></a>02442         <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>* ptr2 = &amp;result.<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[initial];
<a name="l02443"></a>02443         <span class="keywordtype">bool</span> carry;
<a name="l02444"></a>02444         <span class="keywordflow">if</span> (count)
<a name="l02445"></a>02445         {
<a name="l02446"></a>02446           <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <a class="code" href="classlibecc_1_1bitset__invertible.html#a9bf8dafb22ff7f9dd53721fadea6f1bb" title="Access digit number d.">digit</a> = *ptr1;
<a name="l02447"></a>02447           carry = (digit &amp; mask1);
<a name="l02448"></a>02448           <span class="keywordflow">if</span> (DIRECTION::__left)
<a name="l02449"></a>02449             digit &lt;&lt;= 1;
<a name="l02450"></a>02450           <span class="keywordflow">else</span>
<a name="l02451"></a>02451             digit &gt;&gt;= 1;
<a name="l02452"></a>02452           OPERATION::mixed_op(*ptr2, digit);
<a name="l02453"></a>02453           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = count - 1; c; --c)
<a name="l02454"></a>02454           {
<a name="l02455"></a>02455             ptr1 -= DIRECTION::direction;
<a name="l02456"></a>02456             ptr2 -= DIRECTION::direction;
<a name="l02457"></a>02457             digit = *ptr1;
<a name="l02458"></a>02458             <span class="keywordflow">if</span> (carry)
<a name="l02459"></a>02459             {
<a name="l02460"></a>02460               carry = (digit &amp; mask1);
<a name="l02461"></a>02461               <span class="keywordflow">if</span> (DIRECTION::__left)
<a name="l02462"></a>02462                 digit &lt;&lt;= 1;
<a name="l02463"></a>02463               <span class="keywordflow">else</span>
<a name="l02464"></a>02464                 digit &gt;&gt;= 1;
<a name="l02465"></a>02465               digit |= mask2;
<a name="l02466"></a>02466             }
<a name="l02467"></a>02467             <span class="keywordflow">else</span>
<a name="l02468"></a>02468             {
<a name="l02469"></a>02469               carry = (digit &amp; mask1);
<a name="l02470"></a>02470               <span class="keywordflow">if</span> (DIRECTION::__left)
<a name="l02471"></a>02471                 digit &lt;&lt;= 1;
<a name="l02472"></a>02472               <span class="keywordflow">else</span>
<a name="l02473"></a>02473                 digit &gt;&gt;= 1;
<a name="l02474"></a>02474             }
<a name="l02475"></a>02475             OPERATION::op(*ptr2, digit);
<a name="l02476"></a>02476           }
<a name="l02477"></a>02477         }
<a name="l02478"></a>02478         <span class="keywordflow">if</span> (DIRECTION::__left &amp;&amp; <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;::has_excess_bits</a>)
<a name="l02479"></a>02479         {
<a name="l02480"></a>02480           <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> digit;
<a name="l02481"></a>02481           <span class="keywordflow">if</span> (count)
<a name="l02482"></a>02482             digit = ptr1[-DIRECTION::direction];
<a name="l02483"></a>02483           <span class="keywordflow">else</span>
<a name="l02484"></a>02484             digit = *ptr1;
<a name="l02485"></a>02485           digit &lt;&lt;= 1;
<a name="l02486"></a>02486           <span class="keywordflow">if</span> (count &amp;&amp; carry)
<a name="l02487"></a>02487             digit |= mask2;
<a name="l02488"></a>02488           <span class="keywordflow">if</span> (count)
<a name="l02489"></a>02489             OPERATION::op(ptr2[-DIRECTION::direction], (digit &amp; bitset_base&lt;N&gt;::valid_bits));
<a name="l02490"></a>02490           <span class="keywordflow">else</span>
<a name="l02491"></a>02491             OPERATION::op(*ptr2, (digit &amp; bitset_base&lt;N&gt;::valid_bits));
<a name="l02492"></a>02492         }
<a name="l02493"></a>02493 <span class="preprocessor">#endif</span>
<a name="l02494"></a>02494 <span class="preprocessor"></span>      }
<a name="l02495"></a>02495       <span class="keywordflow">else</span>
<a name="l02496"></a>02496       {
<a name="l02497"></a>02497         <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> digit_shift = shift / bitset_digit_bits;
<a name="l02498"></a>02498         <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> bit_shift = shift % bitset_digit_bits;
<a name="l02499"></a>02499 
<a name="l02500"></a>02500         <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> zeroed_digits =
<a name="l02501"></a>02501           DIRECTION::__left ? ((shift &lt; N) ? digit_shift : bitset_base&lt;N&gt;::digits)
<a name="l02502"></a>02502                             : ((bitset_digit_bits - <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;::number_of_valid_bits</a> + shift) / bitset_digit_bits);
<a name="l02503"></a>02503 
<a name="l02504"></a>02504         <span class="keywordflow">if</span> (zeroed_digits &lt; bitset_base&lt;N&gt;::digits)
<a name="l02505"></a>02505         {
<a name="l02506"></a>02506           <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> complement_shift = (bit_shift == 0) ? 0 : bitset_digit_bits - bit_shift;
<a name="l02507"></a>02507           <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> initial_to = DIRECTION::__right ? 0 : bitset_base&lt;N&gt;::digits - 1;
<a name="l02508"></a>02508           <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> initial_from = initial_to + DIRECTION::direction * digit_shift;
<a name="l02509"></a>02509           <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> final_from = DIRECTION::__left ? 0 : bitset_base&lt;N&gt;::digits - 1;
<a name="l02510"></a>02510 
<a name="l02511"></a>02511           <span class="keyword">register</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <a class="code" href="classlibecc_1_1bitset__invertible.html#a9bf8dafb22ff7f9dd53721fadea6f1bb" title="Access digit number d.">digit</a> = this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[initial_from];
<a name="l02512"></a>02512           <span class="keywordflow">if</span> (initial_from != final_from)
<a name="l02513"></a>02513           {
<a name="l02514"></a>02514             <span class="keyword">register</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> next_digit;
<a name="l02515"></a>02515             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> to = initial_to;
<a name="l02516"></a>02516             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> from = initial_from + DIRECTION::direction;
<a name="l02517"></a>02517             <span class="keywordflow">if</span> (from != final_from)
<a name="l02518"></a>02518               <span class="keywordflow">do</span>
<a name="l02519"></a>02519               {
<a name="l02520"></a>02520                 next_digit = this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[from];
<a name="l02521"></a>02521                 <span class="keywordflow">if</span> (bit_shift != 0)
<a name="l02522"></a>02522                 {
<a name="l02523"></a>02523                   <span class="keywordflow">if</span> (DIRECTION::direction == -1)
<a name="l02524"></a>02524                     digit &lt;&lt;= bit_shift;
<a name="l02525"></a>02525                   <span class="keywordflow">else</span>
<a name="l02526"></a>02526                     digit &gt;&gt;= bit_shift;
<a name="l02527"></a>02527                   digit |= DIRECTION::reverse_shift_copy(next_digit, complement_shift);
<a name="l02528"></a>02528                 }
<a name="l02529"></a>02529                 OPERATION::op(result.<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[to], digit);
<a name="l02530"></a>02530                 digit = next_digit;
<a name="l02531"></a>02531                 to += DIRECTION::direction;
<a name="l02532"></a>02532                 from += DIRECTION::direction;
<a name="l02533"></a>02533               }
<a name="l02534"></a>02534               <span class="keywordflow">while</span> (from != final_from);
<a name="l02535"></a>02535             <span class="keywordflow">if</span> (DIRECTION::__left || bit_shift &lt; <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;::number_of_valid_bits</a> || bit_shift != 0)
<a name="l02536"></a>02536               next_digit = this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[final_from];
<a name="l02537"></a>02537             <span class="keywordflow">if</span> (bit_shift != 0)
<a name="l02538"></a>02538             {
<a name="l02539"></a>02539               <span class="keywordflow">if</span> (DIRECTION::direction == -1)
<a name="l02540"></a>02540                 digit &lt;&lt;= bit_shift;
<a name="l02541"></a>02541               <span class="keywordflow">else</span>
<a name="l02542"></a>02542                 digit &gt;&gt;= bit_shift;
<a name="l02543"></a>02543               digit |= DIRECTION::reverse_shift_copy(next_digit, complement_shift);
<a name="l02544"></a>02544             }
<a name="l02545"></a>02545             <span class="keywordflow">if</span> (DIRECTION::__left || bit_shift &lt; <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;::number_of_valid_bits</a>)
<a name="l02546"></a>02546             {
<a name="l02547"></a>02547               OPERATION::op(result.<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[final_from - DIRECTION::direction * (digit_shift + 1)], digit);
<a name="l02548"></a>02548               digit = DIRECTION::shift_copy(next_digit, bit_shift);
<a name="l02549"></a>02549             }
<a name="l02550"></a>02550           }
<a name="l02551"></a>02551           <span class="keywordflow">else</span>
<a name="l02552"></a>02552           {
<a name="l02553"></a>02553             <span class="keywordflow">if</span> (DIRECTION::direction == -1)
<a name="l02554"></a>02554               digit &lt;&lt;= bit_shift;
<a name="l02555"></a>02555             <span class="keywordflow">else</span>
<a name="l02556"></a>02556               digit &gt;&gt;= bit_shift;
<a name="l02557"></a>02557           }
<a name="l02558"></a>02558           <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> have_mixed_digit = shift != 0 &amp;&amp; (DIRECTION::__left ? shift : (N - shift)) % bitset_digit_bits != 0;
<a name="l02559"></a>02559           <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> last_digit = (DIRECTION::__left ? shift : (N - 1 - shift)) / bitset_digit_bits;
<a name="l02560"></a>02560           <span class="keywordflow">if</span> (have_mixed_digit)
<a name="l02561"></a>02561             OPERATION::mixed_op(result.<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[last_digit], digit);
<a name="l02562"></a>02562           <span class="keywordflow">else</span>
<a name="l02563"></a>02563             OPERATION::op(result.<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[last_digit], digit);
<a name="l02564"></a>02564           <span class="keywordflow">if</span> (DIRECTION::__left &amp;&amp; <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;::has_excess_bits</a>)
<a name="l02565"></a>02565             result.<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[bitset_base&lt;N&gt;::digits - 1] &amp;= bitset_base&lt;N&gt;::valid_bits;
<a name="l02566"></a>02566         }
<a name="l02567"></a>02567         <span class="keywordflow">if</span> (OPERATION::__clear &amp;&amp; zeroed_digits &gt; 0)
<a name="l02568"></a>02568         {
<a name="l02569"></a>02569           <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> final_to = DIRECTION::__left ? 0 : bitset_base&lt;N&gt;::digits - 1;
<a name="l02570"></a>02570           <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> initial_to = final_to - DIRECTION::direction * (zeroed_digits - 1);
<a name="l02571"></a>02571           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> to = initial_to;
<a name="l02572"></a>02572           <span class="keywordflow">if</span> (to != final_to)
<a name="l02573"></a>02573             <span class="keywordflow">do</span>
<a name="l02574"></a>02574             {
<a name="l02575"></a>02575               result.<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[to] = 0;
<a name="l02576"></a>02576               to += DIRECTION::direction;
<a name="l02577"></a>02577             }
<a name="l02578"></a>02578             <span class="keywordflow">while</span>(to != final_to);
<a name="l02579"></a>02579           result.<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[to] = 0;
<a name="l02580"></a>02580         }
<a name="l02581"></a>02581       }
<a name="l02582"></a>02582       LibEccDout(dc::bitsetshift|flush_cf, <span class="stringliteral">&quot;Output: &quot;</span> &lt;&lt; cwprint_using(result, &amp;<a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset&lt;N&gt;::base2_print_on</a>));
<a name="l02583"></a>02583     }
<a name="l02584"></a>02584 
<a name="l02585"></a>02585 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02586"></a>02586   <span class="keywordtype">void</span>
<a name="l02587"></a>02587   <a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;::operator&lt;&lt;=</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shift)
<a name="l02588"></a>02588   {
<a name="l02589"></a>02589     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> digit_shift = shift &gt;&gt; bitset_digit_bits_log2;
<a name="l02590"></a>02590     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> bit_shift = shift &amp; (bitset_digit_bits - 1);
<a name="l02591"></a>02591     <span class="keywordtype">int</span> digit1 = bitset_base&lt;N&gt;::digits - digit_shift - 2;
<a name="l02592"></a>02592     <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> d0 = (digit1 &gt;= -1) ? this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[digit1 + 1] : 0;
<a name="l02593"></a>02593     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> digit_to = bitset_base&lt;N&gt;::digits - 1; digit_to &gt;= 0; --digit_to)
<a name="l02594"></a>02594     {
<a name="l02595"></a>02595       <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> d1 = (digit1 &gt;= 0) ? this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[digit1] : 0;
<a name="l02596"></a>02596       <span class="keywordflow">if</span> (bit_shift == 0)
<a name="l02597"></a>02597         this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[digit_to] = d0;
<a name="l02598"></a>02598       <span class="keywordflow">else</span>
<a name="l02599"></a>02599         this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[digit_to] = (d0 &lt;&lt; bit_shift) | (d1 &gt;&gt; (bitset_digit_bits - bit_shift));
<a name="l02600"></a>02600       d0 = d1;
<a name="l02601"></a>02601       --digit1;
<a name="l02602"></a>02602     }
<a name="l02603"></a>02603     <span class="keywordflow">if</span> (bitset_base&lt;N&gt;::has_excess_bits)
<a name="l02604"></a>02604       this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[bitset_base&lt;N&gt;::digits - 1] &amp;= bitset_base&lt;N&gt;::valid_bits;           <span class="comment">// Reset possibly set excess bits.</span>
<a name="l02605"></a>02605   }
<a name="l02606"></a>02606 
<a name="l02607"></a>02607 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02608"></a>02608   <span class="keywordtype">void</span>
<a name="l02609"></a>02609   bitset_base&lt;N&gt;::operator&gt;&gt;=(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shift)
<a name="l02610"></a>02610   {
<a name="l02611"></a>02611     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> digit_shift = shift &gt;&gt; bitset_digit_bits_log2;
<a name="l02612"></a>02612     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> bit_shift = shift &amp; (bitset_digit_bits - 1);
<a name="l02613"></a>02613     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> digit1 = digit_shift + 1;
<a name="l02614"></a>02614     <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> d0 = (digit1 &lt;= bitset_base&lt;N&gt;::digits) ? this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[digit1 - 1] : 0;
<a name="l02615"></a>02615     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> digit_to = 0; digit_to &lt; bitset_base&lt;N&gt;::digits; ++digit_to)
<a name="l02616"></a>02616     {
<a name="l02617"></a>02617       <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> d1 = (digit1 &lt; bitset_base&lt;N&gt;::digits) ? this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[digit1] : 0;
<a name="l02618"></a>02618       <span class="keywordflow">if</span> (bit_shift == 0)
<a name="l02619"></a>02619         this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[digit_to] = d0;
<a name="l02620"></a>02620       <span class="keywordflow">else</span>
<a name="l02621"></a>02621         this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[digit_to] = (d0 &gt;&gt; bit_shift) | (d1 &lt;&lt; (bitset_digit_bits - bit_shift));
<a name="l02622"></a>02622       d0 = d1;
<a name="l02623"></a>02623       ++digit1;
<a name="l02624"></a>02624     }
<a name="l02625"></a>02625   }
<a name="l02626"></a>02626 
<a name="l02643"></a>02643 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02644"></a><a class="code" href="classlibecc_1_1bitset.html#a72e5eeef90293a462ce1da399dcbd8f5">02644</a>   <a class="code" href="classlibecc_1_1bitset.html#a2f7c44b72136449f89e87c9065a50453" title="Construct an uninitialized bitset of N bits.">bitset&lt;N&gt;::bitset</a>(std::string <span class="keyword">const</span>&amp; input)
<a name="l02645"></a>02645   {
<a name="l02646"></a>02646     this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a546fff5ea210a08046d3429642bd0cf4" title="Reset all bits to 0.">reset</a>();                                      <span class="comment">// Reset internal digits to zero.</span>
<a name="l02647"></a>02647     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0;                                 <span class="comment">// Current index of internal digit.</span>
<a name="l02648"></a>02648     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> u = 0;                                 <span class="comment">// Current bit-shift of input digit relative to internal digit.</span>
<a name="l02649"></a>02649 
<a name="l02650"></a>02650     <span class="keywordflow">for</span> (std::string::const_reverse_iterator iter = input.rbegin(); iter != input.rend(); ++iter)       <span class="comment">// Read right to left.</span>
<a name="l02651"></a>02651     {
<a name="l02652"></a>02652       <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> c = toupper(*iter);                <span class="comment">// Get next hexadecimal input character.</span>
<a name="l02653"></a>02653       <span class="keywordflow">if</span> (c == <span class="charliteral">&#39; &#39;</span>)                                     <span class="comment">// Skip spaces.</span>
<a name="l02654"></a>02654         <span class="keywordflow">continue</span>;
<a name="l02655"></a>02655       <span class="keywordflow">if</span> (c &lt; <span class="charliteral">&#39;0&#39;</span>)                                      <span class="comment">// Terminate reading when not a hexadecimal character.</span>
<a name="l02656"></a>02656         <span class="keywordflow">break</span>;
<a name="l02657"></a>02657       <span class="keywordflow">if</span> (c &lt;= <span class="charliteral">&#39;9&#39;</span>)
<a name="l02658"></a>02658         c -= <span class="charliteral">&#39;0&#39;</span>;                                       <span class="comment">// Set c to the value that the input character represents.</span>
<a name="l02659"></a>02659       <span class="keywordflow">else</span>
<a name="l02660"></a>02660       {
<a name="l02661"></a>02661         <span class="keywordflow">if</span> (c &gt; <span class="charliteral">&#39;F&#39;</span>)
<a name="l02662"></a>02662           <span class="keywordflow">break</span>;
<a name="l02663"></a>02663         <span class="keywordflow">if</span> (c &gt;= <span class="charliteral">&#39;A&#39;</span>)
<a name="l02664"></a>02664           c -= (<span class="charliteral">&#39;A&#39;</span> - 10);
<a name="l02665"></a>02665         <span class="keywordflow">else</span>
<a name="l02666"></a>02666           <span class="keywordflow">break</span>;
<a name="l02667"></a>02667       }
<a name="l02668"></a>02668       this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d] |= c &lt;&lt; u;                        <span class="comment">// Set internal bits.</span>
<a name="l02669"></a>02669       <span class="keywordflow">if</span> ((u += 4) == bitset_digit_bits)                <span class="comment">// Update bit/digit &#39;pointers&#39;.</span>
<a name="l02670"></a>02670       {
<a name="l02671"></a>02671         u = 0;
<a name="l02672"></a>02672         <span class="keywordflow">if</span> (++d == bitset_base&lt;N&gt;::digits)              <span class="comment">// Terminate reading when bitset is full.</span>
<a name="l02673"></a>02673           <span class="keywordflow">break</span>;
<a name="l02674"></a>02674       }
<a name="l02675"></a>02675     }
<a name="l02676"></a>02676     <span class="keywordflow">if</span> (<a class="code" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset.">bitset_base&lt;N&gt;::has_excess_bits</a>)
<a name="l02677"></a>02677       this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[bitset_base&lt;N&gt;::digits - 1] &amp;= bitset_base&lt;N&gt;::valid_bits;   <span class="comment">// Reset possibly set excess bits.</span>
<a name="l02678"></a>02678   }
<a name="l02679"></a>02679 
<a name="l02683"></a>02683 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02684"></a>02684   std::istream&amp;
<a name="l02685"></a><a class="code" href="namespacelibecc.html#a8b8aae3b135c4b928cf7caacfc21ddda">02685</a>   <a class="code" href="namespacelibecc.html#a8b8aae3b135c4b928cf7caacfc21ddda" title="Read bitset from istream.">operator&gt;&gt;</a>(std::istream&amp; is, <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset&lt;N&gt;</a>&amp; bitsetx)
<a name="l02686"></a>02686   {
<a name="l02687"></a>02687     std::string tmp;
<a name="l02688"></a>02688     is &gt;&gt; tmp;
<a name="l02689"></a>02689     bitsetx.<a class="code" href="classlibecc_1_1bitset.html#a2f7c44b72136449f89e87c9065a50453" title="Construct an uninitialized bitset of N bits.">bitset</a>(tmp);
<a name="l02690"></a>02690     <span class="keywordflow">return</span> is;
<a name="l02691"></a>02691   }
<a name="l02692"></a>02692 
<a name="l02696"></a>02696 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02697"></a>02697   std::ostream&amp;
<a name="l02698"></a><a class="code" href="namespacelibecc.html#a6f604c27b346d0face2d30fd58c2f1c0">02698</a>   operator&lt;&lt;(std::ostream&amp; os, bitset&lt;N&gt; <span class="keyword">const</span>&amp; bits)
<a name="l02699"></a>02699   {
<a name="l02700"></a>02700     <span class="comment">// Hexadecimal representation</span>
<a name="l02701"></a>02701     os.fill(<span class="charliteral">&#39;0&#39;</span>);
<a name="l02702"></a>02702     os &lt;&lt; std::hex;
<a name="l02703"></a>02703     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> d = <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset&lt;N&gt;::digits</a> - 1; d &gt;= 0; --d)
<a name="l02704"></a>02704     {
<a name="l02705"></a>02705       os.width((d == <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset&lt;N&gt;::digits</a> - 1 &amp;&amp; <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset&lt;N&gt;::has_excess_bits</a>) ?
<a name="l02706"></a>02706           (((N % bitset_digit_bits) - 1) / 4 + 1) :
<a name="l02707"></a>02707           (bitset_digit_bits / 4));
<a name="l02708"></a>02708       os &lt;&lt; bits.digit(d);
<a name="l02709"></a>02709       <span class="keywordflow">if</span> (d &gt; 0)
<a name="l02710"></a>02710         os &lt;&lt; <span class="charliteral">&#39; &#39;</span>;
<a name="l02711"></a>02711     }
<a name="l02712"></a>02712     os &lt;&lt; std::dec;
<a name="l02713"></a>02713     <span class="keywordflow">return</span> os;
<a name="l02714"></a>02714   }
<a name="l02715"></a>02715 
<a name="l02719"></a>02719 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02720"></a>02720   <span class="keywordtype">void</span>
<a name="l02721"></a><a class="code" href="structlibecc_1_1bitset__base.html#a546fff5ea210a08046d3429642bd0cf4">02721</a>   <a class="code" href="structlibecc_1_1bitset__base.html#a546fff5ea210a08046d3429642bd0cf4" title="Reset all bits to 0.">bitset_base&lt;N&gt;::reset</a>(<span class="keywordtype">void</span>)
<a name="l02722"></a>02722   {
<a name="l02723"></a>02723     std::memset(this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>, 0, <span class="keyword">sizeof</span>(this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>));
<a name="l02724"></a>02724   }
<a name="l02725"></a>02725 
<a name="l02729"></a>02729 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02730"></a>02730   <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l02731"></a><a class="code" href="structlibecc_1_1bitset__base.html#a5cd84caa5b775784ceea5ff8549d7672">02731</a>   <a class="code" href="structlibecc_1_1bitset__base.html#a01a13f277f84abee29e8af9c0ac9d6ad" title="Test a bit at a fixed position.">bitset_base&lt;N&gt;::test</a>(<span class="keywordtype">size_t</span> pos)<span class="keyword"> const</span>
<a name="l02732"></a>02732 <span class="keyword"> </span>{
<a name="l02733"></a>02733 <span class="preprocessor">#ifdef __i386__</span>
<a name="l02734"></a>02734 <span class="preprocessor"></span>    <span class="keywordtype">int</span> result;
<a name="l02735"></a>02735     __asm__ __volatile__ (
<a name="l02736"></a>02736         <span class="stringliteral">&quot;btl %2, %1\n\t&quot;</span>
<a name="l02737"></a>02737         <span class="stringliteral">&quot;sbbl %0, %0&quot;</span>
<a name="l02738"></a>02738         : <span class="stringliteral">&quot;=r&quot;</span> (result)
<a name="l02739"></a>02739         : <span class="stringliteral">&quot;m&quot;</span> ((*(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <span class="keyword">volatile</span>*)this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>)), <span class="stringliteral">&quot;Ir&quot;</span> (pos)
<a name="l02740"></a>02740         : <span class="stringliteral">&quot;cc&quot;</span>);
<a name="l02741"></a>02741     <span class="keywordflow">return</span> result;
<a name="l02742"></a>02742 <span class="preprocessor">#else</span>
<a name="l02743"></a>02743 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = pos / bitset_digit_bits;
<a name="l02744"></a>02744     <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> mask = <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a><span class="keyword">&gt;</span>(1) &lt;&lt; (pos % bitset_digit_bits);
<a name="l02745"></a>02745     <span class="keywordflow">return</span> (this-&gt;vector[d] &amp; mask);
<a name="l02746"></a>02746 <span class="preprocessor">#endif</span>
<a name="l02747"></a>02747 <span class="preprocessor"></span>  }
<a name="l02748"></a>02748 
<a name="l02752"></a>02752 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02753"></a>02753   <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos&gt;
<a name="l02754"></a>02754     <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l02755"></a><a class="code" href="structlibecc_1_1bitset__base.html#a01a13f277f84abee29e8af9c0ac9d6ad">02755</a>     <a class="code" href="structlibecc_1_1bitset__base.html#a01a13f277f84abee29e8af9c0ac9d6ad" title="Test a bit at a fixed position.">bitset_base&lt;N&gt;::test</a>(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l02756"></a>02756 <span class="keyword">   </span>{
<a name="l02757"></a>02757       <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> d = pos / bitset_digit_bits;
<a name="l02758"></a>02758       <span class="keyword">static</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <span class="keyword">const</span> mask = <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a><span class="keyword">&gt;</span>(1) &lt;&lt; (pos % bitset_digit_bits);
<a name="l02759"></a>02759       <span class="keywordflow">return</span> (this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d] &amp; mask);
<a name="l02760"></a>02760     }
<a name="l02761"></a>02761 
<a name="l02765"></a>02765 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02766"></a>02766   <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l02767"></a><a class="code" href="structlibecc_1_1bitset__base.html#a1ebff914412369915cd1df75b384020f">02767</a>   <a class="code" href="structlibecc_1_1bitset__base.html#a01a13f277f84abee29e8af9c0ac9d6ad" title="Test a bit at a fixed position.">bitset_base&lt;N&gt;::test</a>(<a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; index)<span class="keyword"> const</span>
<a name="l02768"></a>02768 <span class="keyword"> </span>{
<a name="l02769"></a>02769 <span class="preprocessor">#ifdef __i386__</span>
<a name="l02770"></a>02770 <span class="preprocessor"></span>    <span class="keywordflow">return</span> this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a01a13f277f84abee29e8af9c0ac9d6ad" title="Test a bit at a fixed position.">test</a>(index.<a class="code" href="classlibecc_1_1bitset__index.html#ad97d9d24247e358eb528fd82b41976df">get_index</a>());
<a name="l02771"></a>02771 <span class="preprocessor">#else</span>
<a name="l02772"></a>02772 <span class="preprocessor"></span>    <span class="keywordflow">return</span> (this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[index.get_digit()] &amp; index.get_mask());
<a name="l02773"></a>02773 <span class="preprocessor">#endif</span>
<a name="l02774"></a>02774 <span class="preprocessor"></span>  }
<a name="l02775"></a>02775 
<a name="l02779"></a>02779 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02780"></a>02780   <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l02781"></a><a class="code" href="structlibecc_1_1bitset__base.html#ad3363dbe3669a797faf02253655f49ec">02781</a>   <a class="code" href="structlibecc_1_1bitset__base.html#a618c787949ed07382779045473d01a16" title="Set a bit at a fixed position.">bitset_base&lt;N&gt;::set</a>(<span class="keywordtype">size_t</span> pos)
<a name="l02782"></a>02782   {
<a name="l02783"></a>02783 <span class="preprocessor">#ifdef __i386__</span>
<a name="l02784"></a>02784 <span class="preprocessor"></span>    __asm__ __volatile__ (
<a name="l02785"></a>02785         <span class="stringliteral">&quot;btsl %1, %0&quot;</span>
<a name="l02786"></a>02786         : <span class="stringliteral">&quot;=m&quot;</span> ((*(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <span class="keyword">volatile</span>*)this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>))
<a name="l02787"></a>02787         : <span class="stringliteral">&quot;Ir&quot;</span> (pos)
<a name="l02788"></a>02788         : <span class="stringliteral">&quot;cc&quot;</span>);
<a name="l02789"></a>02789 
<a name="l02790"></a>02790 <span class="preprocessor">#else</span>
<a name="l02791"></a>02791 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = pos / bitset_digit_bits;
<a name="l02792"></a>02792     <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> mask = <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a><span class="keyword">&gt;</span>(1) &lt;&lt; (pos % bitset_digit_bits);
<a name="l02793"></a>02793     this-&gt;vector[d] |= mask;
<a name="l02794"></a>02794 <span class="preprocessor">#endif</span>
<a name="l02795"></a>02795 <span class="preprocessor"></span>  }
<a name="l02796"></a>02796 
<a name="l02800"></a>02800 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02801"></a>02801   <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l02802"></a><a class="code" href="structlibecc_1_1bitset__base.html#aeb494dc2b9bbcb1ea43a5b84d66615b1">02802</a>   <a class="code" href="structlibecc_1_1bitset__base.html#a618c787949ed07382779045473d01a16" title="Set a bit at a fixed position.">bitset_base&lt;N&gt;::set</a>(<a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; index)
<a name="l02803"></a>02803   {
<a name="l02804"></a>02804 <span class="preprocessor">#ifdef __i386__</span>
<a name="l02805"></a>02805 <span class="preprocessor"></span>    this-&gt;<span class="keyword">set</span>(index.<a class="code" href="classlibecc_1_1bitset__index.html#ad97d9d24247e358eb528fd82b41976df">get_index</a>());
<a name="l02806"></a>02806 <span class="preprocessor">#else</span>
<a name="l02807"></a>02807 <span class="preprocessor"></span>    this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[index.get_digit()] |= index.get_mask();
<a name="l02808"></a>02808 <span class="preprocessor">#endif</span>
<a name="l02809"></a>02809 <span class="preprocessor"></span>  }
<a name="l02810"></a>02810 
<a name="l02814"></a>02814 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02815"></a>02815   <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos&gt;
<a name="l02816"></a>02816     <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l02817"></a><a class="code" href="structlibecc_1_1bitset__base.html#a618c787949ed07382779045473d01a16">02817</a>     <a class="code" href="structlibecc_1_1bitset__base.html#a618c787949ed07382779045473d01a16" title="Set a bit at a fixed position.">bitset_base&lt;N&gt;::set</a>(<span class="keywordtype">void</span>)
<a name="l02818"></a>02818     {
<a name="l02819"></a>02819       <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> d = pos / bitset_digit_bits;
<a name="l02820"></a>02820       <span class="keyword">static</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <span class="keyword">const</span> mask = <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a><span class="keyword">&gt;</span>(1) &lt;&lt; (pos % bitset_digit_bits);
<a name="l02821"></a>02821       this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d] |= mask;
<a name="l02822"></a>02822     }
<a name="l02823"></a>02823 
<a name="l02827"></a>02827 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02828"></a>02828   <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l02829"></a><a class="code" href="structlibecc_1_1bitset__base.html#aa2530d51ef1a6f4a68910810c53a87b2">02829</a>   <a class="code" href="structlibecc_1_1bitset__base.html#ac2f5e92ab953a43c76ca664b23add1cf" title="Clear a bit at a fixed position.">bitset_base&lt;N&gt;::clear</a>(<span class="keywordtype">size_t</span> pos)
<a name="l02830"></a>02830   {
<a name="l02831"></a>02831 <span class="preprocessor">#ifdef __i386__</span>
<a name="l02832"></a>02832 <span class="preprocessor"></span>    __asm__ __volatile__ (
<a name="l02833"></a>02833         <span class="stringliteral">&quot;btrl %1, %0&quot;</span>
<a name="l02834"></a>02834         : <span class="stringliteral">&quot;=m&quot;</span> ((*(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <span class="keyword">volatile</span>*)this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>))
<a name="l02835"></a>02835         : <span class="stringliteral">&quot;Ir&quot;</span> (pos)
<a name="l02836"></a>02836         : <span class="stringliteral">&quot;cc&quot;</span>
<a name="l02837"></a>02837     );
<a name="l02838"></a>02838 <span class="preprocessor">#else</span>
<a name="l02839"></a>02839 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = pos / bitset_digit_bits;
<a name="l02840"></a>02840     <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> mask = <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a><span class="keyword">&gt;</span>(1) &lt;&lt; (pos % bitset_digit_bits);
<a name="l02841"></a>02841     this-&gt;vector[d] &amp;= ~mask;
<a name="l02842"></a>02842 <span class="preprocessor">#endif</span>
<a name="l02843"></a>02843 <span class="preprocessor"></span>  }
<a name="l02844"></a>02844 
<a name="l02848"></a>02848 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02849"></a>02849   <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l02850"></a><a class="code" href="structlibecc_1_1bitset__base.html#a8281897a2f4874e80ce6e1941e4eae96">02850</a>   <a class="code" href="structlibecc_1_1bitset__base.html#ac2f5e92ab953a43c76ca664b23add1cf" title="Clear a bit at a fixed position.">bitset_base&lt;N&gt;::clear</a>(<a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; index)
<a name="l02851"></a>02851   {
<a name="l02852"></a>02852 <span class="preprocessor">#ifdef __i386__</span>
<a name="l02853"></a>02853 <span class="preprocessor"></span>    this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#ac2f5e92ab953a43c76ca664b23add1cf" title="Clear a bit at a fixed position.">clear</a>(index.<a class="code" href="classlibecc_1_1bitset__index.html#ad97d9d24247e358eb528fd82b41976df">get_index</a>());
<a name="l02854"></a>02854 <span class="preprocessor">#else</span>
<a name="l02855"></a>02855 <span class="preprocessor"></span>    this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[index.get_digit()] &amp;= ~(index.get_mask());
<a name="l02856"></a>02856 <span class="preprocessor">#endif</span>
<a name="l02857"></a>02857 <span class="preprocessor"></span>  }
<a name="l02858"></a>02858 
<a name="l02862"></a>02862 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02863"></a>02863   <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos&gt;
<a name="l02864"></a>02864     <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l02865"></a><a class="code" href="structlibecc_1_1bitset__base.html#ac2f5e92ab953a43c76ca664b23add1cf">02865</a>     <a class="code" href="structlibecc_1_1bitset__base.html#ac2f5e92ab953a43c76ca664b23add1cf" title="Clear a bit at a fixed position.">bitset_base&lt;N&gt;::clear</a>(<span class="keywordtype">void</span>)
<a name="l02866"></a>02866     {
<a name="l02867"></a>02867       <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> d = pos / bitset_digit_bits;
<a name="l02868"></a>02868       <span class="keyword">static</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <span class="keyword">const</span> mask = ~(<span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a><span class="keyword">&gt;</span>(1) &lt;&lt; (pos % bitset_digit_bits));
<a name="l02869"></a>02869       this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d] &amp;= mask;
<a name="l02870"></a>02870     }
<a name="l02871"></a>02871 
<a name="l02875"></a>02875 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02876"></a>02876   <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l02877"></a><a class="code" href="structlibecc_1_1bitset__base.html#a7b18367cd32fc19431e26e944f1be52f">02877</a>   <a class="code" href="structlibecc_1_1bitset__base.html#a2c449fc9ce728be63620635f5acb39ce" title="Toggle a bit at a fixed position.">bitset_base&lt;N&gt;::flip</a>(<span class="keywordtype">size_t</span> pos)
<a name="l02878"></a>02878   {
<a name="l02879"></a>02879 <span class="preprocessor">#ifdef __i386__</span>
<a name="l02880"></a>02880 <span class="preprocessor"></span>    __asm__ __volatile__ (
<a name="l02881"></a>02881         <span class="stringliteral">&quot;btcl %1, %0&quot;</span>
<a name="l02882"></a>02882         : <span class="stringliteral">&quot;=m&quot;</span> ((*(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <span class="keyword">volatile</span>*)this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>))
<a name="l02883"></a>02883         : <span class="stringliteral">&quot;Ir&quot;</span> (pos)
<a name="l02884"></a>02884         : <span class="stringliteral">&quot;cc&quot;</span>
<a name="l02885"></a>02885     );
<a name="l02886"></a>02886 <span class="preprocessor">#else</span>
<a name="l02887"></a>02887 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = pos / bitset_digit_bits;
<a name="l02888"></a>02888     <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> mask = <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a><span class="keyword">&gt;</span>(1) &lt;&lt; (pos % bitset_digit_bits);
<a name="l02889"></a>02889     this-&gt;vector[d] ^= mask;
<a name="l02890"></a>02890 <span class="preprocessor">#endif</span>
<a name="l02891"></a>02891 <span class="preprocessor"></span>  }
<a name="l02892"></a>02892 
<a name="l02896"></a>02896 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02897"></a>02897   <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l02898"></a><a class="code" href="structlibecc_1_1bitset__base.html#a6452ad3e11c50916ae13525d0a50b4e7">02898</a>   <a class="code" href="structlibecc_1_1bitset__base.html#a2c449fc9ce728be63620635f5acb39ce" title="Toggle a bit at a fixed position.">bitset_base&lt;N&gt;::flip</a>(<a class="code" href="classlibecc_1_1bitset__index.html" title="A bitset index.">bitset_index</a> <span class="keyword">const</span>&amp; index)
<a name="l02899"></a>02899   {
<a name="l02900"></a>02900 <span class="preprocessor">#ifdef __i386__</span>
<a name="l02901"></a>02901 <span class="preprocessor"></span>    this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2c449fc9ce728be63620635f5acb39ce" title="Toggle a bit at a fixed position.">flip</a>(index.<a class="code" href="classlibecc_1_1bitset__index.html#ad97d9d24247e358eb528fd82b41976df">get_index</a>());
<a name="l02902"></a>02902 <span class="preprocessor">#else</span>
<a name="l02903"></a>02903 <span class="preprocessor"></span>    this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[index.get_digit()] ^= index.get_mask();
<a name="l02904"></a>02904 <span class="preprocessor">#endif</span>
<a name="l02905"></a>02905 <span class="preprocessor"></span>  }
<a name="l02906"></a>02906 
<a name="l02910"></a>02910 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02911"></a>02911   <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos&gt;
<a name="l02912"></a>02912     <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l02913"></a><a class="code" href="structlibecc_1_1bitset__base.html#a2c449fc9ce728be63620635f5acb39ce">02913</a>     <a class="code" href="structlibecc_1_1bitset__base.html#a2c449fc9ce728be63620635f5acb39ce" title="Toggle a bit at a fixed position.">bitset_base&lt;N&gt;::flip</a>(<span class="keywordtype">void</span>)
<a name="l02914"></a>02914     {
<a name="l02915"></a>02915       <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> d = pos / bitset_digit_bits;
<a name="l02916"></a>02916       <span class="keyword">static</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> <span class="keyword">const</span> mask = <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a><span class="keyword">&gt;</span>(1) &lt;&lt; (pos % bitset_digit_bits);
<a name="l02917"></a>02917       this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[d] ^= mask;
<a name="l02918"></a>02918     }
<a name="l02919"></a>02919 
<a name="l02923"></a>02923 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02924"></a>02924   <span class="keywordtype">bool</span>
<a name="l02925"></a><a class="code" href="structlibecc_1_1bitset__base.html#a27238b6dcce248896546f144b5500f7b">02925</a>   <a class="code" href="structlibecc_1_1bitset__base.html#a27238b6dcce248896546f144b5500f7b" title="Return true if any bit is set.">bitset_base&lt;N&gt;::any</a>(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l02926"></a>02926 <span class="keyword"> </span>{
<a name="l02927"></a>02927     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> to = bitset_base&lt;N&gt;::digits - 1;
<a name="l02928"></a>02928     <span class="keywordflow">if</span> (bitset_base&lt;N&gt;::digits &gt; 1)
<a name="l02929"></a>02929       <span class="keywordflow">do</span>
<a name="l02930"></a>02930       {
<a name="l02931"></a>02931         <span class="keywordflow">if</span> (this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[to] != 0)
<a name="l02932"></a>02932           <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02933"></a>02933         --to;
<a name="l02934"></a>02934       }
<a name="l02935"></a>02935       <span class="keywordflow">while</span>(to != 0);
<a name="l02936"></a>02936     <span class="keywordflow">return</span> (this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[0] != 0);
<a name="l02937"></a>02937   }
<a name="l02938"></a>02938 
<a name="l02939"></a>02939 <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> oddnumberofbits[] = {
<a name="l02940"></a>02940   <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>,
<a name="l02941"></a>02941   <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>,
<a name="l02942"></a>02942   <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>,
<a name="l02943"></a>02943   <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>,
<a name="l02944"></a>02944   <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>,
<a name="l02945"></a>02945   <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>,
<a name="l02946"></a>02946   <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>,
<a name="l02947"></a>02947   <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>,
<a name="l02948"></a>02948   <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>,
<a name="l02949"></a>02949   <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>,
<a name="l02950"></a>02950   <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>,
<a name="l02951"></a>02951   <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>,
<a name="l02952"></a>02952   <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>,
<a name="l02953"></a>02953   <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>,
<a name="l02954"></a>02954   <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>,
<a name="l02955"></a>02955   <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span> };
<a name="l02956"></a>02956 
<a name="l02960"></a>02960 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l02961"></a>02961   <span class="keywordtype">bool</span>
<a name="l02962"></a><a class="code" href="structlibecc_1_1bitset__base.html#afb0f9064c525944efa025eb309ec473c">02962</a>   <a class="code" href="structlibecc_1_1bitset__base.html#afb0f9064c525944efa025eb309ec473c" title="Returns true when the bitset contains an odd number of bits.">bitset_base&lt;N&gt;::odd</a>(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l02963"></a>02963 <span class="keyword"> </span>{
<a name="l02964"></a>02964     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> from = bitset_base&lt;N&gt;::digits - 1;
<a name="l02965"></a>02965     <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> sum = this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[0];
<a name="l02966"></a>02966     <span class="keywordflow">if</span> (bitset_base&lt;N&gt;::digits &gt; 1)
<a name="l02967"></a>02967       <span class="keywordflow">do</span>
<a name="l02968"></a>02968       {
<a name="l02969"></a>02969         sum ^= this-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e" title="The actual bits, stored as an array of digits  number of &amp;quot;digits&amp;quot; of type libecc::bitset_di...">vector</a>[from];
<a name="l02970"></a>02970         --from;
<a name="l02971"></a>02971       }
<a name="l02972"></a>02972       <span class="keywordflow">while</span>(from != 0);
<a name="l02973"></a>02973     <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> ssum = sum;
<a name="l02974"></a>02974     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>) &gt;= 2)
<a name="l02975"></a>02975     {
<a name="l02976"></a>02976       ssum &gt;&gt;= (bitset_digit_bits / 2);
<a name="l02977"></a>02977       sum ^= ssum;
<a name="l02978"></a>02978     }
<a name="l02979"></a>02979     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>) &gt;= 4)
<a name="l02980"></a>02980     {
<a name="l02981"></a>02981       ssum = sum;
<a name="l02982"></a>02982       ssum &gt;&gt;= (bitset_digit_bits / 4);
<a name="l02983"></a>02983       sum ^= ssum;
<a name="l02984"></a>02984     }
<a name="l02985"></a>02985     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>) &gt;= 8)
<a name="l02986"></a>02986     {
<a name="l02987"></a>02987       ssum = sum;
<a name="l02988"></a>02988       ssum &gt;&gt;= (bitset_digit_bits / 8);
<a name="l02989"></a>02989       sum ^= ssum;
<a name="l02990"></a>02990     }
<a name="l02991"></a>02991     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a>) == 16)
<a name="l02992"></a>02992     {
<a name="l02993"></a>02993       ssum = sum;
<a name="l02994"></a>02994       ssum &gt;&gt;= (bitset_digit_bits / 16);
<a name="l02995"></a>02995       sum ^= ssum;
<a name="l02996"></a>02996     }
<a name="l02997"></a>02997     <span class="keywordflow">return</span> oddnumberofbits[sum &amp; 0xff];
<a name="l02998"></a>02998   }
<a name="l02999"></a>02999 
<a name="l03003"></a><a class="code" href="structlibecc_1_1left.html">03003</a> <span class="keyword">struct</span><a class="code" href="structlibecc_1_1left.html" title="Shift direction used with libecc::bitset::shift_op.">left</a> {
<a name="l03004"></a>03004 <span class="keyword">public</span>:
<a name="l03005"></a>03005   <span class="keyword">typedef</span> <span class="keyword">struct</span><a class="code" href="structlibecc_1_1right.html" title="Shift direction used with libecc::bitset::shift_op.">right</a> inverse;
<a name="l03006"></a>03006   <span class="keyword">static</span> <span class="keywordtype">int</span> <span class="keyword">const</span> direction = -1;
<a name="l03007"></a>03007   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> __left = <span class="keyword">true</span>;
<a name="l03008"></a>03008   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> __right = <span class="keyword">false</span>;
<a name="l03009"></a>03009   <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> shift_copy(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> digit, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shift) { <span class="keywordflow">return</span> digit &lt;&lt; shift; }
<a name="l03010"></a>03010   <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> reverse_shift_copy(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> digit, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shift) { <span class="keywordflow">return</span> digit &gt;&gt; shift; }
<a name="l03011"></a>03011 };
<a name="l03012"></a>03012 
<a name="l03016"></a><a class="code" href="structlibecc_1_1right.html">03016</a> <span class="keyword">struct</span><a class="code" href="structlibecc_1_1right.html" title="Shift direction used with libecc::bitset::shift_op.">right</a> {
<a name="l03017"></a>03017 <span class="keyword">public</span>:
<a name="l03018"></a>03018   <span class="keyword">typedef</span> <span class="keyword">struct</span><a class="code" href="structlibecc_1_1left.html" title="Shift direction used with libecc::bitset::shift_op.">left</a> inverse;
<a name="l03019"></a>03019   <span class="keyword">static</span> <span class="keywordtype">int</span> <span class="keyword">const</span> direction = 1;
<a name="l03020"></a>03020   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> __left = <span class="keyword">false</span>;
<a name="l03021"></a>03021   <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> __right = <span class="keyword">true</span>;
<a name="l03022"></a>03022   <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> shift_copy(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> digit, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shift) { <span class="keywordflow">return</span> digit &gt;&gt; shift; }
<a name="l03023"></a>03023   <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> reverse_shift_copy(<a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">bitset_digit_t</a> digit, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shift) { <span class="keywordflow">return</span> digit &lt;&lt; shift; }
<a name="l03024"></a>03024 };
<a name="l03025"></a>03025 
<a name="l03034"></a>03034 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;
<a name="l03035"></a>03035   <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shift, <span class="keyword">class</span> DIRECTION&gt;
<a name="l03036"></a>03036     <span class="keywordtype">void</span>
<a name="l03037"></a><a class="code" href="classlibecc_1_1bitset.html#a67f603a1483afc9aee7fd9d076bc2c71">03037</a>     <a class="code" href="classlibecc_1_1bitset.html#a67f603a1483afc9aee7fd9d076bc2c71" title="Rotate bitset.">bitset&lt;N&gt;::rotate</a>(<a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset&lt;N&gt;</a>&amp; result)<span class="keyword"> const</span>
<a name="l03038"></a>03038 <span class="keyword">   </span>{
<a name="l03039"></a>03039       LibEccDout(dc::bitsetshift|flush_cf, <span class="stringliteral">&quot;Entering bitset&lt;&quot;</span> &lt;&lt; N &lt;&lt; <span class="stringliteral">&quot;&gt;::rotate&lt;&quot;</span> &lt;&lt; shift &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; type_info_of&lt;DIRECTION&gt;().demangled_name() &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span>);
<a name="l03040"></a>03040       LibEccDout(dc::bitsetshift|flush_cf, <span class="stringliteral">&quot;Rotate input : &quot;</span> &lt;&lt; cwprint_using(*<span class="keyword">this</span>, &amp;<a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset&lt;N&gt;::base2_print_on</a>));
<a name="l03041"></a>03041       shift_op&lt;shift % N, DIRECTION, rotate_phase1&gt;(result);
<a name="l03042"></a>03042       LibEccDout(dc::bitsetshift|flush_cf, <span class="stringliteral">&quot;After phase1 : &quot;</span> &lt;&lt; cwprint_using(result, &amp;<a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset&lt;N&gt;::base2_print_on</a>));
<a name="l03043"></a>03043       <a class="code" href="classlibecc_1_1bitset.html#a446a27809cd4cb9ed6e83629a3f328bc" title="Perform a shift operation followed by a bit operation.">shift_op</a>&lt;N - (shift % N), <span class="keyword">typename</span> DIRECTION::inverse, rotate_phase2&gt;(result);
<a name="l03044"></a>03044       LibEccDout(dc::bitsetshift|flush_cf, <span class="stringliteral">&quot;After phase2 : &quot;</span> &lt;&lt; cwprint_using(result, &amp;<a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset&lt;N&gt;::base2_print_on</a>));
<a name="l03045"></a>03045       LibEccDout(dc::bitsetshift|flush_cf, <span class="stringliteral">&quot;Leaving bitset&lt;&quot;</span> &lt;&lt; N &lt;&lt; <span class="stringliteral">&quot;&gt;::rotate&lt;&quot;</span> &lt;&lt; shift &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; type_info_of&lt;DIRECTION&gt;().demangled_name() &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span>);
<a name="l03046"></a>03046     }
<a name="l03047"></a>03047 
<a name="l03048"></a>03048 } <span class="comment">// namespace libecc</span>
<a name="l03049"></a>03049 
<a name="l03050"></a>03050 <span class="preprocessor">#endif // LIBECC_BITS_H</span>
</pre></div></div>
</div>
<address>Copyright &copy; 2002-2008 Carlo Wood.&nbsp; All rights reserved.</address>

</div>
</body>
</html>

