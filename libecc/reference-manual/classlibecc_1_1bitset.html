<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html LANG="en_US">

<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="Author" content="Carlo Wood">
<meta name="description" content="Elliptic Curve Cryptography C++ Library">
<meta name="keywords" content="libecc, fast, elliptic curves, cryptography, fixed key size, speed, object orientation, OO, C++">
<title>libecc: Elliptic Curve Cryptography C++ Library - Reference Manual</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<script src="../scripts/detect_browser.js"></script>
<script>need_style_doxygen=1</script>
<script src="../scripts/load_style_sheets.js"></script>
</head>

<body>
<div class="normal">

<center>
<a class="qindex" href="../index.html">Main Page</a> &nbsp;
<a class="qindex" href="index.html">Reference Manual</a> &nbsp;
<a class="qindex" href="annotated.html">Compound List</a> &nbsp;
<a class="qindex" href="files.html">File List</a> &nbsp;
</center>

<hr size=1 noshade>
<!-- Generated by Doxygen 1.7.1 -->
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacelibecc.html">libecc</a>      </li>
      <li><a class="el" href="classlibecc_1_1bitset.html">libecc::bitset&lt; N &gt;</a>      </li>
    </ul>
  </div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>libecc::bitset&lt; N &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="libecc::bitset" --><!-- doxytag: inherits="bitset_invertible&lt; N, false &gt;" -->
<p>A bitset with a fixed number of bits.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bitset_8h_source.html">libecc/bitset.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for libecc::bitset&lt; N &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlibecc_1_1bitset__inherit__graph.png" border="0" usemap="#libecc_1_1bitset_3_01N_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="libecc_1_1bitset_3_01N_01_4_inherit__map" id="libecc_1_1bitset_3_01N_01_4_inherit__map">
<area shape="rect" id="node10" href="classlibecc_1_1bitset.html" title="libecc::bitset\&lt; m \&gt;" alt="" coords="5,357,149,387"/><area shape="rect" id="node12" href="classlibecc_1_1bitset.html" title="libecc::bitset\&lt; 512 \&gt;" alt="" coords="173,357,328,387"/><area shape="rect" id="node2" href="classlibecc_1_1bitset__invertible.html" title="libecc::bitset_invertible\&lt; N, false \&gt;" alt="" coords="41,181,287,211"/><area shape="rect" id="node4" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset." alt="" coords="104,5,283,35"/><area shape="rect" id="node6" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&#39;s..." alt="" coords="180,85,447,115"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for libecc::bitset&lt; N &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlibecc_1_1bitset__coll__graph.png" border="0" usemap="#libecc_1_1bitset_3_01N_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="libecc_1_1bitset_3_01N_01_4_coll__map" id="libecc_1_1bitset_3_01N_01_4_coll__map">
<area shape="rect" id="node2" href="classlibecc_1_1bitset__invertible.html" title="libecc::bitset_invertible\&lt; N, false \&gt;" alt="" coords="5,181,251,211"/><area shape="rect" id="node4" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset." alt="" coords="68,5,247,35"/><area shape="rect" id="node6" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&#39;s..." alt="" coords="144,85,411,115"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classlibecc_1_1bitset-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset.html#a2f7c44b72136449f89e87c9065a50453">bitset</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an uninitialized bitset of <em>N</em> bits.  <a href="#a2f7c44b72136449f89e87c9065a50453"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset.html#a72e5eeef90293a462ce1da399dcbd8f5">bitset</a> (std::string const &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a bitset of <em>N</em> bits and initialize it with the string <em>input</em>, a hexadecimal value in ASCII representation.  <a href="#a72e5eeef90293a462ce1da399dcbd8f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset.html#a16bd92d1be8fae9482e0058a8a7f8091">bitset</a> (<a class="el" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d">bitset_digit_t</a> low_bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a bitset of which only the least significant bits are set.  <a href="#a16bd92d1be8fae9482e0058a8a7f8091"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset.html#aabd8efbff263c8de6eae78608714df1c">bitset</a> (<a class="el" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d">bitset_digit_t</a> const (&amp;v)[<a class="el" href="structlibecc_1_1bitset__base.html">bitset_base</a>&lt; N &gt;::<a class="el" href="structlibecc_1_1bitset__base.html#a70219fdf047ad3dcd08b3332c6ff843a">digits</a>])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a bitset directly from an array of <a class="el" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d">bitset_digit_t</a>.  <a href="#aabd8efbff263c8de6eae78608714df1c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int m, bool inverted&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset.html#a64e4720ffb677ab4fc72306407a58f87">bitset</a> (<a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted &gt; const &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#a64e4720ffb677ab4fc72306407a58f87"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int m, bool i1, bool i2, typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset.html#a7d9babce747d7cd2ea411c42525b6db3">bitset</a> (Operator::bitsetExpression&lt; m, i1, i2, OP &gt; const &amp;expr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a bitset from an expression.  <a href="#a7d9babce747d7cd2ea411c42525b6db3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Expression &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1bitset.html">bitset</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset.html#a810b912f226ec3df16eb4bba784f387c">operator=</a> (Expression const &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator.  <a href="#a810b912f226ec3df16eb4bba784f387c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Expression &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1bitset.html">bitset</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset.html#ac0c6bda20427dcce74cd899bd46f43d0">operator&amp;=</a> (Expression const &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator with bitwise AND.  <a href="#ac0c6bda20427dcce74cd899bd46f43d0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Expression &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1bitset.html">bitset</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset.html#af6650b8defe1d4c5083405333b2171bc">operator|=</a> (Expression const &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator with bitwise OR.  <a href="#af6650b8defe1d4c5083405333b2171bc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Expression &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1bitset.html">bitset</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset.html#a7cf1f21496f68eab1f803dc8d55402a6">operator^=</a> (Expression const &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator with bitwise XOR.  <a href="#a7cf1f21496f68eab1f803dc8d55402a6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int shift, class DIRECTION , class OPERATION &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset.html#a446a27809cd4cb9ed6e83629a3f328bc">shift_op</a> (<a class="el" href="classlibecc_1_1bitset.html">bitset</a> &amp;result) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a shift operation followed by a bit operation.  <a href="#a446a27809cd4cb9ed6e83629a3f328bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1bitset.html">bitset</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset.html#aa5a412d599bacae10b747be1d86f8510">operator&lt;&lt;=</a> (unsigned int shift)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shift bitset <em>shift</em> bits to the left.&nbsp; Use the faster <a class="el" href="classlibecc_1_1bitset.html#a446a27809cd4cb9ed6e83629a3f328bc">bitset::shift_op</a> for constant distance shifts.  <a href="#aa5a412d599bacae10b747be1d86f8510"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1bitset.html">bitset</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset.html#a12019bb8406e15d16ce7b31edc03d4ae">operator&gt;&gt;=</a> (unsigned int shift)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shift bitset <em>shift</em> bits to the right.&nbsp; Use the faster <a class="el" href="classlibecc_1_1bitset.html#a446a27809cd4cb9ed6e83629a3f328bc">bitset::shift_op</a> for constant distance shifts.  <a href="#a12019bb8406e15d16ce7b31edc03d4ae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int shift, class DIRECTION &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset.html#a67f603a1483afc9aee7fd9d076bc2c71">rotate</a> (<a class="el" href="classlibecc_1_1bitset.html">bitset</a> &amp;result) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate bitset.  <a href="#a67f603a1483afc9aee7fd9d076bc2c71"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;unsigned int N&gt;<br/>
 class libecc::bitset&lt; N &gt;</h3>

<p>A bitset with a fixed number of bits. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>The number of bits in the bitset. </td></tr>
  </table>
  </dd>
</dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2f7c44b72136449f89e87c9065a50453"></a><!-- doxytag: member="libecc::bitset::bitset" ref="a2f7c44b72136449f89e87c9065a50453" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset.html">libecc::bitset</a>&lt; N &gt;::<a class="el" href="classlibecc_1_1bitset.html">bitset</a> </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct an uninitialized bitset of <em>N</em> bits. </p>

<p>Referenced by <a class="el" href="namespacelibecc.html#a8b8aae3b135c4b928cf7caacfc21ddda">libecc::operator&gt;&gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a72e5eeef90293a462ce1da399dcbd8f5"></a><!-- doxytag: member="libecc::bitset::bitset" ref="a72e5eeef90293a462ce1da399dcbd8f5" args="(std::string const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset.html">libecc::bitset</a>&lt; N &gt;::<a class="el" href="classlibecc_1_1bitset.html">bitset</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a bitset of <em>N</em> bits and initialize it with the string <em>input</em>, a hexadecimal value in ASCII representation. </p>
<p><em>Input</em> is a string of alphanumeric characters ([0-9A-F]) not case sensitive. The input string is read right to left. Any non-space character that is not a hexadecimal digit will terminate reading.</p>
<p>Spaces will be ignored, allowing one to write for example "<code>C20 93B0D12C F78A9001 F6E2841F 0A918FCD</code>" instead of the less readable "<code>C2093B0D12CF78A9001F6E2841F0A918FCD</code>". It is common practise to let each "word" represent an internal digit (32 bits in this example).</p>
<p>If the value passed is larger than fits in the bitset then the most significant bits (the left most characters) are ignored as if the value <em>did</em> fit and then a bit-wise AND was performed with a bitset of <em>N</em> 1's.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>A hexadecimal value in ASCII representation. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structlibecc_1_1bitset__base.html#a546fff5ea210a08046d3429642bd0cf4">libecc::bitset_base&lt; N &gt;::reset()</a>, and <a class="el" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e">libecc::bitset_base&lt; N &gt;::vector</a>.</p>

</div>
</div>
<a class="anchor" id="a16bd92d1be8fae9482e0058a8a7f8091"></a><!-- doxytag: member="libecc::bitset::bitset" ref="a16bd92d1be8fae9482e0058a8a7f8091" args="(bitset_digit_t low_bits)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset.html">libecc::bitset</a>&lt; N &gt;::<a class="el" href="classlibecc_1_1bitset.html">bitset</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d">bitset_digit_t</a>&nbsp;</td>
          <td class="paramname"> <em>low_bits</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a bitset of which only the least significant bits are set. </p>
<p><em>low_bits</em> must never have more bits set than the size of the bitset N. </p>

<p>References <a class="el" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e">libecc::bitset_base&lt; N &gt;::vector</a>.</p>

</div>
</div>
<a class="anchor" id="aabd8efbff263c8de6eae78608714df1c"></a><!-- doxytag: member="libecc::bitset::bitset" ref="aabd8efbff263c8de6eae78608714df1c" args="(bitset_digit_t const (&amp;v)[bitset_base&lt; N &gt;::digits])" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset.html">libecc::bitset</a>&lt; N &gt;::<a class="el" href="classlibecc_1_1bitset.html">bitset</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d">bitset_digit_t</a> const (&amp;)&nbsp;</td>
          <td class="paramname"> <em>v</em>[bitset_base&lt; N &gt;::digits]</td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a bitset directly from an array of <a class="el" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d">bitset_digit_t</a>. </p>
<p>The excess bits of the most significant digit (if any) must be zero. </p>

</div>
</div>
<a class="anchor" id="a64e4720ffb677ab4fc72306407a58f87"></a><!-- doxytag: member="libecc::bitset::bitset" ref="a64e4720ffb677ab4fc72306407a58f87" args="(bitset_invertible&lt; m, inverted &gt; const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<div class="memtemplate">
template&lt;unsigned int m, bool inverted&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset.html">libecc::bitset</a>&lt; N &gt;::<a class="el" href="classlibecc_1_1bitset.html">bitset</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>bits</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>The least significant bit (at position 0) of <em>bits</em> and the constructed bitset are lined up. If <em>bits</em> is wider than the constructed bitset then excess bits are lost; if narrower then missing bits are set to <em>inverted</em>. That is, set to zero when <em>bits</em> is not inverted and set to one when <em>bits</em> represents an inverted bitset.</p>
<p>For example, when x is "0000000010001111" (16 bits), y is "10000000" (8 bits), then</p>
<div class="fragment"><pre class="fragment"> x ^= ~y;
</pre></div><p>results in x being "1111111111110000". </p>

</div>
</div>
<a class="anchor" id="a7d9babce747d7cd2ea411c42525b6db3"></a><!-- doxytag: member="libecc::bitset::bitset" ref="a7d9babce747d7cd2ea411c42525b6db3" args="(Operator::bitsetExpression&lt; m, i1, i2, OP &gt; const &amp;expr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<div class="memtemplate">
template&lt;unsigned int m, bool i1, bool i2, typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset.html">libecc::bitset</a>&lt; N &gt;::<a class="el" href="classlibecc_1_1bitset.html">bitset</a> </td>
          <td>(</td>
          <td class="paramtype">Operator::bitsetExpression&lt; m, i1, i2, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a bitset from an expression. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>bitset::operator= </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac0c6bda20427dcce74cd899bd46f43d0"></a><!-- doxytag: member="libecc::bitset::operator&amp;=" ref="ac0c6bda20427dcce74cd899bd46f43d0" args="(Expression const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<div class="memtemplate">
template&lt;typename Expression &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; N &gt; &amp; <a class="el" href="classlibecc_1_1bitset.html">libecc::bitset</a>&lt; N &gt;::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">Expression const &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator with bitwise AND. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>bitset::operator= </dd></dl>

</div>
</div>
<a class="anchor" id="aa5a412d599bacae10b747be1d86f8510"></a><!-- doxytag: member="libecc::bitset::operator&lt;&lt;=" ref="aa5a412d599bacae10b747be1d86f8510" args="(unsigned int shift)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset.html">bitset</a>&amp; <a class="el" href="classlibecc_1_1bitset.html">libecc::bitset</a>&lt; N &gt;::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>shift</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shift bitset <em>shift</em> bits to the left.&nbsp; Use the faster <a class="el" href="classlibecc_1_1bitset.html#a446a27809cd4cb9ed6e83629a3f328bc">bitset::shift_op</a> for constant distance shifts. </p>

<p>Reimplemented from <a class="el" href="structlibecc_1_1bitset__base.html">libecc::bitset_base&lt; N &gt;</a>.</p>

<p>Referenced by <a class="el" href="classlibecc_1_1bitset.html#aa5a412d599bacae10b747be1d86f8510">libecc::bitset&lt; 512 &gt;::operator&lt;&lt;=()</a>.</p>

</div>
</div>
<a class="anchor" id="a810b912f226ec3df16eb4bba784f387c"></a><!-- doxytag: member="libecc::bitset::operator=" ref="a810b912f226ec3df16eb4bba784f387c" args="(Expression const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<div class="memtemplate">
template&lt;typename Expression &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; N &gt; &amp; <a class="el" href="classlibecc_1_1bitset.html">libecc::bitset</a>&lt; N &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">Expression const &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator. </p>
<p>The least significant bits (at position 0) of <em>expr</em> and this bitset are lined up. If <em>expr</em> is wider than this bitset then excess bits are lost; if narrower then missing bits are set to zero or one depending on whether the expression contains inversion bits.</p>
<p>For example, when x is "0000000010001111" (16 bits), y is "10000000" (8 bits) and z is "11110110" (8 bits), then</p>
<div class="fragment"><pre class="fragment"> x ^= ~y;
</pre></div><p>results in x being "1111111111110000". And</p>
<div class="fragment"><pre class="fragment"> x |= ~y ^ ~z;
</pre></div><p>results in x being "0000000001110110". </p>

</div>
</div>
<a class="anchor" id="a12019bb8406e15d16ce7b31edc03d4ae"></a><!-- doxytag: member="libecc::bitset::operator&gt;&gt;=" ref="a12019bb8406e15d16ce7b31edc03d4ae" args="(unsigned int shift)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset.html">bitset</a>&amp; <a class="el" href="classlibecc_1_1bitset.html">libecc::bitset</a>&lt; N &gt;::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>shift</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shift bitset <em>shift</em> bits to the right.&nbsp; Use the faster <a class="el" href="classlibecc_1_1bitset.html#a446a27809cd4cb9ed6e83629a3f328bc">bitset::shift_op</a> for constant distance shifts. </p>

<p>Reimplemented from <a class="el" href="structlibecc_1_1bitset__base.html">libecc::bitset_base&lt; N &gt;</a>.</p>

<p>Referenced by <a class="el" href="classlibecc_1_1bitset.html#a12019bb8406e15d16ce7b31edc03d4ae">libecc::bitset&lt; 512 &gt;::operator&gt;&gt;=()</a>.</p>

</div>
</div>
<a class="anchor" id="a7cf1f21496f68eab1f803dc8d55402a6"></a><!-- doxytag: member="libecc::bitset::operator^=" ref="a7cf1f21496f68eab1f803dc8d55402a6" args="(Expression const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<div class="memtemplate">
template&lt;typename Expression &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; N &gt; &amp; <a class="el" href="classlibecc_1_1bitset.html">libecc::bitset</a>&lt; N &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype">Expression const &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator with bitwise XOR. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>bitset::operator= </dd></dl>

</div>
</div>
<a class="anchor" id="af6650b8defe1d4c5083405333b2171bc"></a><!-- doxytag: member="libecc::bitset::operator|=" ref="af6650b8defe1d4c5083405333b2171bc" args="(Expression const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<div class="memtemplate">
template&lt;typename Expression &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; N &gt; &amp; <a class="el" href="classlibecc_1_1bitset.html">libecc::bitset</a>&lt; N &gt;::operator|= </td>
          <td>(</td>
          <td class="paramtype">Expression const &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator with bitwise OR. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>bitset::operator= </dd></dl>

</div>
</div>
<a class="anchor" id="a67f603a1483afc9aee7fd9d076bc2c71"></a><!-- doxytag: member="libecc::bitset::rotate" ref="a67f603a1483afc9aee7fd9d076bc2c71" args="(bitset &amp;result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<div class="memtemplate">
template&lt;unsigned int shift, class DIRECTION &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibecc_1_1bitset.html">libecc::bitset</a>&lt; N &gt;::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate bitset. </p>
<p>Rotate bitset <em>shift</em> bits in <em>DIRECTION</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>shift</em>&nbsp;</td><td>The number of bits to rotate this bitset. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DIRECTION</em>&nbsp;</td><td>The direction into which this bitset must be rotated, can be <a class="el" href="structlibecc_1_1left.html" title="Shift direction used with libecc::bitset::shift_op.">libecc::left</a> or <a class="el" href="structlibecc_1_1right.html" title="Shift direction used with libecc::bitset::shift_op.">libecc::right</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result of the rotation. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classlibecc_1_1bitset.html#a446a27809cd4cb9ed6e83629a3f328bc">libecc::bitset&lt; N &gt;::shift_op()</a>.</p>

</div>
</div>
<a class="anchor" id="a446a27809cd4cb9ed6e83629a3f328bc"></a><!-- doxytag: member="libecc::bitset::shift_op" ref="a446a27809cd4cb9ed6e83629a3f328bc" args="(bitset &amp;result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<div class="memtemplate">
template&lt;unsigned int shift, class DIRECTION , class OPERATION &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibecc_1_1bitset.html">libecc::bitset</a>&lt; N &gt;::shift_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a shift operation followed by a bit operation. </p>
<p>Shift this object <em>shift</em> bits in <em>DIRECTION</em> and then perform operation <em>OPERATION</em> on <em>result</em> with it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>shift</em>&nbsp;</td><td>the number of bits to shift this object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DIRECTION</em>&nbsp;</td><td>can be <a class="el" href="structlibecc_1_1left.html" title="Shift direction used with libecc::bitset::shift_op.">libecc::left</a> or <a class="el" href="structlibecc_1_1right.html" title="Shift direction used with libecc::bitset::shift_op.">libecc::right</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OPERATION</em>&nbsp;</td><td>can be either <a class="el" href="structlibecc_1_1assign.html" title="Operation used with libecc::bitset::shift_op.">libecc::assign</a> or <a class="el" href="structlibecc_1_1exor.html" title="Operation used with libecc::bitset::shift_op.">libecc::exor</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The bitset that is used to XOR with, or to assign to. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classlibecc_1_1bitset__invertible.html#a9bf8dafb22ff7f9dd53721fadea6f1bb">libecc::bitset_invertible&lt; N, false &gt;::digit()</a>, and <a class="el" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e">libecc::bitset_base&lt; N &gt;::vector</a>.</p>

<p>Referenced by <a class="el" href="classlibecc_1_1bitset.html#a67f603a1483afc9aee7fd9d076bc2c71">libecc::bitset&lt; N &gt;::rotate()</a>.</p>

</div>
</div>
</div>
<address>Copyright &copy; 2002-2008 Carlo Wood.&nbsp; All rights reserved.</address>

</div>
</body>
</html>

