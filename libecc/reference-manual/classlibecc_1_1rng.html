<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html LANG="en_US">

<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="Author" content="Carlo Wood">
<meta name="description" content="Elliptic Curve Cryptography C++ Library">
<meta name="keywords" content="libecc, fast, elliptic curves, cryptography, fixed key size, speed, object orientation, OO, C++">
<title>libecc: Elliptic Curve Cryptography C++ Library - Reference Manual</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<script src="../scripts/detect_browser.js"></script>
<script>need_style_doxygen=1</script>
<script src="../scripts/load_style_sheets.js"></script>
</head>

<body>
<div class="normal">

<center>
<a class="qindex" href="../index.html">Main Page</a> &nbsp;
<a class="qindex" href="index.html">Reference Manual</a> &nbsp;
<a class="qindex" href="annotated.html">Compound List</a> &nbsp;
<a class="qindex" href="files.html">File List</a> &nbsp;
</center>

<hr size=1 noshade>
<!-- Generated by Doxygen 1.7.1 -->
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacelibecc.html">libecc</a>      </li>
      <li><a class="el" href="classlibecc_1_1rng.html">libecc::rng</a>      </li>
    </ul>
  </div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<h1>libecc::rng Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="libecc::rng" -->
<p>Pseudo Random Number Generator.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rng_8h_source.html">libecc/rng.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for libecc::rng:</div>
<div class="dyncontent">
<div class="center"><img src="classlibecc_1_1rng__coll__graph.png" border="0" usemap="#libecc_1_1rng_coll__map" alt="Collaboration graph"/></div>
<map name="libecc_1_1rng_coll__map" id="libecc_1_1rng_coll__map">
<area shape="rect" id="node2" href="classlibecc_1_1bitset.html" title="libecc::bitset\&lt; 512 \&gt;" alt="" coords="72,357,227,387"/><area shape="rect" id="node4" href="classlibecc_1_1bitset__invertible.html" title="libecc::bitset_invertible\&lt; N, false \&gt;" alt="" coords="5,181,251,211"/><area shape="rect" id="node11" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits." alt="" coords="149,261,291,291"/><area shape="rect" id="node6" href="structlibecc_1_1bitset__base.html" title="Base class of libecc::bitset." alt="" coords="68,5,247,35"/><area shape="rect" id="node8" href="classlibecc_1_1bitset__invertible.html" title="A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1&#39;s..." alt="" coords="144,85,411,115"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classlibecc_1_1rng-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; <a class="el" href="classlibecc_1_1rng.html#a846512228cdfa61ff3b9eb4011b1e45b">S_pool_size</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1rng.html#a3d7c1db3f11c9cbe9db3513866fbb23f">pool_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the constructor argument.  <a href="#a3d7c1db3f11c9cbe9db3513866fbb23f"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1rng.html#a70d9a111410f375721521efd5a7a9d74">rng</a> (<a class="el" href="classlibecc_1_1bitset.html">pool_type</a> const &amp;seed)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a70d9a111410f375721521efd5a7a9d74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1rng.html#af98129268ed22e3b396fca68f610646f">generate_512_bits</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate 512 bits.  <a href="#af98129268ed22e3b396fca68f610646f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; 512 &gt; const &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1rng.html#ad85b236f2f01c223d9512ed95996406a">get_512_bits</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a reference to the 512 bits that were generated with a call to <a class="el" href="classlibecc_1_1rng.html#af98129268ed22e3b396fca68f610646f" title="Generate 512 bits.">rng::generate_512_bits()</a>.  <a href="#ad85b236f2f01c223d9512ed95996406a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1rng.html#a15c9a252f22046ba8d64a3e0a4e94f26">add_entropy</a> (uint32_t const *noise, unsigned int number_of_ints)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add entropy to the random number generator pool.  <a href="#a15c9a252f22046ba8d64a3e0a4e94f26"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int n&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibecc_1_1rng.html#af93e2efa883deddba267db6e993cb7f1">add_entropy</a> (<a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; n &gt; const noise)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add entropy from a bitset.  <a href="#af93e2efa883deddba267db6e993cb7f1"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned int const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1rng.html#a846512228cdfa61ff3b9eb4011b1e45b">S_pool_size</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pool size in bits. This RNG uses a pool of 521 bits.  <a href="#a846512228cdfa61ff3b9eb4011b1e45b"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Pseudo Random Number Generator. </p>
<p>This random number generator was designed from scratch. It is fast (2.5 million bit/second on a 900 Mhz PC), has a long period (2^521 - 1) and passes all known statistical tests for randomness.&nbsp;</p>
<dl class="note"><dt><b>Note:</b></dt><dd> <FONT size=-1> The chosen period of 2^521 - 1 is by far large enough for any purpose; when 15 billion people each using 10,000 PCs with a clock frequency of 100 Ghz generate random numbers for the next 10 million years - then the chance that <em>any</em> two of them ever generated a (partly) overlapping sequence of bits is less than 0.000...(108&nbsp;zeroes)...0001.&nbsp; In order words, if you chose a good random seed, you <em>will</em> be the only one who ever uses the resulting sequence of output bits.  </FONT></dd></dl>
<h4>Theory</h4>
<p>The basis of this Random Number Generator (RNG) is a shift register of 521 bit using nine feedback points.&nbsp; Because such a feedback is linear, it is possible to write any amount of shift as <code>&nbsp;NEWSTATE = MATRIX * OLDSTATE</code>.&nbsp; The matrix that corresponds with a single shift can easily be determined as function of the feedback points.&nbsp; Let's call this matrix <code>&nbsp;M0</code>.&nbsp; The matrix corresponding to a shift of 2 then corresponds to <code>&nbsp;M1 = M0 * M0</code>.&nbsp; A shift of 4 corresponds to <code>&nbsp;M2 = M1 * M1</code>, etcetera.</p>
<p>The period of the RNG will be equal to the number of different internal states that will be used.&nbsp; In the optimal case all possible internal states, except all zeroes which would lead to an output of only zeroes, will be used and the period of the RNG will be equal to 2<sup>521</sup> - 1.&nbsp; This hypothesis can be checked by confirming that <code>M521 = M0<sup>2<sup>521</sup></sup> == M0&nbsp;</code> and because 2<sup>521</sup> - 1 is a prime this value then must be the real period of the RNG.&nbsp; Of course, one of the feedback points is fixed at bit 520 (feeding to bit 0).&nbsp; By choosing the other feedback points close to bit 0, a very fast mangling of the bits is achieved.</p>
<dl class="note"><dt><b>Note:</b></dt><dd> <FONT size=-1> Even with a seed of '1' (a single bit) the first resulting 512 bits of output appear to be totally random already.&nbsp; After 9 calls to <a class="el" href="classlibecc_1_1rng.html#af98129268ed22e3b396fca68f610646f" title="Generate 512 bits.">generate_512_bits()</a>, each bit in the pool has been set at least once.&nbsp;  </FONT></dd></dl>
<h5>Verifying the period, an example</h5>
<p>Suppose we have a shift register of 3 bits (2<sup>3</sup>-1 = 7 is a prime).&nbsp; Let's use one feedback point from bit 1 (and from bit 2 of course), then we have:</p>
<pre>
 bit        0    1    2(output)
 state0:    a    b    c
 state1:    b    c   a^b
 state2:    c   a^b  b^c
   ...
 </pre><p>Which gives, with a starting seed of 001:</p>
<pre>
 001
 010
 101
 011
 111
 110
 100
 and back to the top
 </pre><p>Or rotated 90 degrees:</p>
<pre>
 bit
  0  0010111
  1  0101110
  2  1011100
 </pre><p>Each column can be considered as a vector:</p>
<pre>
 a
 b
 c
 </pre><p>The matrix representing one shift now is:</p>
<pre>
 m11 m12 m13  a   a m11 + b m12 + c m13    b
 m21 m22 m23  b = a m21 + b m22 + c m23 =  c
 m31 m32 m33  c   a m31 + b m32 + c m33    a+b mod 2 = a^b
 </pre><p>From which we can deduce the matrix</p>
<pre>
      0 1 0
 M0 = 0 0 1
      1 1 0
 </pre><p>and that we have to do our calculation modulo 2.</p>
<p>Note that</p>
<pre>
                0 1 0   0 1 0   0 0 1
 M1 = M0 * M0 = 0 0 1   0 0 1 = 1 1 0
                1 1 0   1 1 0   0 1 1</pre><pre>                0 0 1   0 0 1   0 1 1
 M2 = M1 * M1 = 1 1 0   1 1 0 = 1 1 1
                0 1 1   0 1 1   1 0 1
 </pre><p>and</p>
<pre>
                0 1 1   0 1 1   0 1 0
 M3 = M2 * M2 = 1 1 1   1 1 1 = 0 0 1 = M0
                1 0 1   1 0 1   1 1 0</pre><pre> </pre><p>Which proves that this repeats after 2<sup>3</sup>-1 = 7 times.</p>
<h5>Predictability</h5>
<p>Because the state of the RNG changes in a linear way (we can use matrices), the output is predictable: the internal state can be calculated from a small amount of output.</p>
<p>In the above example assume that the RNG produces the output sequence xyz.&nbsp; If the orginal state was abc then after three bits of output the state would be:</p>
<pre>
       a   0 1 0   0 0 1   a   1 1 0   a   a+b
 M0 M1 b = 0 0 1   1 1 0   b = 0 1 1   b = b+c      (mod 2)
       c   1 1 0   0 1 1   c   1 1 1   c   a+b+c
 </pre><p>while the output would be</p>
<pre>
 x   0 0 1   <sup> </sup> a     0 0 0   <sup> </sup> a     0 0 0   <sup> </sup> a   1 1 0  a
 y = 0 0 0 M0<sup>1</sup> b  +  0 0 1 M0<sup>2</sup> b  +  0 0 0 M0<sup>3</sup> b = 0 1 1  b
 z   0 0 0   <sup> </sup> c     0 0 0   <sup> </sup> c     0 0 1   <sup> </sup> c   1 1 1  c
 </pre><p>The inverse of the latter allows one to crack the RNG (calculate the current state from x,y,z).</p>
<h5>Matrix compression</h5>
<p>Although it might sound easy to check if the period of a given RNG is maximal, in practise it still isn't when we want to use a huge number of bits.&nbsp; I wrote a program that does 4 Gigabit operations per second, it was therefore able to do 3 times 127 matrix multiplications of 127x127 matrices per second.&nbsp; That means that it is reasonably fast to look for working feedback points.&nbsp; Let's say, one minute was enough.&nbsp; But if then we try to use this program to find feedback points for a shift register of 1279 bits, it suddenly takes (1279/127)<sup>4</sup> = 10286 minutes = 1 week! And 1279 bits is <em>still</em> not really big...&nbsp; Moreover, storing large matrices uses a lot of memory.&nbsp; A matrix of 19937 bits (2<sup>19937</sup> - 1 is the period of the <a href="http://www.math.keio.ac.jp/~matumoto/emt.html">Mersenne Twister</a>) would use 47.4 Mb per matrix already.</p>
<p>Fortunately, the matrices that we need to prove the period of are not arbitrary.&nbsp; As can be deduced from the paragraphs above, M0 can be written as</p>
<pre>
      0 1 0 0 0 0 0 ... 0 0
      0 0 1 0 0 0 0 ... 0 0
      0 0 0 1 0 0 0 ... 0 0
            .&nbsp;
 M0 =       .&nbsp;
            .&nbsp;
      0 0 0 0 0 0 0 ... 1 0
      0 0 0 0 0 0 0 ... 0 1
      1 0 0 ... 1 ... 1 ...
 </pre><p>Where the 1's on the bottom row are at the feedback point places.</p>
<p>As a result, we can write M0 (for a pxp matrix) as a vector of rows as follows</p>
<pre>
       (0 1 0 0 0 0 0 ... 0)
       (0 1 0 0 0 0 0 ... 0) M0<sup>1</sup>
       (0 1 0 0 0 0 0 ... 0) M0<sup>2</sup>
       (0 1 0 0 0 0 0 ... 0) M0<sup>3</sup>
 M0 =       .&nbsp;
            .&nbsp;
            .&nbsp;
       (0 1 0 0 0 0 0 ... 0) M0<sup>p-1</sup>
 </pre><p>If we multiply this an arbitrary number of times with M0 (say k times), then we get:</p>
<pre>
      <sup> </sup>   (0 1 0 0 0 0 0 ... 0) M0<sup>k&nbsp;</sup>           (0 1 0 0 0 0 0 ... 0) M0<sup>k</sup>
      <sup> </sup>   (0 1 0 0 0 0 0 ... 0) M0<sup>1</sup> M0<sup>k</sup>        (0 1 0 0 0 0 0 ... 0) M0<sup>k</sup> M0<sup>1</sup>
      <sup> </sup>   (0 1 0 0 0 0 0 ... 0) M0<sup>2</sup> M0<sup>k</sup>        (0 1 0 0 0 0 0 ... 0) M0<sup>k</sup> M0<sup>2</sup>
      <sup> </sup>   (0 1 0 0 0 0 0 ... 0) M0<sup>3</sup> M0<sup>k</sup>        (0 1 0 0 0 0 0 ... 0) M0<sup>k</sup> M0<sup>3</sup>
 M0 M0<sup>k</sup> =       .&nbsp;                        =          .&nbsp;
      <sup> </sup>         .&nbsp;                                   .&nbsp;
      <sup> </sup>         .&nbsp;                                   .&nbsp;
      <sup> </sup>   (0 1 0 0 0 0 0 ... 0) M0<sup>p-1</sup> M0<sup>k</sup>       (0 1 0 0 0 0 0 ... 0) M0<sup>k</sup> M0<sup>p-1</sup>
 </pre><p>which proves that every matrix that is a power of M0 can be expressed in terms of the top row of the matrix and M0 as follows:</p>
<pre>
 Row(N+1) = Row(N) M0
 </pre><p><b>Example</b></p>
<p>Consider a RNG of 7 bits with a single feedback points at bit 7 - 3 = 4.&nbsp; The first 7 powers of M0 for that RNG are</p>
<pre>
   <sup> </sup>   1 0 0 0 0 0 0
   <sup> </sup>   <b>0 1 0 0 0 0 0</b>
   <sup> </sup>   0 0 1 0 0 0 0
 M0<sup>0</sup> = 0 0 0 1 0 0 0
   <sup> </sup>   0 0 0 0 1 0 0
   <sup> </sup>   0 0 0 0 0 1 0
   <sup> </sup>   0 0 0 0 0 0 1</pre><pre>   <sup> </sup>   0 1 0 0 0 0 0       <sup> </sup>   0 0 1 0 0 0 0       <sup> </sup>   0 0 0 1 0 0 0
   <sup> </sup>   <b>0 0 1 0 0 0 0</b>       <sup> </sup>   <b>0 0 0 1 0 0 0</b>       <sup> </sup>   <b>0 0 0 0 1 0 0</b>
   <sup> </sup>   0 0 0 1 0 0 0       <sup> </sup>   0 0 0 0 1 0 0       <sup> </sup>   0 0 0 0 0 1 0
 M0<sup>1</sup> = 0 0 0 0 1 0 0  ,  M0<sup>2</sup> = 0 0 0 0 0 1 0  ,  M0<sup>3</sup> = 0 0 0 0 0 0 1
   <sup> </sup>   0 0 0 0 0 1 0       <sup> </sup>   0 0 0 0 0 0 1       <sup> </sup>   1 0 0 0 1 0 0
   <sup> </sup>   0 0 0 0 0 0 1       <sup> </sup>   1 0 0 0 1 0 0       <sup> </sup>   0 1 0 0 0 1 0
   <sup> </sup>   1 0 0 0 1 0 0       <sup> </sup>   0 1 0 0 0 1 0       <sup> </sup>   0 0 1 0 0 0 1</pre><pre>   <sup> </sup>   0 0 0 0 1 0 0      <sup> </sup>   0 0 0 0 0 1 0       <sup> </sup>   0 0 0 0 0 0 1
   <sup> </sup>   <b>0 0 0 0 0 1 0</b>      <sup> </sup>   <b>0 0 0 0 0 0 1</b>       <sup> </sup>   <b>1 0 0 0 1 0 0</b>
   <sup> </sup>   0 0 0 0 0 0 1      <sup> </sup>   1 0 0 0 1 0 0       <sup> </sup>   0 1 0 0 0 1 0
 M0<sup>4</sup> = 1 0 0 0 1 0 0 ,  M0<sup>5</sup> = 0 1 0 0 0 1 0  ,  M0<sup>6</sup> = 0 0 1 0 0 0 1
   <sup> </sup>   0 1 0 0 0 1 0      <sup> </sup>   0 0 1 0 0 0 1       <sup> </sup>   1 0 0 1 1 0 0
   <sup> </sup>   0 0 1 0 0 0 1      <sup> </sup>   1 0 0 1 1 0 0       <sup> </sup>   0 1 0 0 1 1 0
   <sup> </sup>   1 0 0 1 1 0 0      <sup> </sup>   0 1 0 0 1 1 0       <sup> </sup>   0 0 1 0 0 1 1
 </pre><p>And indeed, each second row of a sequential power of M0 is equivalent to a next row of M0 itself.</p>
<p>Now let's consider an arbitrary power k of M0 (in the example below k = 48).</p>
<pre>
   <sup> </sup>   <b>0 0 1 1 0 1 0</b>
   <sup> </sup>   0 0 0 1 1 0 1
   <sup> </sup>   1 0 0 0 0 1 0
 M0<sup>k</sup> = 0 1 0 0 0 0 1
   <sup> </sup>   1 0 1 0 1 0 0
   <sup> </sup>   0 1 0 1 0 1 0
   <sup> </sup>   0 0 1 0 1 0 1
 </pre><p>and let's call the first row C<sub>k</sub><sup>T</sup></p>
<pre>
  <sub> </sub>   0
  <sub> </sub>   0
  <sub> </sub>   1
 C<sub>k</sub> = 1
  <sub> </sub>   0
  <sub> </sub>   1
  <sub> </sub>   0
 </pre><p>then</p>
<pre>
 M0<sup>k</sup> = C<sub>k</sub><sup>T</sup> P
 </pre><p>where <code>P</code> is the vector of matrices</p>
<pre>
     M0<sup>0</sup>
     M0<sup>1</sup>
     M0<sup>2</sup>
 P = M0<sup>3</sup>
     M0<sup>4</sup>
     M0<sup>5</sup>
     M0<sup>6</sup>
 </pre><h5>Multiplying compressed matrices</h5>
<p>Let <code>I<sub>n</sub></code> be the n-th column of <code>I</code> and <code>P<sub>n</sub> = P I<sub>n</sub></code>, a vector of the n-th column of each of the matrices of <code>P</code>. Then the n-th column of M0<sup>k</sup> is</p>
<pre>
 M0<sup>k</sup> I<sub>n</sub> = C<sub>k</sub><sup>T</sup> P I<sub>n</sub> = C<sub>k</sub><sup>T</sup> P<sub>n</sub>
 </pre><p>or</p>
<pre>
 I<sub>n</sub><sup>T</sup> (M0<sup>k</sup>)<sup>T</sup> = P<sub>n</sub><sup>T</sup> C<sub>k</sub>
 </pre><p>Recall that <code>C<sub>k</sub><sup>T</sup></code> is the top row of <code>M0<sup>k</sup></code>.&nbsp; That means we can write</p>
<pre>
 C<sub>k</sub> = (I<sub>0</sub><sup>T</sup> M0<sup>k</sup>)<sup>T</sup> = (M0<sup>k</sup>)<sup>T</sup> I<sub>0</sub>
 </pre><p>and can deduce that</p>
<pre>
 C<sub>m+k</sub> = (M0<sup>m+k</sup>)<sup>T</sup> I<sub>0</sub> = (M0<sup>m</sup> M0<sup>k</sup>)<sup>T</sup> I<sub>0</sub> = (M0<sup>k</sup>)<sup>T</sup> (M0<sup>m</sup>)<sup>T</sup> I<sub>0</sub> = (M0<sup>k</sup>)<sup>T</sup> (I<sub>0</sub><sup>T</sup> M0<sup>m</sup>)<sup>T</sup> = (M0<sup>k</sup>)<sup>T</sup> C<sub>m</sub> =
 [sum over n] (I<sub>n</sub><sup>T</sup> (M0<sup>k</sup>)<sup>T</sup> C<sub>m</sub> I<sub>n</sub>) =
 [sum over n] (P<sub>n</sub><sup>T</sup> C<sub>k</sub> C<sub>m</sub> I<sub>n</sub>) =
 [sum over n] (I<sub>n</sub><sup>T</sup> P<sup>T</sup> C<sub>k</sub> C<sub>m</sub> I<sub>n</sub>) =
 P<sup>T</sup> C<sub>k</sub> C<sub>m</sub>
 </pre><p>from which we conclude that bit n of <code>C<sub>k+m</sub></code> is</p>
<pre>
 I<sub>n</sub><sup>T</sup> C<sub>k+m</sub> =
 I<sub>n</sub><sup>T</sup> P<sup>T</sup> C<sub>k</sub> C<sub>m</sub> =
 P<sub>n</sub><sup>T</sup> C<sub>k</sub> C<sub>m</sub>
 </pre><p>Note that <code>P<sub>n</sub><sup>T</sup></code> is a row of rows, hence <code>P<sub>n</sub><sup>T</sup> C<sub>k</sub></code> is a row which can also be written as <code>C<sub>k</sub><sup>T</sup> Q</code>.&nbsp; The n-th bit of <code>C<sub>k+m</sub></code> then becomes</p>
<pre>
 I<sub>n</sub><sup>T</sup> C<sub>k+m</sub> = C<sub>k</sub><sup>T</sup> Q<sub>n</sub> C<sub>m</sub>
 </pre><p>where <code>Q<sub>n</sub></code> is a matrix consisting of the n-th columns of the elements of <code>P</code>, in other words</p>
<pre>
 Q<sub>n</sub> = Q I<sub>n</sub>
 </pre><p>where</p>
<pre>
 Q = (M0<sup>0</sup> M0<sup>1</sup> M0<sup>2</sup> ... M0<sup>p-1</sup>)
 </pre><p>Note that Q<sub>n</sub> is symmetric so that <code>Q<sub>n</sub><sup>T</sup> = Q<sub>n</sub></code> and therefore <code>C<sub>k</sub><sup>T</sup> Q<sub>n</sub> C<sub>m</sub> = C<sub>m</sub><sup>T</sup> Q<sub>n</sub> C<sub>k</sub></code>, as it should be since <code>M0<sup>k</sup> M0<sup>m</sup> = M0<sup>m</sup> M0<sup>k</sup></code>.</p>
<p>Using this method it was possible to write a program that checks the period of the RNG in a time of the order O(p<sup>2</sup> * f<sup>3</sup>), for pxp matrices with f feedback points, instead of the order O(p<sup>4</sup>). Note that the following observations have been used as well; the period of a RNG with feedback points f1, f2, f3 ... is equal to the period of a RNG with feedback points p - f1, p - f2, p - f3, ... This allowed us to drastically reduce the order of the number of feedback points. Finally note the observation that a RNG only has a period of 2<sup>p</sup> - 1 solution when using an odd number of feedback points.</p>
<p>Considering that it took me something of the order of an hour to find working feedback points for a RNG with 521 bits, it would now take about 9 weeks to find feedback points for a RNG of 19937 bits instead of 262 year as would be the case when using ordinairy matrices.</p>
<p><b>Implementation</b></p>
<p>The implemented Random Number Generator of libecc uses 521 bits and 9 feedback points at 2, 3, 7, 13, 31, 61, 131, 151 and 251.&nbsp; These feedback points are chosen to be primes in order to garantee the least interference.&nbsp; The distance between the feedback points is every time increased by a factor of two (except for the feedback point at 151 which was added in order to make the RNG have its maximum period).&nbsp; The reason for this is again to have the least interference between feedback frequencies, this way the different feedback points nicely supplement each other in achieving bit mangling over the full range. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a3d7c1db3f11c9cbe9db3513866fbb23f"></a><!-- doxytag: member="libecc::rng::pool_type" ref="a3d7c1db3f11c9cbe9db3513866fbb23f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt;<a class="el" href="classlibecc_1_1rng.html#a846512228cdfa61ff3b9eb4011b1e45b">S_pool_size</a>&gt; <a class="el" href="classlibecc_1_1bitset.html">libecc::rng::pool_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The type of the constructor argument. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a70d9a111410f375721521efd5a7a9d74"></a><!-- doxytag: member="libecc::rng::rng" ref="a70d9a111410f375721521efd5a7a9d74" args="(pool_type const &amp;seed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libecc::rng::rng </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset.html">pool_type</a> const &amp;&nbsp;</td>
          <td class="paramname"> <em>seed</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>seed</em>&nbsp;</td><td>A bitset of 521 bits, any value is allowed except all zeroes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a15c9a252f22046ba8d64a3e0a4e94f26"></a><!-- doxytag: member="libecc::rng::add_entropy" ref="a15c9a252f22046ba8d64a3e0a4e94f26" args="(uint32_t const *noise, unsigned int number_of_ints)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libecc::rng::add_entropy </td>
          <td>(</td>
          <td class="paramtype">uint32_t const *&nbsp;</td>
          <td class="paramname"> <em>noise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>number_of_ints</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add entropy to the random number generator pool. </p>
<p>By adding entropy to the random number generator, the output becomes more unpredictable. Its not really necessary to do this however, its hard enough to 'guess' the 521 bits of seed. It is advisable to use SHA-1 on the output though, in order to make it harder to reverse engineer the internal state of the rng from its output. </p>

</div>
</div>
<a class="anchor" id="af93e2efa883deddba267db6e993cb7f1"></a><!-- doxytag: member="libecc::rng::add_entropy" ref="af93e2efa883deddba267db6e993cb7f1" args="(bitset&lt; n &gt; const noise)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libecc::rng::add_entropy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; n &gt; const &nbsp;</td>
          <td class="paramname"> <em>noise</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add entropy from a bitset. </p>
<p>Calls <code><a class="el" href="classlibecc_1_1rng.html#a15c9a252f22046ba8d64a3e0a4e94f26" title="Add entropy to the random number generator pool.">add_entropy(uint32_t const*, unsigned int)</a></code>. </p>

</div>
</div>
<a class="anchor" id="af98129268ed22e3b396fca68f610646f"></a><!-- doxytag: member="libecc::rng::generate_512_bits" ref="af98129268ed22e3b396fca68f610646f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libecc::rng::generate_512_bits </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate 512 bits. </p>
<p>Fills the internal output buffer with 512 new random bits. You can retrieve this output with the member function <a class="el" href="classlibecc_1_1rng.html#ad85b236f2f01c223d9512ed95996406a" title="Retrieve a reference to the 512 bits that were generated with a call to rng::generate_512_bits().">rng::get_512_bits()</a>. </p>

</div>
</div>
<a class="anchor" id="ad85b236f2f01c223d9512ed95996406a"></a><!-- doxytag: member="libecc::rng::get_512_bits" ref="ad85b236f2f01c223d9512ed95996406a" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt;512&gt; const&amp; libecc::rng::get_512_bits </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a reference to the 512 bits that were generated with a call to <a class="el" href="classlibecc_1_1rng.html#af98129268ed22e3b396fca68f610646f" title="Generate 512 bits.">rng::generate_512_bits()</a>. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a846512228cdfa61ff3b9eb4011b1e45b"></a><!-- doxytag: member="libecc::rng::S_pool_size" ref="a846512228cdfa61ff3b9eb4011b1e45b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int const <a class="el" href="classlibecc_1_1rng.html#a846512228cdfa61ff3b9eb4011b1e45b">libecc::rng::S_pool_size</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pool size in bits. This RNG uses a pool of 521 bits. </p>

</div>
</div>
</div>
<address>Copyright &copy; 2002-2008 Carlo Wood.&nbsp; All rights reserved.</address>

</div>
</body>
</html>

