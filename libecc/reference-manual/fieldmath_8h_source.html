<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html LANG="en_US">

<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="Author" content="Carlo Wood">
<meta name="description" content="Elliptic Curve Cryptography C++ Library">
<meta name="keywords" content="libecc, fast, elliptic curves, cryptography, fixed key size, speed, object orientation, OO, C++">
<title>libecc: Elliptic Curve Cryptography C++ Library - Reference Manual</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<script src="../scripts/detect_browser.js"></script>
<script>need_style_doxygen=1</script>
<script src="../scripts/load_style_sheets.js"></script>
</head>

<body>
<div class="normal">

<center>
<a class="qindex" href="../index.html">Main Page</a> &nbsp;
<a class="qindex" href="index.html">Reference Manual</a> &nbsp;
<a class="qindex" href="annotated.html">Compound List</a> &nbsp;
<a class="qindex" href="files.html">File List</a> &nbsp;
</center>

<hr size=1 noshade>
<!-- Generated by Doxygen 1.7.1 -->
<div class="header">
  <div class="headertitle">
<h1>libecc/fieldmath.h</h1>  </div>
</div>
<div class="contents">
<a href="fieldmath_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//</span>
<a name="l00014"></a>00014 <span class="comment"></span><span class="comment">//</span>
<a name="l00015"></a>00015 <span class="comment">// This file is part of the libecc package.</span>
<a name="l00016"></a>00016 <span class="comment">// Copyright (C) 2002, by</span>
<a name="l00017"></a>00017 <span class="comment">//</span>
<a name="l00018"></a>00018 <span class="comment">// Carlo Wood, Run on IRC &lt;carlo@alinoe.com&gt;</span>
<a name="l00019"></a>00019 <span class="comment">// RSA-1024 0x624ACAD5 1997-01-26                    Sign &amp; Encrypt</span>
<a name="l00020"></a>00020 <span class="comment">// Fingerprint16 = 32 EC A7 B6 AC DB 65 A6  F6 F6 55 DD 1C DC FF 61</span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 <span class="comment">// This program is free software; you can redistribute it and/or</span>
<a name="l00023"></a>00023 <span class="comment">// modify it under the terms of the GNU General Public License</span>
<a name="l00024"></a>00024 <span class="comment">// as published by the Free Software Foundation; either version 2</span>
<a name="l00025"></a>00025 <span class="comment">// of the License, or (at your option) any later version.</span>
<a name="l00026"></a>00026 <span class="comment">//</span>
<a name="l00027"></a>00027 <span class="comment">// This program is distributed in the hope that it will be useful,</span>
<a name="l00028"></a>00028 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00029"></a>00029 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00030"></a>00030 <span class="comment">// GNU General Public License for more details.</span>
<a name="l00031"></a>00031 <span class="comment">//</span>
<a name="l00032"></a>00032 <span class="comment">// You should have received a copy of the GNU General Public License</span>
<a name="l00033"></a>00033 <span class="comment">// along with this program; if not, write to the Free Software</span>
<a name="l00034"></a>00034 <span class="comment">// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<a name="l00035"></a>00035 <span class="comment">//</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="preprocessor">#ifndef LIBECC_FIELDMATH_H</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#define LIBECC_FIELDMATH_H</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;gmpxx.h&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;<a class="code" href="bitset_8h.html" title="Fixed size bitset.">libecc/bitset.h</a>&gt;</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="keyword">namespace</span>libecc {
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="keyword">template</span>&lt;<span class="keyword">class</span> field_type&gt;
<a name="l00046"></a>00046   <span class="keyword">class</span>multiplicative_square {
<a name="l00047"></a>00047     <span class="keyword">public</span>:
<a name="l00048"></a>00048       <span class="keywordtype">void</span> operator()(field_type&amp; field_element)<span class="keyword"> const</span>{ field_element *= field_element; }
<a name="l00049"></a>00049   };
<a name="l00050"></a>00050 
<a name="l00085"></a>00085 <span class="keyword">template</span>&lt;<span class="keyword">class</span> field_type, <span class="keyword">class</span> square_functor&gt;
<a name="l00086"></a><a class="code" href="namespacelibecc.html#a8ca53ab8c41c4c288c70f45c263bc099">00086</a>   field_type <a class="code" href="namespacelibecc.html#a8ca53ab8c41c4c288c70f45c263bc099">exponentiation</a>(field_type <span class="keyword">const</span>&amp; base, mpz_class <span class="keyword">const</span>&amp; exponent,
<a name="l00087"></a>00087       square_functor <span class="keyword">const</span>&amp; do_square = multiplicative_square&lt;field_type&gt;())
<a name="l00088"></a>00088   {
<a name="l00089"></a>00089     field_type result(mpz_tstbit(exponent.get_mpz_t(), 0) ? base : field_type::unity());
<a name="l00090"></a>00090     field_type current_factor(base);
<a name="l00091"></a>00091     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> next_bit = 1;
<a name="l00092"></a>00092     <span class="keywordflow">for</span>(;;)
<a name="l00093"></a>00093     {
<a name="l00094"></a>00094       <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> current_bit = mpz_scan1(exponent.get_mpz_t(), next_bit);
<a name="l00095"></a>00095       <span class="keywordflow">if</span> (current_bit == (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)-1)
<a name="l00096"></a>00096         <span class="keywordflow">break</span>;
<a name="l00097"></a>00097       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> cnt = current_bit - next_bit; cnt &gt;= 0; --cnt)
<a name="l00098"></a>00098         do_square(current_factor);
<a name="l00099"></a>00099       result *= current_factor;
<a name="l00100"></a>00100       next_bit = current_bit + 1;
<a name="l00101"></a>00101     }
<a name="l00102"></a>00102     <span class="keywordflow">return</span> result;
<a name="l00103"></a>00103   }
<a name="l00104"></a>00104 
<a name="l00113"></a>00113 <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m&gt;
<a name="l00114"></a>00114   bitset&lt;m&gt;&amp;
<a name="l00115"></a><a class="code" href="namespacelibecc.html#afcf7bbb8b9906784eb5bb28f548d7e03">00115</a>   <a class="code" href="namespacelibecc.html#afcf7bbb8b9906784eb5bb28f548d7e03">gcd</a>(<a class="code" href="classlibecc_1_1bitset.html">bitset&lt;m&gt;</a>&amp; polynomial_coefficients0, <a class="code" href="classlibecc_1_1bitset.html">bitset&lt;m&gt;</a>&amp; polynomial_coefficients1)
<a name="l00116"></a>00116   {
<a name="l00117"></a>00117     <a class="code" href="classlibecc_1_1bitset.html">bitset&lt;m&gt;</a>* polycoef[2];
<a name="l00118"></a>00118     polycoef[0] = &amp;polynomial_coefficients0;
<a name="l00119"></a>00119     polycoef[1] = &amp;polynomial_coefficients1;
<a name="l00120"></a>00120     <span class="keyword">typename</span> <a class="code" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">bitset&lt;m&gt;::const_reverse_iterator</a> iter[2];
<a name="l00121"></a>00121 
<a name="l00122"></a>00122     <span class="comment">// Determine the highest degree bit that is set, in the two polynomial_coefficients.</span>
<a name="l00123"></a>00123     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> p = 0; p &lt; 2; ++p)
<a name="l00124"></a>00124     {
<a name="l00125"></a>00125       iter[p] = polycoef[p]-&gt;<a class="code" href="structlibecc_1_1bitset__base.html#a4a8b1ec5cd0e596877f8613f2644a869" title="Return a reverse iterator to bit N-1.">rbegin</a>();
<a name="l00126"></a>00126       iter[p].find1();
<a name="l00127"></a>00127       <span class="keywordflow">if</span> (iter[p] == polycoef[p]-&gt;rend())
<a name="l00128"></a>00128         <span class="keywordflow">return</span> *polycoef[1 - p];                <span class="comment">// The other polynomials is zero.</span>
<a name="l00129"></a>00129     }
<a name="l00130"></a>00130     <span class="keywordtype">int</span> distance = (iter[0] - iter[1]);
<a name="l00131"></a>00131     <span class="keywordflow">if</span> (distance &lt; 0)
<a name="l00132"></a>00132       distance = -distance;
<a name="l00133"></a>00133     <span class="keywordtype">int</span> smallest = (iter[0] &gt; iter[1]) ? 0 : 1;
<a name="l00134"></a>00134     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> largest = 1 - smallest;; largest = 1 - largest, smallest = 1 - smallest)
<a name="l00135"></a>00135     {
<a name="l00136"></a>00136       <a class="code" href="classlibecc_1_1bitset.html">bitset&lt;m&gt;</a> temp(*polycoef[smallest]);
<a name="l00137"></a>00137       temp &lt;&lt;= distance;
<a name="l00138"></a>00138       <span class="keywordtype">int</span> last_shift = distance;
<a name="l00139"></a>00139       *polycoef[largest] ^= temp;
<a name="l00140"></a>00140       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> shift = distance - 1; shift &gt;= 0; --shift)
<a name="l00141"></a>00141       {
<a name="l00142"></a>00142         <span class="keywordflow">if</span> (!*(iter[largest] + (distance - shift)))
<a name="l00143"></a>00143           <span class="keywordflow">continue</span>;
<a name="l00144"></a>00144         temp &gt;&gt;= (last_shift - shift);
<a name="l00145"></a>00145         last_shift = shift;
<a name="l00146"></a>00146         *polycoef[largest] ^= temp;
<a name="l00147"></a>00147       }
<a name="l00148"></a>00148       iter[largest].find1();
<a name="l00149"></a>00149       <span class="keywordflow">if</span> (iter[largest] == polycoef[largest]-&gt;rend())
<a name="l00150"></a>00150         <span class="keywordflow">break</span>;                          <span class="comment">// Found the gcd.</span>
<a name="l00151"></a>00151       distance = (iter[largest] - iter[smallest]);
<a name="l00152"></a>00152     }
<a name="l00153"></a>00153     <span class="keywordflow">return</span> *polycoef[smallest];
<a name="l00154"></a>00154   }
<a name="l00155"></a>00155   
<a name="l00156"></a>00156 } <span class="comment">// namespace libecc</span>
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 <span class="preprocessor">#endif // LIBECC_FIELDMATH_H</span>
</pre></div></div>
</div>
<address>Copyright &copy; 2002-2008 Carlo Wood.&nbsp; All rights reserved.</address>

</div>
</body>
</html>

