<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html LANG="en_US">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="Author" content="Carlo Wood">
<meta name="description" content="Elliptic Curve Cryptography C++ Library">
<meta name="keywords" content="libecc, fast, elliptic curves, cryptography, fixed key size, speed, object orientation, OO, C++">
<title>libecc: Elliptic Curve Cryptography C++ Library - Reference Manual</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<script src="../scripts/detect_browser.js"></script>
<script>need_style_doxygen=1</script>
<script src="../scripts/load_style_sheets.js"></script>
</head>
<body>
<div class="normal">
<center>
<a class="qindex" href="../index.html">Main Page</a> &nbsp;
<a class="qindex" href="index.html">Reference Manual</a> &nbsp;
<a class="qindex" href="annotated.html">Compound List</a> &nbsp;
<a class="qindex" href="files.html">File List</a> &nbsp;
</center>
<hr size=1 noshade>
<!-- Generated by Doxygen 1.8.18 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">libecc Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for libecc.  
<a href="namespacelibecc.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibecc_1_1assign.html">assign</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation used with <a class="el" href="classlibecc_1_1bitset.html#ab0b8a2d64606610d4b8722960d14e958" title="Perform a shift operation followed by a bit operation.">libecc::bitset::shift_op</a>.  <a href="structlibecc_1_1assign.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset.html">bitset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bitset with a fixed number of bits.  <a href="classlibecc_1_1bitset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibecc_1_1bitset__base.html">bitset_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of <a class="el" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">libecc::bitset</a>.  <a href="structlibecc_1_1bitset__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset__index.html">bitset_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bitset index.  <a href="classlibecc_1_1bitset__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bitset index with increment/decrement methods.  <a href="classlibecc_1_1bitset__index__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1's.  <a href="classlibecc_1_1bitset__invertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-mutable bitset-iterator.  <a href="classlibecc_1_1bitset__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibecc_1_1exor.html">exor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation used with <a class="el" href="classlibecc_1_1bitset.html#ab0b8a2d64606610d4b8722960d14e958" title="Perform a shift operation followed by a bit operation.">libecc::bitset::shift_op</a>.  <a href="structlibecc_1_1exor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibecc_1_1left.html">left</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift direction used with <a class="el" href="classlibecc_1_1bitset.html#ab0b8a2d64606610d4b8722960d14e958" title="Perform a shift operation followed by a bit operation.">libecc::bitset::shift_op</a>.  <a href="structlibecc_1_1left.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1point.html">point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point <span class="Formula">(x,y)</span> on elliptic curve <span class="Formula">x<sup>3</sup> + ax<sup>2</sup> + b = y<sup>2</sup> + xy</span>.  <a href="classlibecc_1_1point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1polynomial.html">polynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial representation of the Galois field <span class="Formula">F<sub>2<sup>m</sup></sub></span>.  <a href="classlibecc_1_1polynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibecc_1_1right.html">right</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift direction used with <a class="el" href="classlibecc_1_1bitset.html#ab0b8a2d64606610d4b8722960d14e958" title="Perform a shift operation followed by a bit operation.">libecc::bitset::shift_op</a>.  <a href="structlibecc_1_1right.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1rng.html">rng</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo Random Number Generator.  <a href="classlibecc_1_1rng.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1sha1.html">sha1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHA-1.  <a href="classlibecc_1_1sha1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7a7be7cc5bc91d345df9a5668e8a866d"><td class="memItemLeft" align="right" valign="top">typedef unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d">bitset_digit_t</a></td></tr>
<tr class="memdesc:a7a7be7cc5bc91d345df9a5668e8a866d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal data type, used to store the bits of class bitset.  <a href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d">More...</a><br /></td></tr>
<tr class="separator:a7a7be7cc5bc91d345df9a5668e8a866d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a20e07c996961c9c66d64359e77443df4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a20e07c996961c9c66d64359e77443df4">operator==</a> (<a class="el" href="classlibecc_1_1bitset__index.html">bitset_index</a> const &amp;i1, <a class="el" href="classlibecc_1_1bitset__index.html">bitset_index</a> const &amp;i2)</td></tr>
<tr class="memdesc:a20e07c996961c9c66d64359e77443df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="namespacelibecc.html#a20e07c996961c9c66d64359e77443df4">More...</a><br /></td></tr>
<tr class="separator:a20e07c996961c9c66d64359e77443df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac394825c0221d5171fe495fb4cac3ef2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#ac394825c0221d5171fe495fb4cac3ef2">operator!=</a> (<a class="el" href="classlibecc_1_1bitset__index.html">bitset_index</a> const &amp;i1, <a class="el" href="classlibecc_1_1bitset__index.html">bitset_index</a> const &amp;i2)</td></tr>
<tr class="memdesc:ac394825c0221d5171fe495fb4cac3ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="namespacelibecc.html#ac394825c0221d5171fe495fb4cac3ef2">More...</a><br /></td></tr>
<tr class="separator:ac394825c0221d5171fe495fb4cac3ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1f35747898307724355a10918c7670"><td class="memTemplParams" colspan="2">template&lt;int DIRECTION&gt; </td></tr>
<tr class="memitem:a1f1f35747898307724355a10918c7670"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a1f1f35747898307724355a10918c7670">operator&lt;</a> (<a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const  &amp;i1, <a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const  &amp;i2)</td></tr>
<tr class="memdesc:a1f1f35747898307724355a10918c7670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less.  <a href="namespacelibecc.html#a1f1f35747898307724355a10918c7670">More...</a><br /></td></tr>
<tr class="separator:a1f1f35747898307724355a10918c7670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88882c29e7ac9e33db3d0925ba0340c"><td class="memTemplParams" colspan="2">template&lt;int DIRECTION&gt; </td></tr>
<tr class="memitem:aa88882c29e7ac9e33db3d0925ba0340c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#aa88882c29e7ac9e33db3d0925ba0340c">operator&gt;</a> (<a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const  &amp;i1, <a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const  &amp;i2)</td></tr>
<tr class="memdesc:aa88882c29e7ac9e33db3d0925ba0340c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater.  <a href="namespacelibecc.html#aa88882c29e7ac9e33db3d0925ba0340c">More...</a><br /></td></tr>
<tr class="separator:aa88882c29e7ac9e33db3d0925ba0340c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aad3be02a5895f1b39ed1ab1af23b7"><td class="memTemplParams" colspan="2">template&lt;int DIRECTION&gt; </td></tr>
<tr class="memitem:a21aad3be02a5895f1b39ed1ab1af23b7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a21aad3be02a5895f1b39ed1ab1af23b7">operator&lt;=</a> (<a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const  &amp;i1, <a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const  &amp;i2)</td></tr>
<tr class="memdesc:a21aad3be02a5895f1b39ed1ab1af23b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less or equal.  <a href="namespacelibecc.html#a21aad3be02a5895f1b39ed1ab1af23b7">More...</a><br /></td></tr>
<tr class="separator:a21aad3be02a5895f1b39ed1ab1af23b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fe37de6fff2e4aad69694c690a33f6"><td class="memTemplParams" colspan="2">template&lt;int DIRECTION&gt; </td></tr>
<tr class="memitem:af2fe37de6fff2e4aad69694c690a33f6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#af2fe37de6fff2e4aad69694c690a33f6">operator&gt;=</a> (<a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const  &amp;i1, <a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const  &amp;i2)</td></tr>
<tr class="memdesc:af2fe37de6fff2e4aad69694c690a33f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater or equal.  <a href="namespacelibecc.html#af2fe37de6fff2e4aad69694c690a33f6">More...</a><br /></td></tr>
<tr class="separator:af2fe37de6fff2e4aad69694c690a33f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c9567bf5741a980fc88bb017036885"><td class="memTemplParams" colspan="2">template&lt;unsigned int N, int DIRECTION&gt; </td></tr>
<tr class="memitem:a35c9567bf5741a980fc88bb017036885"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a35c9567bf5741a980fc88bb017036885">operator+</a> (<a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; const  &amp;i, int d)</td></tr>
<tr class="memdesc:a35c9567bf5741a980fc88bb017036885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator addition.  <a href="namespacelibecc.html#a35c9567bf5741a980fc88bb017036885">More...</a><br /></td></tr>
<tr class="separator:a35c9567bf5741a980fc88bb017036885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6ba6caaad6f4a28bd92bdc724ed633"><td class="memTemplParams" colspan="2">template&lt;unsigned int N, int DIRECTION&gt; </td></tr>
<tr class="memitem:ade6ba6caaad6f4a28bd92bdc724ed633"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#ade6ba6caaad6f4a28bd92bdc724ed633">operator+</a> (int d, <a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; const  &amp;i)</td></tr>
<tr class="memdesc:ade6ba6caaad6f4a28bd92bdc724ed633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator addition.  <a href="namespacelibecc.html#ade6ba6caaad6f4a28bd92bdc724ed633">More...</a><br /></td></tr>
<tr class="separator:ade6ba6caaad6f4a28bd92bdc724ed633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a029aa36e135db6aaeb7e6c4d42aed"><td class="memTemplParams" colspan="2">template&lt;unsigned int N, int DIRECTION&gt; </td></tr>
<tr class="memitem:ab8a029aa36e135db6aaeb7e6c4d42aed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#ab8a029aa36e135db6aaeb7e6c4d42aed">operator-</a> (<a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; const  &amp;i, int d)</td></tr>
<tr class="memdesc:ab8a029aa36e135db6aaeb7e6c4d42aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator subtraction.  <a href="namespacelibecc.html#ab8a029aa36e135db6aaeb7e6c4d42aed">More...</a><br /></td></tr>
<tr class="separator:ab8a029aa36e135db6aaeb7e6c4d42aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcae566219ec9e23ae6ca8b265d7c433"><td class="memTemplParams" colspan="2">template&lt;unsigned int N, int DIRECTION&gt; </td></tr>
<tr class="memitem:afcae566219ec9e23ae6ca8b265d7c433"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#afcae566219ec9e23ae6ca8b265d7c433">operator-</a> (int d, <a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; const  &amp;i)</td></tr>
<tr class="memdesc:afcae566219ec9e23ae6ca8b265d7c433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator subtraction.  <a href="namespacelibecc.html#afcae566219ec9e23ae6ca8b265d7c433">More...</a><br /></td></tr>
<tr class="separator:afcae566219ec9e23ae6ca8b265d7c433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7fc4f4120db4cf68888aa66116fc42"><td class="memTemplParams" colspan="2">template&lt;unsigned int N, bool inverted&gt; </td></tr>
<tr class="memitem:afb7fc4f4120db4cf68888aa66116fc42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; N, !inverted &gt; const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#afb7fc4f4120db4cf68888aa66116fc42">operator~</a> (<a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; N, inverted &gt; const &amp;bits)</td></tr>
<tr class="memdesc:afb7fc4f4120db4cf68888aa66116fc42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert a bitset.  <a href="namespacelibecc.html#afb7fc4f4120db4cf68888aa66116fc42">More...</a><br /></td></tr>
<tr class="separator:afb7fc4f4120db4cf68888aa66116fc42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78a6daf473021764cc3149528263650"><td class="memTemplParams" colspan="2">template&lt;unsigned int n1, bool inverted1, unsigned int n2, bool inverted2&gt; </td></tr>
<tr class="memitem:af78a6daf473021764cc3149528263650"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#af78a6daf473021764cc3149528263650">operator==</a> (<a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; n1, inverted1 &gt; const &amp;bits1, <a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; n2, inverted2 &gt; const &amp;bits2)</td></tr>
<tr class="memdesc:af78a6daf473021764cc3149528263650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalence operator.  <a href="namespacelibecc.html#af78a6daf473021764cc3149528263650">More...</a><br /></td></tr>
<tr class="separator:af78a6daf473021764cc3149528263650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78dcbe32226b5689d2e2beca495df121"><td class="memTemplParams" colspan="2">template&lt;unsigned int n1, bool inverted1, unsigned int n2, bool inverted2&gt; </td></tr>
<tr class="memitem:a78dcbe32226b5689d2e2beca495df121"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a78dcbe32226b5689d2e2beca495df121">operator!=</a> (<a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; n1, inverted1 &gt; const &amp;bits1, <a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; n2, inverted2 &gt; const &amp;bits2)</td></tr>
<tr class="memdesc:a78dcbe32226b5689d2e2beca495df121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unequivalence operator.  <a href="namespacelibecc.html#a78dcbe32226b5689d2e2beca495df121">More...</a><br /></td></tr>
<tr class="separator:a78dcbe32226b5689d2e2beca495df121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b890f8080ea01a5f0841dcaaea7718"><td class="memTemplParams" colspan="2">template&lt;unsigned int m, bool inverted1, bool inverted2&gt; </td></tr>
<tr class="memitem:a17b890f8080ea01a5f0841dcaaea7718"><td class="memTemplItemLeft" align="right" valign="top">Operator::bitsetExpression&lt; m, inverted1, inverted2, Operator::bitsetAND &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a17b890f8080ea01a5f0841dcaaea7718">operator&amp;</a> (<a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted1 &gt; const &amp;arg1, <a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted2 &gt; const &amp;arg2)</td></tr>
<tr class="memdesc:a17b890f8080ea01a5f0841dcaaea7718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator with bitwise AND for expressions.  <a href="namespacelibecc.html#a17b890f8080ea01a5f0841dcaaea7718">More...</a><br /></td></tr>
<tr class="separator:a17b890f8080ea01a5f0841dcaaea7718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b364a6c7b31b1836d6c6d945153c20f"><td class="memTemplParams" colspan="2">template&lt;unsigned int m, bool inverted1, bool inverted2&gt; </td></tr>
<tr class="memitem:a6b364a6c7b31b1836d6c6d945153c20f"><td class="memTemplItemLeft" align="right" valign="top">Operator::bitsetExpression&lt; m, inverted1, inverted2, Operator::bitsetOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a6b364a6c7b31b1836d6c6d945153c20f">operator|</a> (<a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted1 &gt; const &amp;arg1, <a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted2 &gt; const &amp;arg2)</td></tr>
<tr class="memdesc:a6b364a6c7b31b1836d6c6d945153c20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator with bitwise OR for expressions.  <a href="namespacelibecc.html#a6b364a6c7b31b1836d6c6d945153c20f">More...</a><br /></td></tr>
<tr class="separator:a6b364a6c7b31b1836d6c6d945153c20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9003abb32c0aa28a9a40b3bd368813f5"><td class="memTemplParams" colspan="2">template&lt;unsigned int m, bool inverted1, bool inverted2&gt; </td></tr>
<tr class="memitem:a9003abb32c0aa28a9a40b3bd368813f5"><td class="memTemplItemLeft" align="right" valign="top">Operator::bitsetExpression&lt; m, inverted1, inverted2, Operator::bitsetXOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a9003abb32c0aa28a9a40b3bd368813f5">operator^</a> (<a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted1 &gt; const &amp;arg1, <a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted2 &gt; const &amp;arg2)</td></tr>
<tr class="memdesc:a9003abb32c0aa28a9a40b3bd368813f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator with bitwise XOR for expressions.  <a href="namespacelibecc.html#a9003abb32c0aa28a9a40b3bd368813f5">More...</a><br /></td></tr>
<tr class="separator:a9003abb32c0aa28a9a40b3bd368813f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74b9fd7c27ea3209f6f7b7d0d2154a3"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aa74b9fd7c27ea3209f6f7b7d0d2154a3"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#aa74b9fd7c27ea3209f6f7b7d0d2154a3">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; N &gt; &amp;bitsetx)</td></tr>
<tr class="memdesc:aa74b9fd7c27ea3209f6f7b7d0d2154a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bitset from istream.  <a href="namespacelibecc.html#aa74b9fd7c27ea3209f6f7b7d0d2154a3">More...</a><br /></td></tr>
<tr class="separator:aa74b9fd7c27ea3209f6f7b7d0d2154a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008d5cfb4a4aab623bbf52cce7befdc7"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a008d5cfb4a4aab623bbf52cce7befdc7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a008d5cfb4a4aab623bbf52cce7befdc7">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; N &gt; const &amp;bits)</td></tr>
<tr class="memdesc:a008d5cfb4a4aab623bbf52cce7befdc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write bitset to ostream.  <a href="namespacelibecc.html#a008d5cfb4a4aab623bbf52cce7befdc7">More...</a><br /></td></tr>
<tr class="separator:a008d5cfb4a4aab623bbf52cce7befdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c60f0b656da0873ecbe17ec4109563"><td class="memTemplParams" colspan="2">template&lt;class field_type , class square_functor &gt; </td></tr>
<tr class="memitem:af3c60f0b656da0873ecbe17ec4109563"><td class="memTemplItemLeft" align="right" valign="top">field_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#af3c60f0b656da0873ecbe17ec4109563">exponentiation</a> (field_type const &amp;base, mpz_class const &amp;exponent, square_functor const &amp;do_square=multiplicative_square&lt; field_type &gt;())</td></tr>
<tr class="separator:af3c60f0b656da0873ecbe17ec4109563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa610fc0bbb1838980392872595214a72"><td class="memTemplParams" colspan="2">template&lt;unsigned int m&gt; </td></tr>
<tr class="memitem:aa610fc0bbb1838980392872595214a72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; m &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#aa610fc0bbb1838980392872595214a72">gcd</a> (<a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; m &gt; &amp;polynomial_coefficients0, <a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; m &gt; &amp;polynomial_coefficients1)</td></tr>
<tr class="separator:aa610fc0bbb1838980392872595214a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for libecc. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a7a7be7cc5bc91d345df9a5668e8a866d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7be7cc5bc91d345df9a5668e8a866d">&#9670;&nbsp;</a></span>bitset_digit_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d">libecc::bitset_digit_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal data type, used to store the bits of class bitset. </p>
<p>The number of bits in the builtin-type <code>long</code> turns out to be equal to the size of the databus between memory and cpu. The internal type used to store the bits of a bitset is therefore an <code>unsigned long</code> resulting in the most efficient code for bit manipulation. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af3c60f0b656da0873ecbe17ec4109563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c60f0b656da0873ecbe17ec4109563">&#9670;&nbsp;</a></span>exponentiation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class field_type , class square_functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">field_type libecc::exponentiation </td>
          <td>(</td>
          <td class="paramtype">field_type const &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_class const &amp;&#160;</td>
          <td class="paramname"><em>exponent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">square_functor const &amp;&#160;</td>
          <td class="paramname"><em>do_square</em> = <code>multiplicative_square&lt;field_type&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the exponentiation of an arbitrary field element. The field must have defined the methods <code>unity()</code> and <code>operator*=</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_type</td><td>The type of the field element. </td></tr>
    <tr><td class="paramname">square_functor</td><td>A functor to calculate the square of a field_type. </td></tr>
    <tr><td class="paramname">base</td><td>The field_type that will be exponentiated. </td></tr>
    <tr><td class="paramname">exponent</td><td>The exponent of the exponentiation. </td></tr>
    <tr><td class="paramname">do_square</td><td>The square_functor.</td></tr>
  </table>
  </dd>
</dl>
<p><em>square_functor</em> must define a method <code>void operator()(field_type&amp; x)</code> setting <code>x</code> to its square.</p>
<p>For example for a <a class="el" href="classlibecc_1_1polynomial.html">libecc::polynomial</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k&gt;</div>
<div class="line">  <span class="keyword">class</span>polynomial_square {</div>
<div class="line">    <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d">libecc::bitset_digit_t</a> buffer[<a class="code" href="classlibecc_1_1polynomial.html">libecc::polynomial&lt;m, k&gt;::square_digits</a>];</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      <span class="keywordtype">void</span> operator()(<a class="code" href="classlibecc_1_1polynomial.html">libecc::polynomial&lt;m, k&gt;</a>&amp; p) { p = p.<a class="code" href="classlibecc_1_1polynomial.html#a6de63c911a01ec4b240c879f31550ef3">square</a>(buffer); }</div>
<div class="line">  };</div>
</div><!-- fragment --><p>and then use</p>
<div class="fragment"><div class="line"><a class="code" href="classlibecc_1_1polynomial.html">libecc::polynomial&lt;m, k&gt;</a> power(<a class="code" href="namespacelibecc.html#af3c60f0b656da0873ecbe17ec4109563">exponentiation</a>(base, exponent, polynomial_square&lt;m, k&gt;()));</div>
</div><!-- fragment --><p>The default functor <em>multiplicative_square</em> uses <code>operator*=</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><em>base</em> to the power <em>exponent</em>. </dd></dl>

</div>
</div>
<a id="aa610fc0bbb1838980392872595214a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa610fc0bbb1838980392872595214a72">&#9670;&nbsp;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt;m&gt;&amp; libecc::gcd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; m &gt; &amp;&#160;</td>
          <td class="paramname"><em>polynomial_coefficients0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; m &gt; &amp;&#160;</td>
          <td class="paramname"><em>polynomial_coefficients1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the Greatest Common Denominator of two polynomials over <img class="formulaInl" alt="$\mathbb{Z}_2$" src="form_1036_270.png" width="14" height="13"/> with respectively coefficients <em>polynomial_coefficients0</em> and <em>polynomial_coefficients1</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to either <em>polynomial_coefficients0</em> or <em>polynomial_coefficients1</em>, now containing the gcd of the two arguments.&#160; The bits of the other argument are reset. </dd></dl>

</div>
</div>
<a id="ac394825c0221d5171fe495fb4cac3ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac394825c0221d5171fe495fb4cac3ef2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libecc::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__index.html">bitset_index</a> const &amp;&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__index.html">bitset_index</a> const &amp;&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>

<p class="reference">References <a class="el" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab">libecc::bitset_index::M_index</a>.</p>

<p class="reference">Referenced by <a class="el" href="classlibecc_1_1point.html#a3958676e971af2a954d4a5b510483f84">libecc::point&lt; Polynomial, a, b &gt;::operator==()</a>.</p>

</div>
</div>
<a id="a78dcbe32226b5689d2e2beca495df121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78dcbe32226b5689d2e2beca495df121">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int n1, bool inverted1, unsigned int n2, bool inverted2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libecc::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; n1, inverted1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bits1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; n2, inverted2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bits2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unequivalence operator. </p>
<dl class="section return"><dt>Returns</dt><dd><code>!(bits1 == bits2)</code> </dd></dl>

</div>
</div>
<a id="a17b890f8080ea01a5f0841dcaaea7718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b890f8080ea01a5f0841dcaaea7718">&#9670;&nbsp;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int m, bool inverted1, bool inverted2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Operator::bitsetExpression&lt;m, inverted1, inverted2, Operator::bitsetAND&gt; libecc::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator with bitwise AND for expressions. </p>
<dl class="section see"><dt>See also</dt><dd>bitset::operator= </dd></dl>

</div>
</div>
<a id="a35c9567bf5741a980fc88bb017036885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c9567bf5741a980fc88bb017036885">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N, int DIRECTION&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; libecc::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; const &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator addition. </p>

</div>
</div>
<a id="ade6ba6caaad6f4a28bd92bdc724ed633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6ba6caaad6f4a28bd92bdc724ed633">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N, int DIRECTION&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; libecc::operator+ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; const &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator addition. </p>

</div>
</div>
<a id="ab8a029aa36e135db6aaeb7e6c4d42aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a029aa36e135db6aaeb7e6c4d42aed">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N, int DIRECTION&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; libecc::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; const &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator subtraction. </p>

</div>
</div>
<a id="afcae566219ec9e23ae6ca8b265d7c433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcae566219ec9e23ae6ca8b265d7c433">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N, int DIRECTION&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; libecc::operator- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; const &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator subtraction. </p>

</div>
</div>
<a id="a1f1f35747898307724355a10918c7670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1f35747898307724355a10918c7670">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIRECTION&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libecc::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const &amp;&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const &amp;&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less. </p>

</div>
</div>
<a id="a008d5cfb4a4aab623bbf52cce7befdc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008d5cfb4a4aab623bbf52cce7befdc7">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; libecc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write bitset to ostream. </p>

</div>
</div>
<a id="a21aad3be02a5895f1b39ed1ab1af23b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21aad3be02a5895f1b39ed1ab1af23b7">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIRECTION&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libecc::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const &amp;&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const &amp;&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less or equal. </p>

</div>
</div>
<a id="a20e07c996961c9c66d64359e77443df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e07c996961c9c66d64359e77443df4">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libecc::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__index.html">bitset_index</a> const &amp;&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__index.html">bitset_index</a> const &amp;&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>

<p class="reference">References <a class="el" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab">libecc::bitset_index::M_index</a>.</p>

</div>
</div>
<a id="af78a6daf473021764cc3149528263650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78a6daf473021764cc3149528263650">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int n1, bool inverted1, unsigned int n2, bool inverted2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool libecc::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; n1, inverted1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bits1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; n2, inverted2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bits2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalence operator. </p>
<p>This operator can only compare bitsets and inverted bitsets with eachother.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (x == ~y) ...</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa88882c29e7ac9e33db3d0925ba0340c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88882c29e7ac9e33db3d0925ba0340c">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIRECTION&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libecc::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const &amp;&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const &amp;&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater. </p>

</div>
</div>
<a id="af2fe37de6fff2e4aad69694c690a33f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fe37de6fff2e4aad69694c690a33f6">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIRECTION&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libecc::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const &amp;&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const &amp;&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater or equal. </p>

</div>
</div>
<a id="aa74b9fd7c27ea3209f6f7b7d0d2154a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74b9fd7c27ea3209f6f7b7d0d2154a3">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; libecc::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>bitsetx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bitset from istream. </p>

<p class="reference">References <a class="el" href="classlibecc_1_1bitset.html#a2f7c44b72136449f89e87c9065a50453">libecc::bitset&lt; N &gt;::bitset()</a>.</p>

</div>
</div>
<a id="a9003abb32c0aa28a9a40b3bd368813f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9003abb32c0aa28a9a40b3bd368813f5">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int m, bool inverted1, bool inverted2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Operator::bitsetExpression&lt;m, inverted1, inverted2, Operator::bitsetXOR&gt; libecc::operator^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator with bitwise XOR for expressions. </p>
<dl class="section see"><dt>See also</dt><dd>bitset::operator= </dd></dl>

</div>
</div>
<a id="a6b364a6c7b31b1836d6c6d945153c20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b364a6c7b31b1836d6c6d945153c20f">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int m, bool inverted1, bool inverted2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Operator::bitsetExpression&lt;m, inverted1, inverted2, Operator::bitsetOR&gt; libecc::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator with bitwise OR for expressions. </p>
<dl class="section see"><dt>See also</dt><dd>bitset::operator= </dd></dl>

</div>
</div>
<a id="afb7fc4f4120db4cf68888aa66116fc42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7fc4f4120db4cf68888aa66116fc42">&#9670;&nbsp;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N, bool inverted&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt;N, !inverted&gt; const&amp; libecc::operator~ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; N, inverted &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert a bitset. </p>
<p>This operator is just a cast and doesn't actually do anything until you assign the expression that it is part of to another bitset.</p>
<p>For example:</p>
<div class="fragment"><div class="line">x = ~y;</div>
<div class="line">x ^= ~y &amp; ~z;</div>
</div><!-- fragment --><p>Both cases will run over the digits of bitset x just once and apply the given formula (and any like it) directly on the digits of the bitsets involved.</p>
<p>Inversion can also be used together with the equivalence operators. For example:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (x == ~y) ...</div>
</div><!-- fragment --><p>will only run once over the digits of both bitset and compare the digits once by one using <code>x.digit(d) == ~y.digit(d)</code>. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="aclasslibecc_1_1polynomial_html_a6de63c911a01ec4b240c879f31550ef3"><div class="ttname"><a href="classlibecc_1_1polynomial.html#a6de63c911a01ec4b240c879f31550ef3">libecc::polynomial::square</a></div><div class="ttdeci">polynomial &amp; square(bitset_digit_t *tmpbuf) const</div></div>
<div class="ttc" id="anamespacelibecc_html_a7a7be7cc5bc91d345df9a5668e8a866d"><div class="ttname"><a href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d">libecc::bitset_digit_t</a></div><div class="ttdeci">unsigned long bitset_digit_t</div><div class="ttdoc">Internal data type, used to store the bits of class bitset.</div><div class="ttdef"><b>Definition:</b> bitset.h:69</div></div>
<div class="ttc" id="anamespacelibecc_html_af3c60f0b656da0873ecbe17ec4109563"><div class="ttname"><a href="namespacelibecc.html#af3c60f0b656da0873ecbe17ec4109563">libecc::exponentiation</a></div><div class="ttdeci">field_type exponentiation(field_type const &amp;base, mpz_class const &amp;exponent, square_functor const &amp;do_square=multiplicative_square&lt; field_type &gt;())</div><div class="ttdef"><b>Definition:</b> fieldmath.h:86</div></div>
<div class="ttc" id="aclasslibecc_1_1polynomial_html"><div class="ttname"><a href="classlibecc_1_1polynomial.html">libecc::polynomial</a></div><div class="ttdoc">Polynomial representation of the Galois field F2m.</div><div class="ttdef"><b>Definition:</b> polynomial.h:60</div></div>
<address>Copyright &copy; 2002-2008 Carlo Wood.&nbsp; All rights reserved.</address>
</div>
</body>
</html>
