<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html LANG="en_US">

<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="Author" content="Carlo Wood">
<meta name="description" content="Elliptic Curve Cryptography C++ Library">
<meta name="keywords" content="libecc, fast, elliptic curves, cryptography, fixed key size, speed, object orientation, OO, C++">
<title>libecc: Elliptic Curve Cryptography C++ Library - Reference Manual</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<script src="../scripts/detect_browser.js"></script>
<script>need_style_doxygen=1</script>
<script src="../scripts/load_style_sheets.js"></script>
</head>

<body>
<div class="normal">

<center>
<a class="qindex" href="../index.html">Main Page</a> &nbsp;
<a class="qindex" href="index.html">Reference Manual</a> &nbsp;
<a class="qindex" href="annotated.html">Compound List</a> &nbsp;
<a class="qindex" href="files.html">File List</a> &nbsp;
</center>

<hr size=1 noshade>
<!-- Generated by Doxygen 1.7.1 -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>libecc Namespace Reference</h1>  </div>
</div>
<div class="contents">

<p>Namespace for libecc.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset__index.html">bitset_index</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A bitset index.  <a href="classlibecc_1_1bitset__index.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A bitset index with increment/decrement methods.  <a href="classlibecc_1_1bitset__index__iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A non-mutable bitset-iterator.  <a href="classlibecc_1_1bitset__iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibecc_1_1bitset__base.html">bitset_base</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class of <a class="el" href="classlibecc_1_1bitset.html" title="A bitset with a fixed number of bits.">libecc::bitset</a>.  <a href="structlibecc_1_1bitset__base.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A bitset with a fixed number of bits, having possibly an infinite number of leading virtual 1's.  <a href="classlibecc_1_1bitset__invertible.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1bitset.html">bitset</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A bitset with a fixed number of bits.  <a href="classlibecc_1_1bitset.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibecc_1_1assign.html">assign</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operation used with <a class="el" href="classlibecc_1_1bitset.html#a446a27809cd4cb9ed6e83629a3f328bc" title="Perform a shift operation followed by a bit operation.">libecc::bitset::shift_op</a>.  <a href="structlibecc_1_1assign.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibecc_1_1exor.html">exor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operation used with <a class="el" href="classlibecc_1_1bitset.html#a446a27809cd4cb9ed6e83629a3f328bc" title="Perform a shift operation followed by a bit operation.">libecc::bitset::shift_op</a>.  <a href="structlibecc_1_1exor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibecc_1_1left.html">left</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shift direction used with <a class="el" href="classlibecc_1_1bitset.html#a446a27809cd4cb9ed6e83629a3f328bc" title="Perform a shift operation followed by a bit operation.">libecc::bitset::shift_op</a>.  <a href="structlibecc_1_1left.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibecc_1_1right.html">right</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shift direction used with <a class="el" href="classlibecc_1_1bitset.html#a446a27809cd4cb9ed6e83629a3f328bc" title="Perform a shift operation followed by a bit operation.">libecc::bitset::shift_op</a>.  <a href="structlibecc_1_1right.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1rng.html">rng</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pseudo Random Number Generator.  <a href="classlibecc_1_1rng.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1sha1.html">sha1</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SHA-1.  <a href="classlibecc_1_1sha1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1polynomial.html">polynomial</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Polynomial representation of the Galois field <span class="Formula">F<sub>2<sup>m</sup></sub></span>.  <a href="classlibecc_1_1polynomial.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibecc_1_1point.html">point</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Point <span class="Formula">(x,y)</span> on elliptic curve <span class="Formula">x<sup>3</sup> + ax<sup>2</sup> + b = y<sup>2</sup> + xy</span>.  <a href="classlibecc_1_1point.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d">bitset_digit_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal data type, used to store the bits of class bitset.  <a href="#a7a7be7cc5bc91d345df9a5668e8a866d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a20e07c996961c9c66d64359e77443df4">operator==</a> (<a class="el" href="classlibecc_1_1bitset__index.html">bitset_index</a> const &amp;i1, <a class="el" href="classlibecc_1_1bitset__index.html">bitset_index</a> const &amp;i2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality operator.  <a href="#a20e07c996961c9c66d64359e77443df4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#ac394825c0221d5171fe495fb4cac3ef2">operator!=</a> (<a class="el" href="classlibecc_1_1bitset__index.html">bitset_index</a> const &amp;i1, <a class="el" href="classlibecc_1_1bitset__index.html">bitset_index</a> const &amp;i2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality operator.  <a href="#ac394825c0221d5171fe495fb4cac3ef2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int DIRECTION&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a6dd9d88ad6232a1440bf99b9a17d0999">operator&lt;</a> (<a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const &amp;i1, <a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const &amp;i2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Less.  <a href="#a6dd9d88ad6232a1440bf99b9a17d0999"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int DIRECTION&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#ad633c82ce07ed657f0253109b6ddab2e">operator&gt;</a> (<a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const &amp;i1, <a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const &amp;i2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Greater.  <a href="#ad633c82ce07ed657f0253109b6ddab2e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int DIRECTION&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a6414177ca4462dcca73a183f33872f4d">operator&lt;=</a> (<a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const &amp;i1, <a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const &amp;i2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Less or equal.  <a href="#a6414177ca4462dcca73a183f33872f4d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int DIRECTION&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a2a5c351ce802cec421f36c5e0dfc74a5">operator&gt;=</a> (<a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const &amp;i1, <a class="el" href="classlibecc_1_1bitset__index__iterator.html">bitset_index_iterator</a>&lt; DIRECTION &gt; const &amp;i2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Greater or equal.  <a href="#a2a5c351ce802cec421f36c5e0dfc74a5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int N, int DIRECTION&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a36b6c0536e6dc391140e676cb2315c53">operator+</a> (<a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; const &amp;i, int d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator addition.  <a href="#a36b6c0536e6dc391140e676cb2315c53"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int N, int DIRECTION&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a7bcecfdcf3f7e1fc4f175eb7215815a8">operator+</a> (int d, <a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; const &amp;i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator addition.  <a href="#a7bcecfdcf3f7e1fc4f175eb7215815a8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int N, int DIRECTION&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a0b71c59d918245ddafffcfcb3a823ee6">operator-</a> (<a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; const &amp;i, int d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator subtraction.  <a href="#a0b71c59d918245ddafffcfcb3a823ee6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int N, int DIRECTION&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#ab7b21143e0373255d40d4b81a566c7bc">operator-</a> (int d, <a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; const &amp;i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator subtraction.  <a href="#ab7b21143e0373255d40d4b81a566c7bc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int N, bool inverted&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; N,!inverted &gt;<br class="typebreak"/>
 const &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a235eedb20a11ff426c5d6a1e63fe04b0">operator~</a> (<a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; N, inverted &gt; const &amp;bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invert a bitset.  <a href="#a235eedb20a11ff426c5d6a1e63fe04b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int n1, bool inverted1, unsigned int n2, bool inverted2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a342f4385a37ad89ff8b7d965392effb6">operator==</a> (<a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; n1, inverted1 &gt; const &amp;bits1, <a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; n2, inverted2 &gt; const &amp;bits2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equivalence operator.  <a href="#a342f4385a37ad89ff8b7d965392effb6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int n1, bool inverted1, unsigned int n2, bool inverted2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#ae9b836e6e5fa4c0089f9c6dda286e03b">operator!=</a> (<a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; n1, inverted1 &gt; const &amp;bits1, <a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; n2, inverted2 &gt; const &amp;bits2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unequivalence operator.  <a href="#ae9b836e6e5fa4c0089f9c6dda286e03b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int m, bool inverted1, bool inverted2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Operator::bitsetExpression&lt; m, <br class="typebreak"/>
inverted1, inverted2, <br class="typebreak"/>
Operator::bitsetAND &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#aadbb5397d68c20d4082c181578d17ed0">operator&amp;</a> (<a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted1 &gt; const &amp;arg1, <a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted2 &gt; const &amp;arg2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator with bitwise AND for expressions.  <a href="#aadbb5397d68c20d4082c181578d17ed0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int m, bool inverted1, bool inverted2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Operator::bitsetExpression&lt; m, <br class="typebreak"/>
inverted1, inverted2, <br class="typebreak"/>
Operator::bitsetOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a9c3499b2519e3394ff9fe3260bbab5e9">operator|</a> (<a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted1 &gt; const &amp;arg1, <a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted2 &gt; const &amp;arg2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator with bitwise OR for expressions.  <a href="#a9c3499b2519e3394ff9fe3260bbab5e9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int m, bool inverted1, bool inverted2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Operator::bitsetExpression&lt; m, <br class="typebreak"/>
inverted1, inverted2, <br class="typebreak"/>
Operator::bitsetXOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a6486d5676238ef8c129ca46cb197a989">operator^</a> (<a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted1 &gt; const &amp;arg1, <a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt; m, inverted2 &gt; const &amp;arg2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator with bitwise XOR for expressions.  <a href="#a6486d5676238ef8c129ca46cb197a989"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a8b8aae3b135c4b928cf7caacfc21ddda">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; N &gt; &amp;bitsetx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read bitset from istream.  <a href="#a8b8aae3b135c4b928cf7caacfc21ddda"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a6f604c27b346d0face2d30fd58c2f1c0">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; N &gt; const &amp;bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write bitset to ostream.  <a href="#a6f604c27b346d0face2d30fd58c2f1c0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int m, unsigned int k, unsigned int k1, unsigned int k2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#ad65aa955d2dac93b01348ce38fe2038e">operator*</a> (<a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt; const &amp;, <a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt; const &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int m, unsigned int k, unsigned int k1, unsigned int k2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a6c1a17c0edf91f0763e30845d1393302">operator/</a> (<a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt; const &amp;, <a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt; const &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int m, unsigned int k, unsigned int k1, unsigned int k2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a4dc3cea520f9716401f100670a606a6c">operator==</a> (<a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt; const &amp;, <a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt; const &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int m, unsigned int k, unsigned int k1, unsigned int k2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#acd966668d5904d3f551fc1db22ddaa3b">operator!=</a> (<a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt; const &amp;, <a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt; const &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int m, unsigned int k, unsigned int k1, unsigned int k2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#ae8e184d661d996e4e8f5f100f851dfc5">operator&lt;&lt;</a> (std::ostream &amp;, <a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt; const &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int m, unsigned int k, unsigned int k1, unsigned int k2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt;<br class="typebreak"/>
::xor_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a6c3f7419bed635af1a227cd63cabd8ba">operator+</a> (<a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt; const &amp;, <a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt; const &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int m, unsigned int k, unsigned int k1, unsigned int k2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt;<br class="typebreak"/>
::xor_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a60483329f2a1b7553b16167bb73d1264">operator-</a> (<a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt; const &amp;, <a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt; const &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class field_type , class square_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">field_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#a8ca53ab8c41c4c288c70f45c263bc099">exponentiation</a> (field_type const &amp;base, mpz_class const &amp;exponent, square_functor const &amp;do_square=multiplicative_square&lt; field_type &gt;())</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int m&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; m &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibecc.html#afcf7bbb8b9906784eb5bb28f548d7e03">gcd</a> (<a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; m &gt; &amp;polynomial_coefficients0, <a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt; m &gt; &amp;polynomial_coefficients1)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Namespace for libecc. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a7a7be7cc5bc91d345df9a5668e8a866d"></a><!-- doxytag: member="libecc::bitset_digit_t" ref="a7a7be7cc5bc91d345df9a5668e8a866d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d">libecc::bitset_digit_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal data type, used to store the bits of class bitset. </p>
<p>The number of bits in the builtin-type <code>long</code> turns out to be equal to the size of the databus between memory and cpu. The internal type used to store the bits of a bitset is therefore an <code>unsigned long</code> resulting in the most efficient code for bit manipulation. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a8ca53ab8c41c4c288c70f45c263bc099"></a><!-- doxytag: member="libecc::exponentiation" ref="a8ca53ab8c41c4c288c70f45c263bc099" args="(field_type const &amp;base, mpz_class const &amp;exponent, square_functor const &amp;do_square=multiplicative_square&lt; field_type &gt;())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class field_type , class square_functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">field_type libecc::exponentiation </td>
          <td>(</td>
          <td class="paramtype">field_type const &amp;&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_class const &amp;&nbsp;</td>
          <td class="paramname"> <em>exponent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">square_functor const &amp;&nbsp;</td>
          <td class="paramname"> <em>do_square</em> = <code>multiplicative_square&lt;field_type&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates the exponentiation of an arbitrary field element. The field must have defined the methods <code>unity()</code> and <code>operator*=</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>field_type</em>&nbsp;</td><td>The type of the field element. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>square_functor</em>&nbsp;</td><td>A functor to calculate the square of a field_type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>The field_type that will be exponentiated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exponent</em>&nbsp;</td><td>The exponent of the exponentiation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>do_square</em>&nbsp;</td><td>The square_functor.</td></tr>
  </table>
  </dd>
</dl>
<p><em>square_functor</em> must define a method <code>void operator()(field_type&amp; x)</code> setting <code>x</code> to its square.</p>
<p>For example for a <a class="el" href="classlibecc_1_1polynomial.html">libecc::polynomial</a> :</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k&gt;
   <span class="keyword">class</span>polynomial_square {
     <a class="code" href="namespacelibecc.html#a7a7be7cc5bc91d345df9a5668e8a866d" title="Internal data type, used to store the bits of class bitset.">libecc::bitset_digit_t</a> buffer[<a class="code" href="classlibecc_1_1polynomial.html" title="Polynomial representation of the Galois field F2m.">libecc::polynomial&lt;m, k&gt;::square_digits</a>];
     <span class="keyword">public</span>:
       <span class="keywordtype">void</span> operator()(<a class="code" href="classlibecc_1_1polynomial.html" title="Polynomial representation of the Galois field F2m.">libecc::polynomial&lt;m, k&gt;</a>&amp; p) { p = p.<a class="code" href="classlibecc_1_1polynomial.html#a2e61df3858bb78ca33541a3f45e6dd68">square</a>(buffer); }
   };
</pre></div><p>and then use</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classlibecc_1_1polynomial.html" title="Polynomial representation of the Galois field F2m.">libecc::polynomial&lt;m, k&gt;</a> power(<a class="code" href="namespacelibecc.html#a8ca53ab8c41c4c288c70f45c263bc099">exponentiation</a>(base, exponent, polynomial_square&lt;m, k&gt;()));
</pre></div><p>The default functor <em>multiplicative_square</em> uses <code>operator*=</code>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>base</em> to the power <em>exponent</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="afcf7bbb8b9906784eb5bb28f548d7e03"></a><!-- doxytag: member="libecc::gcd" ref="afcf7bbb8b9906784eb5bb28f548d7e03" args="(bitset&lt; m &gt; &amp;polynomial_coefficients0, bitset&lt; m &gt; &amp;polynomial_coefficients1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset.html">bitset</a>&lt;m&gt;&amp; libecc::gcd </td>
          <td>(</td>
          <td class="paramtype">bitset&lt; m &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>polynomial_coefficients0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitset&lt; m &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>polynomial_coefficients1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates the Greatest Common Denominator of two polynomials over <img class="formulaInl" alt="$\mathbb{Z}_2$" src="form_1022_271.png"/> with respectively coefficients <em>polynomial_coefficients0</em> and <em>polynomial_coefficients1</em>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to either <em>polynomial_coefficients0</em> or <em>polynomial_coefficients1</em>, now containing the gcd of the two arguments.&nbsp; The bits of the other argument are reset. </dd></dl>

<p>References <a class="el" href="structlibecc_1_1bitset__base.html#a4a8b1ec5cd0e596877f8613f2644a869">libecc::bitset_base&lt; N &gt;::rbegin()</a>.</p>

</div>
</div>
<a class="anchor" id="ac394825c0221d5171fe495fb4cac3ef2"></a><!-- doxytag: member="libecc::operator!=" ref="ac394825c0221d5171fe495fb4cac3ef2" args="(bitset_index const &amp;i1, bitset_index const &amp;i2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool libecc::operator!= </td>
          <td>(</td>
          <td class="paramtype">bitset_index const &amp;&nbsp;</td>
          <td class="paramname"> <em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitset_index const &amp;&nbsp;</td>
          <td class="paramname"> <em>i2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inequality operator. </p>

<p>References <a class="el" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab">libecc::bitset_index::M_index</a>.</p>

</div>
</div>
<a class="anchor" id="acd966668d5904d3f551fc1db22ddaa3b"></a><!-- doxytag: member="libecc::operator!=" ref="acd966668d5904d3f551fc1db22ddaa3b" args="(polynomial&lt; m, k, k1, k2 &gt; const &amp;, polynomial&lt; m, k, k1, k2 &gt; const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int m, unsigned int k, unsigned int k1, unsigned int k2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool libecc::operator!= </td>
          <td>(</td>
          <td class="paramtype">polynomial&lt; m, k, k1, k2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">polynomial&lt; m, k, k1, k2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compare two polynomials. Returns <code>true</code> when <em>p1</em> != <em>p2</em>, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ae9b836e6e5fa4c0089f9c6dda286e03b"></a><!-- doxytag: member="libecc::operator!=" ref="ae9b836e6e5fa4c0089f9c6dda286e03b" args="(bitset_invertible&lt; n1, inverted1 &gt; const &amp;bits1, bitset_invertible&lt; n2, inverted2 &gt; const &amp;bits2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int n1, bool inverted1, unsigned int n2, bool inverted2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool libecc::operator!= </td>
          <td>(</td>
          <td class="paramtype">bitset_invertible&lt; n1, inverted1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>bits1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitset_invertible&lt; n2, inverted2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>bits2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unequivalence operator. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>!(bits1 == bits2)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="aadbb5397d68c20d4082c181578d17ed0"></a><!-- doxytag: member="libecc::operator&amp;" ref="aadbb5397d68c20d4082c181578d17ed0" args="(bitset_invertible&lt; m, inverted1 &gt; const &amp;arg1, bitset_invertible&lt; m, inverted2 &gt; const &amp;arg2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int m, bool inverted1, bool inverted2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Operator::bitsetExpression&lt;m, inverted1, inverted2, Operator::bitsetAND&gt; libecc::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">bitset_invertible&lt; m, inverted1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitset_invertible&lt; m, inverted2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator with bitwise AND for expressions. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>bitset::operator= </dd></dl>

</div>
</div>
<a class="anchor" id="ad65aa955d2dac93b01348ce38fe2038e"></a><!-- doxytag: member="libecc::operator*" ref="ad65aa955d2dac93b01348ce38fe2038e" args="(polynomial&lt; m, k, k1, k2 &gt; const &amp;, polynomial&lt; m, k, k1, k2 &gt; const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int m, unsigned int k, unsigned int k1, unsigned int k2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt; libecc::operator* </td>
          <td>(</td>
          <td class="paramtype">polynomial&lt; m, k, k1, k2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">polynomial&lt; m, k, k1, k2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Multiply polynomial <em>p1</em> with polynomial <em>p2</em>. </p>

</div>
</div>
<a class="anchor" id="a7bcecfdcf3f7e1fc4f175eb7215815a8"></a><!-- doxytag: member="libecc::operator+" ref="a7bcecfdcf3f7e1fc4f175eb7215815a8" args="(int d, bitset_iterator&lt; N, DIRECTION &gt; const &amp;i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N, int DIRECTION&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; libecc::operator+ </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitset_iterator&lt; N, DIRECTION &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator addition. </p>

</div>
</div>
<a class="anchor" id="a36b6c0536e6dc391140e676cb2315c53"></a><!-- doxytag: member="libecc::operator+" ref="a36b6c0536e6dc391140e676cb2315c53" args="(bitset_iterator&lt; N, DIRECTION &gt; const &amp;i, int d)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N, int DIRECTION&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; libecc::operator+ </td>
          <td>(</td>
          <td class="paramtype">bitset_iterator&lt; N, DIRECTION &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator addition. </p>

</div>
</div>
<a class="anchor" id="a6c3f7419bed635af1a227cd63cabd8ba"></a><!-- doxytag: member="libecc::operator+" ref="a6c3f7419bed635af1a227cd63cabd8ba" args="(polynomial&lt; m, k, k1, k2 &gt; const &amp;, polynomial&lt; m, k, k1, k2 &gt; const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int m, unsigned int k, unsigned int k1, unsigned int k2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt;::xor_type libecc::operator+ </td>
          <td>(</td>
          <td class="paramtype">polynomial&lt; m, k, k1, k2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">polynomial&lt; m, k, k1, k2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prepare the addition of two polynomials.</p>
<p>Returns a dummy object with two pointers to the polynomials to be added. The addition does not take place until the final destination polynomial is known as well.</p>
<p>Note that it is <em>not</em> possible to write:</p>
<div class="fragment"><pre class="fragment"> p1 OP= p1 + p2 + p3;
</pre></div><p>There is a complicated reason for that. Instead, write</p>
<div class="fragment"><pre class="fragment"> polynomial&lt;m,k&gt; tmp(p2 + p3);
 p1 OP= p1 + tmp;
</pre></div><p>For example, when adding a whole series of polynomials you'd do:</p>
<div class="fragment"><pre class="fragment"> polynomial&lt;m,k&gt; result(p1 + p2);
 result += p3 + p4;
 result += p5 + p5;
 ...
</pre></div><p>Basically, it is not supported to add or substract a polynomial to or from a temporary that represents an addition or subtraction by itself. </p>

</div>
</div>
<a class="anchor" id="a0b71c59d918245ddafffcfcb3a823ee6"></a><!-- doxytag: member="libecc::operator&#45;" ref="a0b71c59d918245ddafffcfcb3a823ee6" args="(bitset_iterator&lt; N, DIRECTION &gt; const &amp;i, int d)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N, int DIRECTION&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; libecc::operator- </td>
          <td>(</td>
          <td class="paramtype">bitset_iterator&lt; N, DIRECTION &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator subtraction. </p>

</div>
</div>
<a class="anchor" id="ab7b21143e0373255d40d4b81a566c7bc"></a><!-- doxytag: member="libecc::operator&#45;" ref="ab7b21143e0373255d40d4b81a566c7bc" args="(int d, bitset_iterator&lt; N, DIRECTION &gt; const &amp;i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N, int DIRECTION&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset__iterator.html">bitset_iterator</a>&lt; N, DIRECTION &gt; libecc::operator- </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitset_iterator&lt; N, DIRECTION &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator subtraction. </p>

</div>
</div>
<a class="anchor" id="a60483329f2a1b7553b16167bb73d1264"></a><!-- doxytag: member="libecc::operator&#45;" ref="a60483329f2a1b7553b16167bb73d1264" args="(polynomial&lt; m, k, k1, k2 &gt; const &amp;, polynomial&lt; m, k, k1, k2 &gt; const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int m, unsigned int k, unsigned int k1, unsigned int k2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt;::xor_type libecc::operator- </td>
          <td>(</td>
          <td class="paramtype">polynomial&lt; m, k, k1, k2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">polynomial&lt; m, k, k1, k2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prepare the subtraction of two polynomials.</p>
<p>Returns a dummy object with two pointers to the polynomials to be subtracted. The subtraction does not take place until the final destination polynomial is known as well.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespacelibecc.html#a6c3f7419bed635af1a227cd63cabd8ba">operator+(polynomial const&amp;, polynomial const&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6c1a17c0edf91f0763e30845d1393302"></a><!-- doxytag: member="libecc::operator/" ref="a6c1a17c0edf91f0763e30845d1393302" args="(polynomial&lt; m, k, k1, k2 &gt; const &amp;, polynomial&lt; m, k, k1, k2 &gt; const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int m, unsigned int k, unsigned int k1, unsigned int k2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1polynomial.html">polynomial</a>&lt; m, k, k1, k2 &gt; libecc::operator/ </td>
          <td>(</td>
          <td class="paramtype">polynomial&lt; m, k, k1, k2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">polynomial&lt; m, k, k1, k2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Devide polynomial <em>p1</em> by polynomial <em>p2</em>. </p>

</div>
</div>
<a class="anchor" id="a6dd9d88ad6232a1440bf99b9a17d0999"></a><!-- doxytag: member="libecc::operator&lt;" ref="a6dd9d88ad6232a1440bf99b9a17d0999" args="(bitset_index_iterator&lt; DIRECTION &gt; const &amp;i1, bitset_index_iterator&lt; DIRECTION &gt; const &amp;i2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIRECTION&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool libecc::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">bitset_index_iterator&lt; DIRECTION &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitset_index_iterator&lt; DIRECTION &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>i2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Less. </p>

</div>
</div>
<a class="anchor" id="a6f604c27b346d0face2d30fd58c2f1c0"></a><!-- doxytag: member="libecc::operator&lt;&lt;" ref="a6f604c27b346d0face2d30fd58c2f1c0" args="(std::ostream &amp;os, bitset&lt; N &gt; const &amp;bits)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; libecc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitset&lt; N &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write bitset to ostream. </p>

</div>
</div>
<a class="anchor" id="ae8e184d661d996e4e8f5f100f851dfc5"></a><!-- doxytag: member="libecc::operator&lt;&lt;" ref="ae8e184d661d996e4e8f5f100f851dfc5" args="(std::ostream &amp;, polynomial&lt; m, k, k1, k2 &gt; const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int m, unsigned int k, unsigned int k1, unsigned int k2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; libecc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">polynomial&lt; m, k, k1, k2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the binary coefficients of the polynomial <em>p</em> to <em>os</em>.</p>
<p>For example, an output string <code>1001101</code> means <span class="Formula">t<sup>6</sup> + t<sup>3</sup> + t<sup>2</sup> + 1</span>. </p>

</div>
</div>
<a class="anchor" id="a6414177ca4462dcca73a183f33872f4d"></a><!-- doxytag: member="libecc::operator&lt;=" ref="a6414177ca4462dcca73a183f33872f4d" args="(bitset_index_iterator&lt; DIRECTION &gt; const &amp;i1, bitset_index_iterator&lt; DIRECTION &gt; const &amp;i2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIRECTION&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool libecc::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">bitset_index_iterator&lt; DIRECTION &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitset_index_iterator&lt; DIRECTION &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>i2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Less or equal. </p>

</div>
</div>
<a class="anchor" id="a4dc3cea520f9716401f100670a606a6c"></a><!-- doxytag: member="libecc::operator==" ref="a4dc3cea520f9716401f100670a606a6c" args="(polynomial&lt; m, k, k1, k2 &gt; const &amp;, polynomial&lt; m, k, k1, k2 &gt; const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int m, unsigned int k, unsigned int k1, unsigned int k2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool libecc::operator== </td>
          <td>(</td>
          <td class="paramtype">polynomial&lt; m, k, k1, k2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">polynomial&lt; m, k, k1, k2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compare two polynomials. Returns <code>true</code> when <em>p1</em> == <em>p2</em>, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a20e07c996961c9c66d64359e77443df4"></a><!-- doxytag: member="libecc::operator==" ref="a20e07c996961c9c66d64359e77443df4" args="(bitset_index const &amp;i1, bitset_index const &amp;i2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool libecc::operator== </td>
          <td>(</td>
          <td class="paramtype">bitset_index const &amp;&nbsp;</td>
          <td class="paramname"> <em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitset_index const &amp;&nbsp;</td>
          <td class="paramname"> <em>i2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equality operator. </p>

<p>References <a class="el" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab">libecc::bitset_index::M_index</a>.</p>

</div>
</div>
<a class="anchor" id="a342f4385a37ad89ff8b7d965392effb6"></a><!-- doxytag: member="libecc::operator==" ref="a342f4385a37ad89ff8b7d965392effb6" args="(bitset_invertible&lt; n1, inverted1 &gt; const &amp;bits1, bitset_invertible&lt; n2, inverted2 &gt; const &amp;bits2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int n1, bool inverted1, unsigned int n2, bool inverted2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool libecc::operator== </td>
          <td>(</td>
          <td class="paramtype">bitset_invertible&lt; n1, inverted1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>bits1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitset_invertible&lt; n2, inverted2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>bits2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equivalence operator. </p>
<p>This operator can only compare bitsets and inverted bitsets with eachother.</p>
<p>For example:</p>
<div class="fragment"><pre class="fragment"> <span class="keywordflow">if</span> (x == ~y) ...
</pre></div> 
<p>References <a class="el" href="structlibecc_1_1bitset__base.html#a2eed05c44dcf2492b9f43291789d3d2e">libecc::bitset_base&lt; N &gt;::vector</a>.</p>

</div>
</div>
<a class="anchor" id="ad633c82ce07ed657f0253109b6ddab2e"></a><!-- doxytag: member="libecc::operator&gt;" ref="ad633c82ce07ed657f0253109b6ddab2e" args="(bitset_index_iterator&lt; DIRECTION &gt; const &amp;i1, bitset_index_iterator&lt; DIRECTION &gt; const &amp;i2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIRECTION&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool libecc::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">bitset_index_iterator&lt; DIRECTION &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitset_index_iterator&lt; DIRECTION &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>i2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Greater. </p>

<p>References <a class="el" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab">libecc::bitset_index::M_index</a>.</p>

</div>
</div>
<a class="anchor" id="a2a5c351ce802cec421f36c5e0dfc74a5"></a><!-- doxytag: member="libecc::operator&gt;=" ref="a2a5c351ce802cec421f36c5e0dfc74a5" args="(bitset_index_iterator&lt; DIRECTION &gt; const &amp;i1, bitset_index_iterator&lt; DIRECTION &gt; const &amp;i2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIRECTION&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool libecc::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">bitset_index_iterator&lt; DIRECTION &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitset_index_iterator&lt; DIRECTION &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>i2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Greater or equal. </p>

<p>References <a class="el" href="classlibecc_1_1bitset__index.html#a06c8986704b2b81a07b2f758ceda8fab">libecc::bitset_index::M_index</a>.</p>

</div>
</div>
<a class="anchor" id="a8b8aae3b135c4b928cf7caacfc21ddda"></a><!-- doxytag: member="libecc::operator&gt;&gt;" ref="a8b8aae3b135c4b928cf7caacfc21ddda" args="(std::istream &amp;is, bitset&lt; N &gt; &amp;bitsetx)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; libecc::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitset&lt; N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bitsetx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read bitset from istream. </p>

<p>References <a class="el" href="classlibecc_1_1bitset.html#a2f7c44b72136449f89e87c9065a50453">libecc::bitset&lt; N &gt;::bitset()</a>.</p>

</div>
</div>
<a class="anchor" id="a6486d5676238ef8c129ca46cb197a989"></a><!-- doxytag: member="libecc::operator^" ref="a6486d5676238ef8c129ca46cb197a989" args="(bitset_invertible&lt; m, inverted1 &gt; const &amp;arg1, bitset_invertible&lt; m, inverted2 &gt; const &amp;arg2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int m, bool inverted1, bool inverted2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Operator::bitsetExpression&lt;m, inverted1, inverted2, Operator::bitsetXOR&gt; libecc::operator^ </td>
          <td>(</td>
          <td class="paramtype">bitset_invertible&lt; m, inverted1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitset_invertible&lt; m, inverted2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator with bitwise XOR for expressions. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>bitset::operator= </dd></dl>

</div>
</div>
<a class="anchor" id="a9c3499b2519e3394ff9fe3260bbab5e9"></a><!-- doxytag: member="libecc::operator|" ref="a9c3499b2519e3394ff9fe3260bbab5e9" args="(bitset_invertible&lt; m, inverted1 &gt; const &amp;arg1, bitset_invertible&lt; m, inverted2 &gt; const &amp;arg2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int m, bool inverted1, bool inverted2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Operator::bitsetExpression&lt;m, inverted1, inverted2, Operator::bitsetOR&gt; libecc::operator| </td>
          <td>(</td>
          <td class="paramtype">bitset_invertible&lt; m, inverted1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitset_invertible&lt; m, inverted2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator with bitwise OR for expressions. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>bitset::operator= </dd></dl>

</div>
</div>
<a class="anchor" id="a235eedb20a11ff426c5d6a1e63fe04b0"></a><!-- doxytag: member="libecc::operator~" ref="a235eedb20a11ff426c5d6a1e63fe04b0" args="(bitset_invertible&lt; N, inverted &gt; const &amp;bits)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N, bool inverted&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibecc_1_1bitset__invertible.html">bitset_invertible</a>&lt;N, !inverted&gt; const&amp; libecc::operator~ </td>
          <td>(</td>
          <td class="paramtype">bitset_invertible&lt; N, inverted &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>bits</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Invert a bitset. </p>
<p>This operator is just a cast and doesn't actually do anything until you assign the expression that it is part of to another bitset.</p>
<p>For example:</p>
<div class="fragment"><pre class="fragment"> x = ~y;
 x ^= ~y &amp; ~z;
</pre></div><p>Both cases will run over the digits of bitset x just once and apply the given formula (and any like it) directly on the digits of the bitsets involved.</p>
<p>Inversion can also be used together with the equivalence operators. For example:</p>
<div class="fragment"><pre class="fragment"> <span class="keywordflow">if</span> (x == ~y) ...
</pre></div><p>will only run once over the digits of both bitset and compare the digits once by one using <code>x.digit(d) == ~y.digit(d)</code>. </p>

</div>
</div>
</div>
<address>Copyright &copy; 2002-2008 Carlo Wood.&nbsp; All rights reserved.</address>

</div>
</body>
</html>

