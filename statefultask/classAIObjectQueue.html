<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="Author" content="Carlo Wood">
<meta name="description" content="ai-statefultask">
<title>ai-statefultask version 2cfbfa5 documentation</title>
<link rel="shortcut icon" href="images/favicon.ico">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="main.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top">
<div id="titlearea">
<table>
 <tbody>
  <tr>
  <td style="width: 128px"><img src="images/aistatefultask_arc.png"></td>
  <td>
    <p id="html_header1"><span id="name">AIStatefulTask</span> &dash; Asynchronous, Stateful Task Scheduler library.</p>
    <p id="html_header2">Threads-like task objects evolving through user-defined states.</p>
  </td>
  </tr>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classAIObjectQueue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AIObjectQueue&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class AIObjectQueue&lt; T &gt;</h3>

<p>A ring buffer for moveable objects. </p>
<p>Usage (using for example <code>std::function&lt;void()&gt;</code>):</p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> <a class="code" href="classAIObjectQueue.html#aea2846d63f6fa9d2f306397410add357">capacity</a> = 8;</div><div class="line"><a class="code" href="classAIObjectQueue.html">AIObjectQueue&lt;std::function&lt;void()&gt;</a>&gt; queue(capacity);    <span class="comment">// Allocates 9 std::function&lt;void()&gt; objects.</span></div></div><!-- fragment --><p>The actual size of the allocated memory for this queue will be nine: eight objects can be written to the queue without reading anything from it. The space for the nineth object is reserved to store the last object that was already read from the queue but wasn't popped yet.</p><div class="fragment"><div class="line"><span class="comment">// Producer threads:</span></div><div class="line">{ <span class="comment">// Lock the queue for other producer threads.</span></div><div class="line">  <span class="keyword">auto</span> access = queue.producer_access();</div><div class="line">  <span class="keywordtype">int</span> length = access.length();</div><div class="line">  <span class="keywordflow">if</span> (length == capacity) { <span class="comment">/* Buffer full */</span> <span class="keywordflow">return</span>; }</div><div class="line">  access.move_in([](){ std::cout &lt;&lt; <span class="stringliteral">&quot;Hello\n&quot;</span>; });</div><div class="line">} <span class="comment">// Unlock the queue.</span></div></div><!-- fragment --><p>The value of <code>length</code> allows one to do client-side bandwidth control; by reducing the throughput till the returned length is as small as possible one can reduce the latency.</p>
<p>Note that due to race conditions, the actual length might be less, as consumer threads can read from the queue while we hold the producer lock.</p><div class="fragment"><div class="line"><span class="comment">// Consumer threads:</span></div><div class="line">std::function&lt;void()&gt; f;</div><div class="line">{ <span class="comment">// Lock the queue for other consumer threads.</span></div><div class="line">  <span class="keyword">auto</span> access = queue.consumer_access();</div><div class="line">  <span class="keywordtype">int</span> length = access.length();</div><div class="line">  <span class="keywordflow">if</span> (length == 0) { <span class="comment">/* Buffer empty */</span> <span class="keywordflow">return</span>; }</div><div class="line">  f = access.move_out();</div><div class="line">} <span class="comment">// Unlock the queue.</span></div><div class="line">f(); <span class="comment">// Invoke the functor.</span></div></div><!-- fragment --><p>Here the actual length might be greater than the returned value because producer threads can still write to the queue while we hold the consumer lock. In fact, both calls to <code>length()</code> do essentially the same calculation (which doesn't require locking at all to be thread-safe); the only difference is the memory model used for access, but the locking by accessing <code>length()</code> through the respective access objects is necessary to prevent a producer thread having a race condition with another producer thread, or a consumer thread having a race condition with another consumer thread.</p>
<h3>const qualifier and AIObjectQueue&lt;T&gt;</h3>
<p>Essentially, an AIObjectQueue only allows one to move objects of type <code>T</code> into and out of the queue; it doesn't have accessors. Consequently none of its member functions is const.</p>
<p>Therefore, it is possible to overload the use of the const qualifier for the public member functions to mean: these member functions are threadsafe; they may be accessed concurrently by multiple threads.</p>
<p>Specifically, <a class="el" href="classAIObjectQueue.html#a69cdab4a806e019d824bd43f099c1375" title="Obtain exclusive producer access to the buffer. ">producer_access()</a> and <a class="el" href="classAIObjectQueue.html#a6908f63adcc53ccaed42db70ffd3249d" title="Obtain exclusive consumer access to the buffer. ">consumer_access()</a>, although <code>const</code>, <em>do</em> allow respectively writing data into &dash; and extracting data from the queue. Their const-ness merely means that concurrent access is thread safe. </p>
</div>
<p><code>#include &lt;<a class="el" href="AIObjectQueue_8h_source.html">AIObjectQueue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIObjectQueue_1_1ConsumerAccess.html">ConsumerAccess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return type of <a class="el" href="classAIObjectQueue.html#a6908f63adcc53ccaed42db70ffd3249d" title="Obtain exclusive consumer access to the buffer. ">consumer_access()</a>.  <a href="structAIObjectQueue_1_1ConsumerAccess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIObjectQueue_1_1ProducerAccess.html">ProducerAccess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return type of <a class="el" href="classAIObjectQueue.html#a69cdab4a806e019d824bd43f099c1375" title="Obtain exclusive producer access to the buffer. ">producer_access()</a>.  <a href="structAIObjectQueue_1_1ProducerAccess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a145bcdb6ff113b3329f1c3f24c8d9ec0"><td class="memItemLeft" align="right" valign="top"><a id="a145bcdb6ff113b3329f1c3f24c8d9ec0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIObjectQueue.html#a145bcdb6ff113b3329f1c3f24c8d9ec0">AIObjectQueue</a> ()</td></tr>
<tr class="memdesc:a145bcdb6ff113b3329f1c3f24c8d9ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a buffer with size zero. <br /></td></tr>
<tr class="separator:a145bcdb6ff113b3329f1c3f24c8d9ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb829ae223c17540ea369035d562420e"><td class="memItemLeft" align="right" valign="top"><a id="afb829ae223c17540ea369035d562420e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIObjectQueue.html#afb829ae223c17540ea369035d562420e">AIObjectQueue</a> (int <a class="el" href="classAIObjectQueue.html#aea2846d63f6fa9d2f306397410add357">capacity</a>)</td></tr>
<tr class="memdesc:afb829ae223c17540ea369035d562420e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a buffer with a capacity of <em>capacity</em> objects of type <code>T</code>. <br /></td></tr>
<tr class="separator:afb829ae223c17540ea369035d562420e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499c37df4a1ba7c2e20c5bbd20c76758"><td class="memItemLeft" align="right" valign="top"><a id="a499c37df4a1ba7c2e20c5bbd20c76758"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIObjectQueue.html#a499c37df4a1ba7c2e20c5bbd20c76758">AIObjectQueue</a> (<a class="el" href="classAIObjectQueue.html">AIObjectQueue</a> &amp;&amp;rvalue)</td></tr>
<tr class="memdesc:a499c37df4a1ba7c2e20c5bbd20c76758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Only use this directly after constructing (if at all). <br /></td></tr>
<tr class="separator:a499c37df4a1ba7c2e20c5bbd20c76758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8368faf869122b25971646003427a7a0"><td class="memItemLeft" align="right" valign="top"><a id="a8368faf869122b25971646003427a7a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIObjectQueue.html#a8368faf869122b25971646003427a7a0">~AIObjectQueue</a> ()</td></tr>
<tr class="memdesc:a8368faf869122b25971646003427a7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor &ndash; frees allocated memory. <br /></td></tr>
<tr class="separator:a8368faf869122b25971646003427a7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2846d63f6fa9d2f306397410add357"><td class="memItemLeft" align="right" valign="top"><a id="aea2846d63f6fa9d2f306397410add357"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIObjectQueue.html#aea2846d63f6fa9d2f306397410add357">capacity</a> () const</td></tr>
<tr class="memdesc:aea2846d63f6fa9d2f306397410add357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current capacity of the buffer. <br /></td></tr>
<tr class="separator:aea2846d63f6fa9d2f306397410add357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d45c06e1d9653cab5f26b9ccdb8d13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIObjectQueue.html#a83d45c06e1d9653cab5f26b9ccdb8d13">reallocate</a> (int <a class="el" href="classAIObjectQueue.html#aea2846d63f6fa9d2f306397410add357">capacity</a>)</td></tr>
<tr class="memdesc:a83d45c06e1d9653cab5f26b9ccdb8d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the capacity of the buffer.  <a href="#a83d45c06e1d9653cab5f26b9ccdb8d13">More...</a><br /></td></tr>
<tr class="separator:a83d45c06e1d9653cab5f26b9ccdb8d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cdab4a806e019d824bd43f099c1375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAIObjectQueue_1_1ProducerAccess.html">ProducerAccess</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIObjectQueue.html#a69cdab4a806e019d824bd43f099c1375">producer_access</a> () const</td></tr>
<tr class="memdesc:a69cdab4a806e019d824bd43f099c1375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain exclusive producer access to the buffer.  <a href="#a69cdab4a806e019d824bd43f099c1375">More...</a><br /></td></tr>
<tr class="separator:a69cdab4a806e019d824bd43f099c1375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6908f63adcc53ccaed42db70ffd3249d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAIObjectQueue_1_1ConsumerAccess.html">ConsumerAccess</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIObjectQueue.html#a6908f63adcc53ccaed42db70ffd3249d">consumer_access</a> () const</td></tr>
<tr class="memdesc:a6908f63adcc53ccaed42db70ffd3249d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain exclusive consumer access to the buffer.  <a href="#a6908f63adcc53ccaed42db70ffd3249d">More...</a><br /></td></tr>
<tr class="separator:a6908f63adcc53ccaed42db70ffd3249d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7f8469d3e09f5351ad2f02b0211f5d05"><td class="memItemLeft" align="right" valign="top"><a id="a7f8469d3e09f5351ad2f02b0211f5d05"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIObjectQueue.html#a7f8469d3e09f5351ad2f02b0211f5d05">alignment</a> = (alignof(T) &lt; 64) ? (size_t)64 : alignof(T)</td></tr>
<tr class="memdesc:a7f8469d3e09f5351ad2f02b0211f5d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer storage alignment. Align the buffer at a multiple of the L1 cache line size. <br /></td></tr>
<tr class="separator:a7f8469d3e09f5351ad2f02b0211f5d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6908f63adcc53ccaed42db70ffd3249d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6908f63adcc53ccaed42db70ffd3249d">&#9670;&nbsp;</a></span>consumer_access()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAIObjectQueue_1_1ConsumerAccess.html">ConsumerAccess</a> <a class="el" href="classAIObjectQueue.html">AIObjectQueue</a>&lt; T &gt;::consumer_access </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain exclusive consumer access to the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structAIObjectQueue_1_1ConsumerAccess.html" title="The return type of consumer_access(). ">ConsumerAccess</a> object. </dd></dl>

</div>
</div>
<a id="a69cdab4a806e019d824bd43f099c1375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69cdab4a806e019d824bd43f099c1375">&#9670;&nbsp;</a></span>producer_access()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAIObjectQueue_1_1ProducerAccess.html">ProducerAccess</a> <a class="el" href="classAIObjectQueue.html">AIObjectQueue</a>&lt; T &gt;::producer_access </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain exclusive producer access to the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structAIObjectQueue_1_1ProducerAccess.html" title="The return type of producer_access(). ">ProducerAccess</a> object. </dd></dl>

</div>
</div>
<a id="a83d45c06e1d9653cab5f26b9ccdb8d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d45c06e1d9653cab5f26b9ccdb8d13">&#9670;&nbsp;</a></span>reallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAIObjectQueue.html">AIObjectQueue</a>&lt; T &gt;::reallocate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the capacity of the buffer. </p>
<p>This function will deadlock when used by a thread that still has the return type of a call to <code><a class="el" href="classAIObjectQueue.html#a69cdab4a806e019d824bd43f099c1375" title="Obtain exclusive producer access to the buffer. ">producer_access()</a></code> or <code><a class="el" href="classAIObjectQueue.html#a6908f63adcc53ccaed42db70ffd3249d" title="Obtain exclusive consumer access to the buffer. ">consumer_access()</a></code> around.</p>
<p>This blocks all producers and consumers from using the buffer while (re)allocating memory and moving memory content. It is currently also destructive to all objects still in the buffer. Hence this function really only should be used while it is empty and not in use at all.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The new queue capacity in number of objects of type <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>statefultask/<a class="el" href="AIObjectQueue_8h_source.html">AIObjectQueue.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer" style="text-align:left;">
<span style="margin-left: 10px; font-size: 90%;">Copyright &copy; 2018 Carlo Wood.&nbsp; All rights reserved.</span>
<span style="float:right;">
<small>Generated by&#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></span>
</address>
</body>
</html>
