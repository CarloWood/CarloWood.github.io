<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="Author" content="Carlo Wood">
<meta name="description" content="ai-statefultask">
<title>ai-statefultask version 2cfbfa5 documentation</title>
<link rel="shortcut icon" href="images/favicon.ico">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="main.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top">
<div id="titlearea">
<table>
 <tbody>
  <tr>
  <td style="width: 128px"><img src="images/aistatefultask_arc.png"></td>
  <td>
    <p id="html_header1"><span id="name">AIStatefulTask</span> &dash; Asynchronous, Stateful Task Scheduler library.</p>
    <p id="html_header2">Threads-like task objects evolving through user-defined states.</p>
  </td>
  </tr>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 

<div id="mainpage">
<p><span class="projectname">AIStatefulTask</span> is an
<a href="https://github.com/CarloWood/ai-statefultask">open source project</a>
written by <a href="http://carlowood.github.io/">Carlo Wood</a> and is
the accumulation of more than a decade of design effort, testing and improvements.
<span class="projectname">AIStatefulTask</span> allows you
to write event based applications of arbitrary complexity.</p>

<p>The features of the library include:</p>

<ul class="features">
  <li class="title">High performance.</li>
    <ul>
      <li>A great amount of effort was put into assuring the fastest possible algorithms and code.
      The whole design of the library has been with one goal in mind: to have every core in
      the machine run a thread that never blocks; does as little system calls as possible,
      certainly none that might put the thread to sleep.</li>
      <li>Where possible a lock-free approach has been chosen using weakly ordered atomics,
      while critical areas &mdash; when unavoidable &mdash; are the least number of clock
      cycles long in order to reduce concurrent locking of mutexes to a negligible amount.</li>
      <li>To give one example: it is possible to have millions of timers running without
      a significant overhead. The required algorithm to achieve this dictates that one has
      to make a sacrifice: it is only possible to start (such high performance) timers with a
      timeout interval that is known at compile time. A more na√Øve design would rather
      have approached the problem from the starting point that one should be able to start
      timers with arbitrary (run time) intervals with as unavoidable result that using
      too many timers results in significant overhead.</li>
      <li>Another example is the extremely efficient I/O. This library is the only library
      in the world that allows reading and writing the same socket concurrently. Input is
      buffered but without the need to copy the data: data is read from a socket into memory
      and in most cases never moved, but processed in-place.</li>
      <li>In order to minimize the number of context switches, a thread only goes to sleep
      when there is nothing else to do (the lock-free ring buffers of the thread pool are
      empty). Nevertheless, in order to avoid unnecessary system calls to wake up sleeping
      threads, a special <code>SpinSemaphore</code> has been designed (again, based on weakly ordered
      atomics) that utilizes the linux-specific futex system call directly in order to
      gain some cpu cycles by being able to wake up more than one thread at a time (the default
      POSIX semaphore only allows waking up a single thread at a time, because not all
      operating systems support waking up more). A (specifically tuned) test application
      became 20 times faster using our custom semaphore as opposed to using the libc provided
      one.</li>
      <li>And the list goes on. If anything, then this is a Maximum High Performance library.</li>
    </ul>
  <li class="title">Scalable to many cores.</li>
    <ul>
      <li>Doing I/O requires one thread to sleep in <code>epoll</code>. For the timers we
      use the (hardware) per-process POSIX timer (see timer_create(2)). There is no distinction
      between other threads; the user can have dedicated threads of course, and have it
      donate cycles to the tasks running in this library by calling a function (e.g. from
      its 'idle' point in the main loop), but the library works perfectly well by dividing
      the work over threads from its thread pool. The idea is to have as many threads as
      one has cores, so that there is no need for context switching by the kernel within
      the application (aka, on an otherwise unloaded machine). A thread that mostly sleeps,
      like the dedicated I/O thread that basically does nothing but wait for I/O events
      in epoll, does not need to be counted here of course (not using a core makes the
      application slower than having a context switch upon I/O events).</li>
      <li>As the work of an application can be divided over many little tasks, those will
      be executed in parallel whenever possible and when (more) cores are available.</li>
    </ul>
  <li class="title">Highly robust.</li>
    <ul>
      <li>Every demand that the library puts on its usage is enforced. Preferably at compile
      time; but when that is not possible (or would introduce less efficient code), usage
      errors are caught with asserts that are accompanied with detailed comments explaining
      what one did wrong when that assert failed and how to fix it. Once a program is
      finished and is using the library correctly then those asserts can of course be
      removed by compiling for the production environment as opposed to debug mode.</li>
      <li>In fact, because of this, a reasonable approach would be to just "try something"
      and/or make random changes to working code; after fixing all compile errors and
      testing the application well enough to make sure there are no asserts, it is guaranteed
      that it works again. I am guilty of using this approach myself many times, so that
      this feature is in fact a tested feature.</li>
      <li>For example:
      <pre>
// The lifetime of at least one FileLock object, of the corresponding
// canonical path, must be longer than the lifetime of FileLockAccess
// objects created from it. I.e. you deleted the FileLock object
// corresponding to this FileLockAccess. Don't do that.
ASSERT(!m_debug_weak_ptr.expired());</pre>
      </li>
    </ul>
  <li class="title">Builtin debugging support.</li>
    <ul>
      <li>Debugging complex, multi-threaded programs can be quite a challenge.
      Stepping through the code with a debugger is often not going to cut it.
      The only reasonable way to debug such a program is with highly detailed
      debug output that prints everything that goes on. This library been written
      with that in mind from the beginning.
      Based on <a href="https://github.com/CarloWood/libcwd">libcwd</a>, debug
      output is written to so called <i>debug channels</i> allowing to follow
      exactly what happened just prior to the problem that you want to investigate.
      The debug code can be omitted entirely from production code of course,
      but even in debug mode doesn't cause a very significant overhead apart
      from the actual output (especially to screen). However, one can&mdash;
      for example&mdash; turn all debug output off except for one (or more)
      specific Tasks.</li>
    </ul>
  <li class="title">Thread-safe by design.</li>
    <ul>
      <li>AIStatefulTask helps in many ways with writing a (heavy) multi-threaded
      program without running into all the normal problems: each Task is an object
      with its own (private) members that it is manipulating. A task basically
      exists of a single virtual function (<code>multiplex_impl</code>). Only
      one thread at a time will execute that function, so it is basically
      single-threaded; no mutex locking is necessary for any of the private
      variable. Synchronization with other threads (tasks) is provided by
      the library in a fail-safe way.</li>
      <li>When a task is run from an <code>AIEngine</code> then it is executed
      from a known point in the main loop of, for example, some other library.
      That means that the task runs at the moment that that library doesn't
      run so again there is no need for complex mutex locking. This is the
      prefered way run tasks that have to interact with non-thread-safe third
      party libraries.</li>
    </ul>
  <li class="title">Error handling and reporting via C++ exceptions.</li>
    <ul>
      <li>C++ exceptions are the preferred error reporting mechanism for most applications.
      The exception thrown includes the detailed error code information important for
      diagnosing the exact cause of errors. In most cases such errors are fatal for
      whatever task initiated it. For example, the user tries to write a file
      to a non-existing directory. Then the rest of the program can continue running,
      the only thing needed is to cancel this user-action. Hence, an error is closely
      related (if not the same) as a pop-up telling the user of a problem.
      The library makes use of <code>AIAlert</code> error reporting, which has
      been written with exactly that in mind and are ready for translation into
      other languages.</li>
    </ul>
</ul>

<h3>The Problem</h3>

<p><b>Applications</b> often need to do something along the lines of</p>

<div class="todothis">&quot;do <span>this</span>, and when you're done [...]&quot;</div>

<p>If that task simply requires lots of CPU cycles then one can pass the task to a thread
and let that crunch away until the task is done. If the task is something basic, like reading a socket,
then you might be able to find a library that supports performing that particular task in an asynchronous
manner. In both cases you probably need some kind of event mechanism to be notified when the task has finished.</p>

<p><b>In reality</b> life isn't that simple.
Often a task will use some&dash; or possibly a significant amount of&dash;
CPU cycles alternated by the need to idle (i.e. waiting for network and/or disk access).
It might even never finish; requiring a timeout and/or error handling, etc.
There certainly won't be an existing library that does this work asynchronously for you and unless
you can spare a core to do the task synchronously passing the task to another thread won't
help you one single bit.</p>

<p><b>If your application is complex</b>, tasks will need to perform an arbitrary number of
other tasks, which in turn need to do tasks before they can finish, so that it is both,
completely unpredictable what kind of resources and timing a single task needs,
as well as not feasible to use a thread-per-task because there are simply too many tasks.</p>

<p>Moreover, each task needs a callback mechanism; if such callbacks are performed
by the thread that happens to finish a task (remember, you can't allocate one particular
thread for a task) then it is not possible to predict which thread, or in what state
it is; as a result you can't do much more than set a flag in the callback and still
need <em>something</em> to pick up on the fact that the task was finished.</p>

<p><b>Heavily asynchronous code</b> has the tendency to exist of a large collection
of callback functions where one quickly loses overview of which function(s) will be
called when and in what order. Object orientation is lost because of this and thread-safety
can only be guaranteed by locking each and every variable every time they are accessed,
which either leads to unpredictable deadlocks or thread-unsafe accesses when attempting
to avoid 'unneeded' mutex locking.<p>

<h3>The Objective Of <span class="projectname">AIStatefulTask</span></h3>

<p><b>The design goal</b> of <span class="projectname">AIStatefulTask</span> was to create
a framework that allows one to dispatch tasks to a thread pool without losing
thread-safety or object orientation and without wasting CPU cycles or losing
the ability to fully utilize the power of every available core.</p>

<p><b>A primary goal</b> has also been to allow a developer to achieve all that by
only concentrating on a single object at a time; having a clear one-on-one
relationship between a Task and an object.</p>

<p>Despite the complexity of thread dispatching, asynchronous execution and
error handling, the code of such a task should give (mostly) a linear feel
along the way of, <div class="todothis">&quot;To do this task,
<li>do this, and when done,
<li>do this, and when done,
<li>do this, and when done,
<li>then this task is finished.
<li>Do this if an error occurs.&quot;</div></p>

<h4>Thread-safety And Object Orientation</h4>

<p>Each Task in <span class="projectname">AIStatefulTask</span></h3>
is derived from
 class <a class="el" href="classAIStatefulTask.html" title="Base class for task objects. ">AIStatefulTask</a>, overriding up to six virtual functions.</p>
<p>These virtual functions allow the developer to perform initialization, execute code in the case something unexpected happens or when the task finishes, and of course define what the task is supposed to accomplish by overriding the pure virtual <code><a class="el" href="classAIStatefulTask.html#a57233a1b95a6fdbef04c4cab3fd890ae" title="Called for base state bs_multiplex. ">AIStatefulTask::multiplex_impl</a></code> member function of the base class.</p>
<p>The linear feel of a task is accomplished by having all code that comprises the majority of the work done by the task in a single <code>switch</code> statement, in the overridden <code>multiplex_impl</code> member function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyTask::multiplex_impl(state_type run_state)</div><div class="line">{</div><div class="line">  <span class="keywordflow">switch</span>(run_state)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">case</span> MyTask_start:</div><div class="line">      <span class="comment">/* Do this, and when done continue with MyTask_next_step. */</span></div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> MyTask_next_step:</div><div class="line">      <span class="comment">/* Do this, and when done continue with MyTask_last_step. */</span></div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> MyTask_last_step:</div><div class="line">      <span class="comment">/* Do this, and when done continue with MyTask_done. */</span></div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> MyTask_done:</div><div class="line">      <span class="comment">/* This task is finished. */</span></div><div class="line">      finish();</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> MyTask::abort_impl()</div><div class="line">{</div><div class="line">  <span class="comment">/* Do this if an error occurs. */</span></div><div class="line">}</div></div><!-- fragment --><p>The <em>states</em> are user defined. This construct allows for a sequential feel&mdash; while the thread, at any point, still can return to its main loop and later reenter the code where it left of. Note that it doesn't <em>have</em> to be linear, but in general the state of a Task will more or less advance in one direction; in the above example from <code>MyTask_start</code> to <code>MyTask_next_step</code> to <code>MyTask_last_step</code> and finally to <code>MyTask_done</code>. So if the case statements are put in that order then this gives an intuitive feel of how the task will progress (from top to bottom).</p>
<p>A Task <em>object</em> is only executed by a single thread at a time. Although theoretically that can be a different thread each time <code>multiplex_impl</code> is reentered the effect is still single threaded; as long as the variables that the Task is accessing aren't also accessed outside of a Task then no locking is necessary. Most notably, (non-static) private member variables of the Task do not need a mutex to protect them when a Task works in isolation (that is, no other threads call its member functions while it is working), which is the normal mode of operation for a Task as its internal state is basically unknown until the task has finished: a task should be left alone doing its thing while it is doing its thing.</p>
<p>Moreover, a Task is executed from a well-defined point in each threads main loop. This allows to access variables of thread-unsafe third party code by running the Task in the same thread as that third-party code. Note that it <em>is</em> possible to tell a Task in which thread to run.</p>
<p> 
See <a href="#usage">Usage</a> for more detailed information.

<h2 id="compiling">Compiling</h2>

<p><span class="projectname">AIStatefulTask</span> is a <tt>git submodule</tt>.
It can just be checked out in its own subdirectory and be compiled as part
of a larger project. The submodule <em>does</em> contain a <tt>Makefile.am</tt>
file to facilitate building a libtool archive using the
<a href="https://www.gnu.org/software/automake/manual/html_node/index.html"><tt>GNU</tt>&nbsp;<tt>autotools</tt></a>.</p>

<p>However, <b>the recommended way</b> to use this submodule is by using <a href="https://github.com/CarloWood/cwm4">cwm4</a>.
Please read <a href="https://github.com/CarloWood/ai-statefultask#adding-the-ai-statefultask-submodule-to-a-project">README.md</a>
for a detailed description of how to include <span class="projectname">AIStatefulTask</span> in your cwm4 based project.</p>

<h2 id="usage">Usage</h2>
<h3>Prerequisites</h3>

<p>Once the build system has been set up correctly (see <a href="#compiling">Compiling</a> above)
there are still a few things to be taken care of at the C++ level; lets write a quick
'Hello World'.</p>

<p>In fact, most prerequisites are due to <a href="http://libcwd.sourceforge.net/index.html"><b>libcwd</b></a>:
<ul>
<li>Each source file must start with <code>#include &quot;sys.h&quot;</code>.
By default this will use the one provided by <a href="https://github.com/CarloWood/cwds#readme">cwds</a>
or you can override that by providing your own sys.h in the root of the project.
<li>Each source or header file that uses debugging, so that certainly includes
the <tt>main.cpp</tt>, needs to <code>#include &quot;debug.h&quot;</code> somewhere.
<li>At the beginning of <code>main</code> you need to add the line:
</ul>
 </p><div class="fragment"><div class="line">Debug(NAMESPACE_DEBUG::init());</div></div><!-- fragment --><p> This calls a function provided by <code>cwds</code> that reads your <code>~/.libcwdrc</code> file turning on debug output for the specified debug channels.</p>
<p> 
To enable debug output of <span class="projectname">AIStatefulTask</span> you should turn on
the debug channel <code>statefultask</code>. This can be done by adding it to your <tt>.libcwdrc</tt>
file or by adding the following line below the previous one:
 </p><div class="fragment"><div class="line">Debug(<span class="keywordflow">if</span> (!dc::statefultask.is_on()) dc::statefultask.on());</div></div><!-- fragment --> <p><a class="anchor" id="helloworld_example"></a> 
<p>Then at least one of two things are needed for <span class="projectname">AIStatefulTask</span>:
<ul>
<li>Create one or more AIEngine objects and use those as default handler for your tasks;
and have a main loop calling <code>mainloop();</code> on each of those engines on a regular basis;
for example as part of the 'idle' cycle of the main loop of <a href="https://www.gtkmm.org/en/documentation.html">gtkmm/glibmm</a>.
<li>Create an AIThreadPool object and create one or more AIThreadPool::PriorityQueue objects, refered to by AIQueueHandle`s,
and use those as default handler for your tasks.
</ul>
</p>

<p>See the <a href="https://github.com/CarloWood/ai-statefultask-testsuite/blob/master/src/helloworld.cxx"><tt>helloworld.cxx</tt></a>
file of the ai-statefultask-testsuite project for a working &quot;Hello World&quot; example.
As another example have a look at the <a href="https://github.com/CarloWood/ai-statefultask-testsuite/blob/master/src/fibonacci.cxx"><tt>fibonacci.cxx</tt></a>
file in the same project.</p>

<p>If you are new to <span class="projectname">AIStatefulTask</span> then I urge
you to first clone <a href="https://github.com/CarloWood/ai-statefultask-testsuite">ai-statefultask-testsuite</a> and get that working;
as that will require you to have all the bits and pieces for building a project
that uses <span class="projectname">AIStatefulTask</span> installed (hint: start
with getting, compiling and installing <a href="https://github.com/CarloWood/libcwd">libcwd</a>
and configure that for example with <tt>--enable-maintainer-mode&nbsp;--enable-optimize&nbsp;--disable-alloc&nbsp;--disable-location&nbsp;--disable-nonthreading</tt>
because, respectivily, you got it with git, but you're not debugging libcwd itself, you don't need memory allocation
debugging (slow), or printing source_file:line_number locations, and we only need the multithreaded version).

<h3>A tasks life cycle: creation, initialization, running and destruction</h3>

<p>Because Task objects are called by (possibly) multiple threads, although one at a time,
that are constantly going into functions and leaving them again at the very least all
the way back to the their main loop; it makes no sense to even want to create a Task object on
the stack: the life-time of a Task object is <em>unrelated</em> to any scope.</p>

<p><b>The correct way to create task objects</b> therefore is by allocating them with <code>new</code>
on the heap. There are two ways to do this:</p>
</p>
<ol>
<li>
<p class="startli">The quick and dirty way, where you just want to run a task a single time. The task will delete itself when finished. </p><div class="fragment"><div class="line"><span class="comment">// Here &#39;task&#39; is usually just some automatic variable.</span></div><div class="line">MyTask* task = <span class="keyword">new</span> MyTask(my_args);</div><div class="line">task-&gt;my_initialization(my_params); <span class="comment">// Assuming MyTask needs this.</span></div><div class="line">task-&gt;run(handler, callback_args);  <span class="comment">// This will cause &#39;task&#39; to</span></div><div class="line">                                    <span class="comment">// be deleted when finished.</span></div><div class="line"><span class="comment">// Do not use &#39;task&#39; anymore here.</span></div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
If you want to control the life-time of the Task. <div class="fragment"><div class="line"><span class="comment">// In general &#39;m_task&#39; will be a member variable of an object.</span></div><div class="line">boost::intrusive_ptr&lt;MyTask&gt; m_task = <span class="keyword">new</span> MyTask(my_args);</div><div class="line"></div><div class="line"><span class="comment">// Then, every time you want to run it:</span></div><div class="line">m_task-&gt;my_initialization(my_params);</div><div class="line">m_task-&gt;run(handler, callback_args);</div><div class="line"><span class="comment">// The task object will be kept around until both,</span></div><div class="line"><span class="comment">// &#39;m_task&#39; is destructed and the task did finish.</span></div></div><!-- fragment --> </li>
</ol>
<p>In both cases <code>handler</code> is either an <code>AIEngine*</code> or a AIQueueHandle.</p>
<p>Note that this allows the task to be re-used: it can simply be re-initialized and run again after it finished; there is no need to allocate memory on the heap and construct a Task object every time you want to run it! Of course a task must be finished first before you can restart it.</p>
<p>In the above code snippets, <code>my_args</code> and <code>my_params</code> are entirely user defined; respectively the parameters of the constructor of <code>MyTask</code> and the initialization parameters to some user defined function <code>MyTask::my_initialization</code>.</p>
<p><code>callback_args</code> are the arguments of one of the <a class="el" href="group__group__run.html">AIStatefulTask::run</a> member functions. See the documentation of that member function for a description of those arguments.</p>
<p>Any thread may create a stateful task object, initialize it by calling its initializing member function and call one of the <a class="el" href="group__group__run.html">AIStatefulTask::run</a> methods, which might or might not immediately start to execute the task.</p>
<p>The call to <code>run</code> causes a call to <a class="el" href="classExample.html#a22ac76bde007a560c6428ac0f997a4ee">initialize_impl</a>, which must call <a class="el" href="group__group__protected.html#ga160831e7b091af4095a9f60e33834328">set_state</a> at least once (only the last call is used). Upon return from <code>initialize_impl</code>, <a class="el" href="classExample.html#a5e23b83406c365bed7cbeeb196071726">multiplex_impl</a> will be called with that state.</p>
<p><code>multiplex_impl</code> may never reentrant (cause itself to be called) and should end by callling either one of <a class="el" href="group__group__wait.html#gaf6b0f3ba324cd8ca6b4a2f925c106897">wait</a>, <a class="el" href="group__group__yield.html#ga00981f1360b10d5f99f805d501a537a2">yield</a>, <a class="el" href="group__group__protected.html#gaf7642911a8012284ec7aa5a9a700b06b">finish</a> [or <a class="el" href="group__group__public.html#gac520d813fed06cba4eef1913c3daca3f">abort</a>].</p>
<p>Leaving <code>multiplex_impl</code> without calling any of those might result in an immediate reentry, which could cause the task to enter an infinite loop without reaching the main loop again, unless the state is changed with <a class="el" href="group__group__protected.html#ga160831e7b091af4095a9f60e33834328">set_state</a>.</p>
<p>If <code>multiplex_impl</code> calls <a class="el" href="group__group__wait.html#gaf6b0f3ba324cd8ca6b4a2f925c106897">wait(condition)</a>, and there was only one call to <a class="el" href="group__group__public.html#ga8b7111d021ba8507748df416a0631e5d">signal(condition)</a> since the last call to <code>wait(condition)</code>, then <code>multiplex_impl</code> will not be called again until <code>signal(condition)</code> is called from outside.</p>
<p>If <code>multiplex_impl</code> calls <code>finish</code> then <a class="el" href="classExample.html#a418945b72b830cbc95f3d2cb10f62e83">finish_impl</a> will be called [if instead it calls <code>abort</code> then first <a class="el" href="classExample.html#ada8595c90689acf0b8c89ce7a4786b5a">abort_impl</a> will be called, followed by a call to <code>finish_impl</code>]. Upon return from <code>multiplex_impl</code>, and if <code>finish</code> [or <code>abort</code>] was called, the call back passed to <code>run</code> will be called.</p>
<p>If the call back function does <em>not</em> call <code>run</code>, or when <a class="el" href="group__group__public.html#ga0593a004b92de37cbcfae9f3cfcccaec">kill</a> is called <em>after</em> <code>run</code> was called, then the task is deleted upon return from the call back, provided the user didn't keep a <code>boost::intrusive_ptr&lt;&gt;</code> reference around.</p>
<h3>Writing a task</h3>
<p>A typical Task will look like,</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="AIStatefulTask_8h.html">statefultask/AIStatefulTask.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classAIStatefulTask.html">AIStatefulTask</a></div><div class="line">{</div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">typedef</span> <a class="code" href="classAIStatefulTask.html">AIStatefulTask</a> direct_base_type;      <span class="comment">// The immediate base class of this task.</span></div><div class="line"></div><div class="line">  <span class="comment">// The different states of the task.</span></div><div class="line">  <span class="keyword">enum</span> my_task_state_type {</div><div class="line">    MyTask_start = direct_base_type::max_state, <span class="comment">// The first state.</span></div><div class="line">    ...a list of all states...</div><div class="line">    MyTask_done                                 <span class="comment">// The last state.</span></div><div class="line">  };</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">static</span> state_type constexpr max_state = MyTask_done + 1;  <span class="comment">// The last state plus one.</span></div><div class="line"></div><div class="line"> ...</div><div class="line"></div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  ~MyTask() <span class="keyword">override</span>;</div><div class="line">  <span class="keywordtype">char</span> <span class="keyword">const</span>* <a class="code" href="classAIStatefulTask.html#abf2da57033c2f1d05a7f6b59fe392d67">state_str_impl</a>(state_type run_state) <span class="keyword">const override</span>;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classAIStatefulTask.html#a57233a1b95a6fdbef04c4cab3fd890ae">multiplex_impl</a>(state_type run_state) <span class="keyword">override</span>;</div><div class="line">  <span class="comment">// Optional:</span></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classAIStatefulTask.html#afe86c9acff86165977302965e5401e20">initialize_impl</a>() <span class="keyword">override</span>;  <span class="comment">// Default starts with first state.</span></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classAIStatefulTask.html#a61a6f86a6e413cf7391b756b0038d4f0">abort_impl</a>() <span class="keyword">override</span>;       <span class="comment">// Default does nothing.</span></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classAIStatefulTask.html#a872025f08ce55e54810495690da7b337">finish_impl</a>() <span class="keyword">override</span>;      <span class="comment">// Default does nothing.</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">char</span> <span class="keyword">const</span>* MyTask::state_str_impl(state_type run_state)</div><div class="line">{</div><div class="line">  <span class="keywordflow">switch</span> (run_state)</div><div class="line">  {</div><div class="line">    <span class="comment">// A complete listing of my_task_state_type.</span></div><div class="line">    AI_CASE_RETURN(MyTask_start);</div><div class="line">    ...a list of all states...</div><div class="line">    AI_CASE_RETURN(MyTask_done);</div><div class="line">  }</div><div class="line">  ASSERT(<span class="keyword">false</span>);</div><div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;UNKNOWN STATE&quot;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> MyTask::multiplex_impl(state_type run_state)</div><div class="line">{</div><div class="line">  <span class="keywordflow">switch</span> (run_state)</div><div class="line">  {</div><div class="line">    <span class="comment">// A complete listing of my_task_state_type.</span></div><div class="line">    <span class="keywordflow">case</span> MyTask_start:</div><div class="line">      <span class="comment">// Handle state.</span></div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    ...a list of all states...</div><div class="line">    <span class="keywordflow">case</span> MyTask_done:</div><div class="line">      <a class="code" href="group__group__protected.html#gaf7642911a8012284ec7aa5a9a700b06b">finish</a>();</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>Then in <code>multiplex_impl</code> each state need to be implemented. Here are a few examples.</p>
<p><b>Changing state</b></p>
<p>It is simply the last call to <code>set_state</code> that is used to determine what state to run the next invocation of <code>multiplex_impl</code>. Also, as might be intuitively correct, it is not really necessary to return from <code>multiple_impl</code> to change state; you are allowed to simply fall-through to the next state.</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> MyTask_state10:</div><div class="line">  set_state(MyTask_state11);      <span class="comment">// By default run state11 next.</span></div><div class="line">  <span class="keywordflow">if</span> (something)</div><div class="line">  {</div><div class="line">    set_state(MyTask_state12);    <span class="comment">// Continue with state12.</span></div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (foobar)</div><div class="line">  {</div><div class="line">    <span class="comment">// Optional code here.</span></div><div class="line">    <span class="keywordflow">break</span>;                        <span class="comment">// Continue with state11.</span></div><div class="line">  }</div><div class="line">  <span class="comment">// Optional code here.</span></div><div class="line">  <span class="comment">/*fall-through*/</span>                <span class="comment">// Continue with state11 without even</span></div><div class="line">                                  <span class="comment">// returning from multiplex_impl.</span></div><div class="line"><span class="keywordflow">case</span> MyTask_state11:</div><div class="line">  <span class="keywordflow">if</span> (run_state == MyTask_state10)    <span class="comment">// Apparently we did fall-through.</span></div><div class="line">    ...</div></div><!-- fragment --><p><b>Yielding</b></p>
<p>If in the above code you'd have used a <code>break</code> instead of falling through, then the program would have almost acted in the same way: upon return from <code>multiplex_impl</code> the engine sees that the task is still running and will therefore immediately reenter <code>multiplex_impl</code>.</p>
<p>In other words, doing a <code>break</code> is <em>not</em> the same as a <code>yield</code>.</p>
<p>Even if a task runs in an engine with a max_duration, and it would go over that time limit then doing a <code>break</code> still doesn't do anything but immediately reentering <code>multiplex_impl</code> to continue with the next state. The test that looks if the engine did run for too long only is done once we actually return to the <code>mainloop()</code> of the engine which only happens when either <code>wait</code> or <code>yield</code> is called.</p>
<p>Hence, if you want this time check to take place, or if you simply want other tasks in the same engine to get a chance to run too while this task is working, call <a class="el" href="group__group__yield.html">yield*()</a>. For example,</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> MyTask_state10:</div><div class="line">  set_state(MyTask_state11);      <span class="comment">// By default run state11 next.</span></div><div class="line">  <span class="keywordflow">if</span> (something)</div><div class="line">  {</div><div class="line">    set_state(MyTask_state12);    <span class="comment">// Continue with state12.</span></div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (foobar)</div><div class="line">    do_computation_A();</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    do_computation_B();</div><div class="line">  yield();                      <span class="comment">// Make sure other tasks and/or the</span></div><div class="line">                                <span class="comment">// mainloop get CPU time too.</span></div><div class="line">  <span class="keywordflow">break</span>;                        <span class="comment">// Continue with state11.</span></div></div><!-- fragment --><p><a class="anchor" id="waiting"></a><b>Waiting</b></p>
<p>Finally there are a couple of typical ways to go idle while waiting for some event to happen. Under the hood all of those use the same mechanism: you call <code>wait(condition)</code> and the task goes idle until something else calls <code>task.signal(condition)</code>.</p>
<p>Here <code>condition</code> is simply a <code>uint32_t</code> bit mask. Normally you will just use <code>1</code>. In order not to wake up when some old <code>signal</code> happens for a condition that you are no longer waiting for, each task has up to 32 different possible values. If you were waiting for mask <code>1</code> and it didn't come or might still be coming (again) but now you want to wait for something else, then simply wait for condition <code>2</code>, <code>4</code> or <code>8</code> etc so that you will automatically ignore an (old and lagging behind) signal on <code>1</code>. It is possible to wait and/or signal multiple conditions at the same time however: a call to <code>wait(condition1)</code> is woken up by a call to <code>signal(condition2)</code> when <code>condition1 &amp; condition2</code> is non-zero.</p>
<p>For example,</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> some_event()</div><div class="line">{</div><div class="line">  task.signal(1);</div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line">  <span class="keywordflow">case</span> MyTask_state20:</div><div class="line">    set_state(MyTask_state21);  <span class="comment">// Continue with state21.</span></div><div class="line">    wait(1);                    <span class="comment">// Go idle until some_event() is called.</span></div><div class="line">    <span class="keywordflow">break</span>;</div></div><!-- fragment --><p>Often you want to wait for a real condition however, for example <code>x &gt; y</code>, and it is not really possible to call <code>signal</code> when that happens and then still be sure that this condition is still true once the task starts running again.</p>
<p>In general, you will only have events that when they happen make it possible, preferably likely that the condition that you are waiting for is true.</p>
<p>Code that needs this will typically look like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> some_event()</div><div class="line">{</div><div class="line">  ++x;  <span class="comment">// Now x might have become larger than y.</span></div><div class="line">  task.signal(1);</div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line">  <span class="keywordflow">case</span> MyTask_state20:</div><div class="line">    wait_until([&amp;](){ <span class="keywordflow">return</span> x &gt; y;}, 1, MyTask_state21);</div><div class="line">        <span class="comment">// Continue with state21 as soon as x &gt; y.</span></div><div class="line">    <span class="keywordflow">break</span>;</div></div><!-- fragment --><p>Simply running another task and waiting until it is finished:</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> MyTask_state30:</div><div class="line">  m_task = <span class="keyword">new</span> MyChildTask;</div><div class="line">  m_task-&gt;run(handler, <span class="keyword">this</span>, 2);  <span class="comment">// 2 is just the condition bit to be used.</span></div><div class="line">  set_state(MyTask_state31);      <span class="comment">// Continue with state31 once m_task has finished.</span></div><div class="line">  <span class="keywordflow">break</span>;</div></div><!-- fragment --><p>Running some computational extensive function in another thread (see <a class="el" href="classAIPackagedTask_3_01R_07Args_8_8_8_08_4.html">AIPackagedTask</a>):</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyTask : <a class="code" href="classAIStatefulTask.html">AIStatefulTask</a></div><div class="line">{</div><div class="line">  AIPackagedTask&lt;int(double, double)&gt; m_calculate;</div><div class="line">  <span class="keyword">static</span> condition_type constexpr calculate_condition = 4;</div><div class="line">      <span class="comment">// The condition bit to be used.</span></div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  MyTask(<span class="keywordtype">int</span> calculate_handle) :</div><div class="line">      m_calculate(this, calculate_condition, &amp;func, calculate_handle) { }</div><div class="line">        <span class="comment">// m_calculate will call func(double, double).</span></div><div class="line">...</div><div class="line">};</div><div class="line"></div><div class="line">...</div><div class="line">  <span class="keywordflow">case</span> MyTask_state20:</div><div class="line">    m_calculate(3.0, 4.1);              <span class="comment">// Copy parameters to m_calculate.</span></div><div class="line">    <a class="code" href="group__group__protected.html#ga160831e7b091af4095a9f60e33834328">set_state</a>(MyTask_dispatch);</div><div class="line">  <span class="keywordflow">case</span> MyTask_dispatch:</div><div class="line">    <span class="keywordflow">if</span> (!m_calculate.dispatch())        <span class="comment">// Put m_calculate in the queue.</span></div><div class="line">    {</div><div class="line">      yield_frames(1);                  <span class="comment">// Yield because the queue was full.</span></div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    <a class="code" href="group__group__protected.html#ga160831e7b091af4095a9f60e33834328">set_state</a>(MyTask_state21);          <span class="comment">// Continue with state21 once the</span></div><div class="line">    <span class="keywordflow">break</span>;                              <span class="comment">//   function finished executing.</span></div><div class="line">  <span class="keywordflow">case</span> MyTask_state21:</div><div class="line">  {</div><div class="line">    <span class="keywordtype">int</span> result = m_calculate.get();     <span class="comment">// Get the result.</span></div></div><!-- fragment --><p> 
</div> <!-- mainpage -->
 </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer" style="text-align:left;">
<span style="margin-left: 10px; font-size: 90%;">Copyright &copy; 2018, 2019 Carlo Wood.&nbsp; All rights reserved.</span>
<span style="float:right;">
<small>Generated by&#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></span>
</address>
</body>
</html>
