<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="Author" content="Carlo Wood">
<meta name="description" content="ai-statefultask">
<title>ai-statefultask version 2cfbfa5 documentation</title>
<link rel="shortcut icon" href="images/favicon.ico">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="main.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top">
<div id="titlearea">
<table>
 <tbody>
  <tr>
  <td style="width: 128px"><img src="images/aistatefultask_arc.png"></td>
  <td>
    <p id="html_header1"><span id="name">AIStatefulTask</span> &dash; Asynchronous, Stateful Task Scheduler library.</p>
    <p id="html_header2">Threads-like task objects evolving through user-defined states.</p>
  </td>
  </tr>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="usage.html">Usage</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">C++ Prerequisites </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h3>Library initialization.</h3>
<p>Once the build system has been set up correctly (see <a class="el" href="compiling.html">Compiling</a>) there are still a few things to be taken care of at the C++ level; lets write a quick 'Hello World'.</p>
<p>In fact, a lot of prerequisites are due to <a href="http://libcwd.sourceforge.net/index.html"><b>libcwd</b></a>: </p><ol class="prerequisites">
<li>
Each source file must start with <span class="inlinecode">#include "sys.h"</span>. By default this will use <a href="https://github.com/CarloWood/cwds/blob/master/sys.h">the one provided</a> by <a href="https://github.com/CarloWood/cwds#readme">cwds</a>, or you can override that by providing your own <span class="tt">sys.h</span> in the root of the project. </li>
<li>
Each source or header file that uses debugging, so that certainly includes  <span class="tt">main.cpp</span>, needs to <span class="inlinecode">#include&nbsp;"debug.h"</span> somewhere. However, <span class="tt">main.cpp</span> also needs to <span class="inlinecode">#include&nbsp;"evio/EventLoop.h"</span> (which includes <span class="tt">threadpool/AIThreadPool.h</span>), or at the very least <span class="tt">threadpool/AIThreadPool.h</span> if you don't use an <span class="inlinecode">EventLoop</span>, which already include(s) <span class="tt">debug.h</span>, so including just the former is sufficient. </li>
<li>
At the beginning of <span class="inlinecode">main</span> you need to add the line: <div class="fragment"><div class="line">Debug(NAMESPACE_DEBUG::init());</div></div><!-- fragment --> This calls a function provided by <span class="tt">cwds</span> that reads your <span class="tt">~/.libcwdrc</span> file turning on debug output for the specified debug channels. </li>
</ol>
<p>To enable debug output of <span class="projectname">AIStatefulTask</span> you should turn on the debug channel <span class="inlinecode">statefultask</span>. You could add, below the previous one, the line  <span class="inlinecode">Debug(if (!dc::statefultask.is_on()) dc::statefultask.on());</span> but prefered is to simply turn on and off debug channels in your <span class="tt">~/.libcwdrc</span>. Mine looks like this:</p>
<p> <div class="fragment libcwdrc">silent = on
channels_default = off
channels_on = warning,notice,system,statefultask,threadpool
#channels_on = action,semaphore,semaphorestats
gdb = /usr/bin/gdb $GDBCOMMANDFILE
xterm = konsole --nofork --workdir "$PWD" --geometry 165x24-0-0 -e %s
</div></p>
<p><a class="anchor" id="helloworld_example"></a></p>
<p> <span class="projectname">AIStatefulTask</span> requires multiple initializations at the beginning of <span class="inlinecode">main</span>. The reason for that is to make it easier to customize the initialization; although each have sensible defaults you can pass (different) arguments to fine tune the initialization. See their respective documentation for the details. For now don't worry about this and just use the defaults.</p>
<p>The following objects should be created at the start of <span class="inlinecode">main</span>:</p>
<ul>
<li>
An AIMemoryPagePool object. Causes a singleton object to be initialized that can only be used after this AIMemoryPagePool object is created. You must create it at the start of <span class="inlinecode">main</span> however and not as a global variable, so that upon leaving <span class="inlinecode">main</span> the singleton is destructed and allocated memory is cleanly deallocated. This is a general approach of the library, and should be of your code that uses the library: do not use the library from anything that can be executed before or after <span class="inlinecode">main</span>. </li>
<li>
An AIThreadPool object. Even though the thread pool has its own separate git submodule, it is the work horse of <span class="projectname">AIStatefulTask</span>. Like with AIMemoryPagePool, creating an AIThreadPool object at the start of <span class="inlinecode">main</span> causes a singleton object to be initialized that can only be used while this object exists. Do not use AIThreadPool::instance() before or after <span class="inlinecode">main</span>. </li>
<li>
One or more AIThreadPool::PriorityQueue objects, refered to by AIQueueHandle`s, to be used as default handler for your tasks. But even if you don't need a handler, you must created at least one queue. </li>
<li>
Create zero or more <a class="el" href="classAIEngine.html">AIEngine</a> objects and use those as default handler for your tasks; and have a main loop calling <span class="inlinecode">mainloop();</span> on each of those engines on a regular basis; for example as part of the 'idle' cycle of the main loop of <a href="https://www.gtkmm.org/en/documentation.html">gtkmm/glibmm</a>. </li>
</ul>
<p>See the <a href="https://github.com/CarloWood/ai-statefultask-testsuite/blob/master/src/helloworld.cxx"> <span class="tt">helloworld.cxx</span></a> file of the ai-statefultask-testsuite project for a working &quot;Hello World&quot; example. As another example have a look at the <a href="https://github.com/CarloWood/ai-statefultask-testsuite/blob/master/src/fibonacci.cxx"> <span class="tt">fibonacci.cxx</span></a> file in the same project.</p>
<p>If you are new to <span class="projectname">AIStatefulTask</span> then I urge you to first clone <a href="https://github.com/CarloWood/ai-statefultask-testsuite">ai-statefultask-testsuite</a> and get that working; as that will require you to have all the bits and pieces for building a project that uses <span class="projectname">AIStatefulTask</span> installed (hint: start with getting, compiling and installing <a href="https://github.com/CarloWood/libcwd">libcwd</a> and configure that for example with <span class="tt">--enable-maintainer-mode&nbsp;--enable-optimize&nbsp;--disable-alloc&nbsp;--disable-location&nbsp;--disable-nonthreading</span> because, respectivily, you got it with git, but you're not debugging libcwd itself, you don't need memory allocation debugging (slow), or printing source_file:line_number locations, and we only need the multithreaded version).</p>
<p>If you run into any problems configuring, compiling and/or installing libcwd, please watch <a href="https://www.youtube.com/watch?v=JbDlUIz7oek&amp;list=PLJzCXkV5Y8Ze6TtQWQSH6w5J-e-yIhgzP&amp;t=172">this tutorial</a>. If you run into any problems with setting up the environment related to the git submodules (cwm4 and cwds), please watch <a href="https://www.youtube.com/watch?v=53wWV0wqOMA&amp;list=PLJzCXkV5Y8Ze6TtQWQSH6w5J-e-yIhgzP&amp;index=2">this tutorial</a>.</p>
<p>The minimal program to print debug output looks something like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;sys.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;debug.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Debug(NAMESPACE_DEBUG::init());</div><div class="line">  Dout(dc::notice, <span class="stringliteral">&quot;Entering main()&quot;</span>);</div><div class="line"></div><div class="line">  <span class="comment">// See below.</span></div><div class="line"></div><div class="line">  Dout(dc::notice, <span class="stringliteral">&quot;Leaving main()&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>which requires linking with <span class="tt">libcwds_r</span>.</p>
<p>A minimal program that has a thread pool, looks something like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;sys.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;threadpool/AIThreadPool.h&quot;</span>    <span class="comment">// Includes debug.h.</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Debug(NAMESPACE_DEBUG::init());</div><div class="line">  Dout(dc::notice, <span class="stringliteral">&quot;Entering main()&quot;</span>);</div><div class="line"></div><div class="line">  AIThreadPool thread_pool;     <span class="comment">// AIThreadPool(int number_of_threads, int max_number_of_threads)</span></div><div class="line">  AIQueueHandle high_priority_queue =</div><div class="line">      thread_pool.new_queue(8); <span class="comment">// new_queue(int capacity, int reserved_threads)</span></div><div class="line">  <span class="comment">// Optionally add more queues for different priorities:</span></div><div class="line">  AIQueueHandle medium_priority_queue = thread_pool.new_queue(8);</div><div class="line">  AIQueueHandle low_priority_queue = thread_pool.new_queue(8);</div><div class="line"></div><div class="line">  <span class="comment">// See below.</span></div><div class="line"></div><div class="line">  Dout(dc::notice, <span class="stringliteral">&quot;Leaving main()&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>which requires, additionally, linking with <span class="tt">libthreadpool libthreadsafe libutils</span>.</p>
<p>A minimal program that has an event loop (for I/O), looks something like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;sys.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;evio/EventLoop.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;utils/debug_ostream_operators.h&quot;</span>      <span class="comment">// Needed to write error to Dout.</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Debug(NAMESPACE_DEBUG::init());</div><div class="line">  Dout(dc::notice, <span class="stringliteral">&quot;Entering main()&quot;</span>);</div><div class="line"></div><div class="line">  AIThreadPool thread_pool;</div><div class="line">  AIQueueHandle low_priority_queue = thread_pool.new_queue(8);</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    evio::EventLoop event_loop(low_priority_queue); </div><div class="line">    </div><div class="line">    <span class="comment">// See below.</span></div><div class="line"></div><div class="line">    <span class="comment">// Terminate application.</span></div><div class="line">    event_loop.join();</div><div class="line">  }</div><div class="line">  <span class="keywordflow">catch</span> (AIAlert::Error <span class="keyword">const</span>&amp; error)</div><div class="line">  {</div><div class="line">    Dout(dc::warning, error);</div><div class="line">  }</div><div class="line"></div><div class="line">  Dout(dc::notice, <span class="stringliteral">&quot;Leaving main()&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>which requires, additionally, linking with <span class="tt">libevio</span>.</p>
<p>When you actually use a task, so far we only used submodules other than <span class="tt">statefultask</span>, it is a good idea to also create the <span class="inlinecode">AIMemoryPagePool</span> object, just in case (although this is really only required when you use <a class="el" href="classAIStatefulTaskMutex.html">AIStatefulTaskMutex</a> (indirectly)).</p>
<p>Assume we have a task <span class="inlinecode">task::HelloWorld</span> and want to run that, after initialization. Then we can run this task in the thread pool:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;sys.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;helloworld-task/HelloWorld.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="DefaultMemoryPagePool_8h.html">statefultask/DefaultMemoryPagePool.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;threadpool/AIThreadPool.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;utils/AIAlert.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;utils/debug_ostream_operators.h&quot;</span>      <span class="comment">// Needed to write error to Dout.</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Debug(NAMESPACE_DEBUG::init());</div><div class="line">  Dout(dc::notice, <span class="stringliteral">&quot;Entering main()&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classstatefultask_1_1DefaultMemoryPagePool.html">AIMemoryPagePool</a> mpp;                 <span class="comment">// Create before thread_pool.</span></div><div class="line">  AIThreadPool thread_pool;</div><div class="line">  AIQueueHandle low_priority_queue = thread_pool.new_queue(8);</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    <span class="keyword">auto</span> <a class="code" href="namespacetask.html">task</a> = task::create&lt;task::HelloWorld&gt;();</div><div class="line">    <a class="code" href="namespacetask.html">task</a>-&gt;initialize(42);</div><div class="line">    <a class="code" href="namespacetask.html">task</a>-&gt;run(low_priority_queue);      <span class="comment">// Must have a non-immediate handler because it calls yield().</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">catch</span> (AIAlert::Error <span class="keyword">const</span>&amp; error)</div><div class="line">  {</div><div class="line">    Dout(dc::warning, error);</div><div class="line">  }</div><div class="line"></div><div class="line">  Dout(dc::notice, <span class="stringliteral">&quot;Leaving main()&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>which requires, additionally, linking with <span class="tt">libstatefultask.la</span> (and <span class="tt">libhelloworldtask.la</span>).</p>
<p>Note that <span class="inlinecode">AIMemoryPagePool</span> is created <em>before</em> <span class="inlinecode">AIThreadPool</span>. This is important because tasks can continue running until the thread pool is destructed, so <span class="inlinecode">mpp</span> must be destructed <em>after</em> <span class="inlinecode">thread_pool</span>!</p>
<p>Also note that the task is run by passing a handler. Try what happens when you don't pass anything and just call <span class="inlinecode">run()</span>.</p>
<p>It is also possible run a task in an <a class="el" href="classAIEngine.html">AIEngine</a>. An <a class="el" href="classAIEngine.html">AIEngine</a> requires a main loop somewhere to be run from, which we don't have in a small  <span class="tt">Hello World</span> type program, so we have to add one for demonstration purposes. I'm also adding the event loop back, pretending we're doing I/O.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;sys.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;helloworld-task/HelloWorld.h&quot;</span>         <span class="comment">// task::HelloWorld (and task::create).</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="DefaultMemoryPagePool_8h.html">statefultask/DefaultMemoryPagePool.h</a>&quot;</span> <span class="comment">// AIMemoryPagePool.</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="AIEngine_8h.html">statefultask/AIEngine.h</a>&quot;</span>              <span class="comment">// AIEngine, AIThreadPool, AIQueueHandle.</span></div><div class="line"><span class="preprocessor">#include &quot;evio/EventLoop.h&quot;</span>                     <span class="comment">// evio::EventLoop (and AIAlert).</span></div><div class="line"><span class="preprocessor">#include &quot;utils/debug_ostream_operators.h&quot;</span>      <span class="comment">// Needed to write AIAlert::Error to Dout.</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Debug(NAMESPACE_DEBUG::init());               <span class="comment">// Initialize cwds and libcwd.</span></div><div class="line">  Dout(dc::notice, <span class="stringliteral">&quot;Entering main()&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classstatefultask_1_1DefaultMemoryPagePool.html">AIMemoryPagePool</a> mpp;                 <span class="comment">// Create first. Takes optional initialization.</span></div><div class="line">  AIThreadPool thread_pool;             <span class="comment">// Required. Takes optional initialization).</span></div><div class="line">  AIQueueHandle low_priority_queue =    <span class="comment">// At least one queue is required.</span></div><div class="line">      thread_pool.new_queue(8);</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    evio::EventLoop event_loop(low_priority_queue);     <span class="comment">// Needed when doing I/O.</span></div><div class="line">    <a class="code" href="classAIEngine.html">AIEngine</a> engine(<span class="stringliteral">&quot;main engine&quot;</span>, 2.0);                <span class="comment">// To run tasks from a known point</span></div><div class="line">                                                        <span class="comment">// in some (libraries) main loop.</span></div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> test_finished = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// All tasks are created (somewhere, often as member variable of an object).</span></div><div class="line">    <span class="keyword">auto</span> <a class="code" href="namespacetask.html">task</a> = task::create&lt;task::HelloWorld&gt;();</div><div class="line">    <span class="comment">// Often initialized before (re)running them.</span></div><div class="line">    <a class="code" href="namespacetask.html">task</a>-&gt;initialize(42);</div><div class="line">    <span class="comment">// And finally started by calling one of the run() member functions.</span></div><div class="line">    <a class="code" href="namespacetask.html">task</a>-&gt;run(&amp;engine, [&amp;](<span class="keywordtype">bool</span> CWDEBUG_ONLY(success)){</div><div class="line">        test_finished = <span class="keyword">true</span>;</div><div class="line">        Dout(dc::notice, <span class="stringliteral">&quot;Inside the call-back (&quot;</span> &lt;&lt;</div><div class="line">            (success ? <span class="stringliteral">&quot;success&quot;</span> : <span class="stringliteral">&quot;failure&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;).&quot;</span>);</div><div class="line">    });</div><div class="line">    <span class="comment">// Destruction of a task is automatic; once both, the &#39;task&#39; variable</span></div><div class="line">    <span class="comment">// is destructed and it finished running.</span></div><div class="line"></div><div class="line">    <span class="comment">// Add an artificial main loop here.</span></div><div class="line">    <span class="keywordflow">while</span> (!test_finished)</div><div class="line">    {</div><div class="line">      <span class="comment">// Run tasks from a known point some libraries main loop.</span></div><div class="line">      <span class="comment">// This &#39;synchronizes&#39; the task with the code of that particular library.</span></div><div class="line">      engine.mainloop();</div><div class="line">      <span class="comment">// Pretend we&#39;re doing something else too.</span></div><div class="line">      std::this_thread::sleep_for(std::chrono::milliseconds(10));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Application termination (this signals clean termination, as opposed to</span></div><div class="line">    <span class="comment">// leaving this scope by thrown exception).</span></div><div class="line">    <span class="comment">// It influences how the destructor of evio::EventLoop behaves.</span></div><div class="line">    event_loop.join();</div><div class="line">  }</div><div class="line">  <span class="keywordflow">catch</span> (AIAlert::Error <span class="keyword">const</span>&amp; error)</div><div class="line">  {</div><div class="line">    <span class="comment">// This is only debug output. Normally you&#39;d want to handle errors of course.</span></div><div class="line">    Dout(dc::warning, error);</div><div class="line">  }</div><div class="line"></div><div class="line">  Dout(dc::notice, <span class="stringliteral">&quot;Leaving main()&quot;</span>);</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer" style="text-align:left; margin-left: 10px; font-size: 90%;">
Revised Tue Dec 3 2019
<span style="float:right;">Copyright &copy; Carlo Wood, 2018-2019.</span>
</address>
</body>
</html>
