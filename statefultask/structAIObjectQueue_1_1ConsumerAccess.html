<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="Author" content="Carlo Wood">
<meta name="description" content="ai-statefultask">
<title>ai-statefultask version 2cfbfa5 documentation</title>
<link rel="shortcut icon" href="images/favicon.ico">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="main.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top">
<div id="titlearea">
<table>
 <tbody>
  <tr>
  <td style="width: 128px"><img src="images/aistatefultask_arc.png"></td>
  <td>
    <p id="html_header1"><span id="name">AIStatefulTask</span> &dash; Asynchronous, Stateful Task Scheduler library.</p>
    <p id="html_header2">Threads-like task objects evolving through user-defined states.</p>
  </td>
  </tr>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="classAIObjectQueue.html">AIObjectQueue</a></li><li class="navelem"><a class="el" href="structAIObjectQueue_1_1ConsumerAccess.html">ConsumerAccess</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structAIObjectQueue_1_1ConsumerAccess-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AIObjectQueue&lt; T &gt;::ConsumerAccess Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct AIObjectQueue&lt; T &gt;::ConsumerAccess</h3>

<p>The return type of <a class="el" href="classAIObjectQueue.html#a6908f63adcc53ccaed42db70ffd3249d" title="Obtain exclusive consumer access to the buffer. ">consumer_access()</a>. </p>
</div>
<p><code>#include &lt;<a class="el" href="AIObjectQueue_8h_source.html">AIObjectQueue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a94c5dce5e86d9c61a3f2f3cb5291295a"><td class="memItemLeft" align="right" valign="top"><a id="a94c5dce5e86d9c61a3f2f3cb5291295a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIObjectQueue_1_1ConsumerAccess.html#a94c5dce5e86d9c61a3f2f3cb5291295a">ConsumerAccess</a> (<a class="el" href="classAIObjectQueue.html">AIObjectQueue</a>&lt; T &gt; *buffer)</td></tr>
<tr class="memdesc:a94c5dce5e86d9c61a3f2f3cb5291295a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a94c5dce5e86d9c61a3f2f3cb5291295a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b4d18c7e70dac76c5ddaf1f18f4aed"><td class="memItemLeft" align="right" valign="top"><a id="a66b4d18c7e70dac76c5ddaf1f18f4aed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIObjectQueue_1_1ConsumerAccess.html#a66b4d18c7e70dac76c5ddaf1f18f4aed">~ConsumerAccess</a> ()</td></tr>
<tr class="memdesc:a66b4d18c7e70dac76c5ddaf1f18f4aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a66b4d18c7e70dac76c5ddaf1f18f4aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82937eb07579697a478e087a6af3aa8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIObjectQueue_1_1ConsumerAccess.html#aa82937eb07579697a478e087a6af3aa8">length</a> () const</td></tr>
<tr class="memdesc:aa82937eb07579697a478e087a6af3aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current length of the buffer.  <a href="#aa82937eb07579697a478e087a6af3aa8">More...</a><br /></td></tr>
<tr class="separator:aa82937eb07579697a478e087a6af3aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81af999825ca2b7d90cf0624ae62d7cb"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIObjectQueue_1_1ConsumerAccess.html#a81af999825ca2b7d90cf0624ae62d7cb">move_out</a> ()</td></tr>
<tr class="memdesc:a81af999825ca2b7d90cf0624ae62d7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an object from the buffer by means of <code>std::move</code>.  <a href="#a81af999825ca2b7d90cf0624ae62d7cb">More...</a><br /></td></tr>
<tr class="separator:a81af999825ca2b7d90cf0624ae62d7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675f59db487e68540b60a721becf1969"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIObjectQueue_1_1ConsumerAccess.html#a675f59db487e68540b60a721becf1969">clear</a> ()</td></tr>
<tr class="memdesc:a675f59db487e68540b60a721becf1969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the buffer by putting the tail where the head is.  <a href="#a675f59db487e68540b60a721becf1969">More...</a><br /></td></tr>
<tr class="separator:a675f59db487e68540b60a721becf1969"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a675f59db487e68540b60a721becf1969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675f59db487e68540b60a721becf1969">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAIObjectQueue.html">AIObjectQueue</a>&lt; T &gt;::ConsumerAccess::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the buffer by putting the tail where the head is. </p>
<p>Artificially stop all consumers from reading this buffer by faking that it is now empty. This should probably only be used as part of a clean up. The objects that weren't read are not destroyed; they will be destroyed when the buffer is destroyed, or, if one continues to use the buffer, they would be partially destroyed when another object is moved over them (the destructor is always only called once the buffer is destructed or <a class="el" href="classAIObjectQueue.html#a83d45c06e1d9653cab5f26b9ccdb8d13" title="Change the capacity of the buffer. ">reallocate()</a> is called). </p>

</div>
</div>
<a id="aa82937eb07579697a478e087a6af3aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82937eb07579697a478e087a6af3aa8">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAIObjectQueue.html">AIObjectQueue</a>&lt; T &gt;::ConsumerAccess::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current length of the buffer. </p>
<p>This is the number of objects available for reading. If the returned value equals zero than the buffer is empty and one should not call move_out. </p>

</div>
</div>
<a id="a81af999825ca2b7d90cf0624ae62d7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81af999825ca2b7d90cf0624ae62d7cb">&#9670;&nbsp;</a></span>move_out()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classAIObjectQueue.html">AIObjectQueue</a>&lt; T &gt;::ConsumerAccess::move_out </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an object from the buffer by means of <code>std::move</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The read object. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>statefultask/<a class="el" href="AIObjectQueue_8h_source.html">AIObjectQueue.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer" style="text-align:left;">
<span style="margin-left: 10px; font-size: 90%;">Copyright &copy; 2018 Carlo Wood.&nbsp; All rights reserved.</span>
<span style="float:right;">
<small>Generated by&#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></span>
</address>
</body>
</html>
