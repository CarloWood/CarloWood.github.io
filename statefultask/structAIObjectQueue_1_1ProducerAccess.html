<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="Author" content="Carlo Wood">
<meta name="description" content="ai-statefultask">
<title>ai-statefultask version 2cfbfa5 documentation</title>
<link rel="shortcut icon" href="images/favicon.ico">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="main.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top">
<div id="titlearea">
<table>
 <tbody>
  <tr>
  <td style="width: 128px"><img src="images/aistatefultask_arc.png"></td>
  <td>
    <p id="html_header1"><span id="name">AIStatefulTask</span> &dash; Asynchronous, Stateful Task Scheduler library.</p>
    <p id="html_header2">Threads-like task objects evolving through user-defined states.</p>
  </td>
  </tr>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="classAIObjectQueue.html">AIObjectQueue</a></li><li class="navelem"><a class="el" href="structAIObjectQueue_1_1ProducerAccess.html">ProducerAccess</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structAIObjectQueue_1_1ProducerAccess-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AIObjectQueue&lt; T &gt;::ProducerAccess Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct AIObjectQueue&lt; T &gt;::ProducerAccess</h3>

<p>The return type of <a class="el" href="classAIObjectQueue.html#a69cdab4a806e019d824bd43f099c1375" title="Obtain exclusive producer access to the buffer. ">producer_access()</a>. </p>
</div>
<p><code>#include &lt;<a class="el" href="AIObjectQueue_8h_source.html">AIObjectQueue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a023ccc9ec2e27b6aa6bc2dd8ff85f559"><td class="memItemLeft" align="right" valign="top"><a id="a023ccc9ec2e27b6aa6bc2dd8ff85f559"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIObjectQueue_1_1ProducerAccess.html#a023ccc9ec2e27b6aa6bc2dd8ff85f559">ProducerAccess</a> (<a class="el" href="classAIObjectQueue.html">AIObjectQueue</a>&lt; T &gt; *buffer)</td></tr>
<tr class="memdesc:a023ccc9ec2e27b6aa6bc2dd8ff85f559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a023ccc9ec2e27b6aa6bc2dd8ff85f559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677f82e02615ad665dede034816b8282"><td class="memItemLeft" align="right" valign="top"><a id="a677f82e02615ad665dede034816b8282"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIObjectQueue_1_1ProducerAccess.html#a677f82e02615ad665dede034816b8282">~ProducerAccess</a> ()</td></tr>
<tr class="memdesc:a677f82e02615ad665dede034816b8282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a677f82e02615ad665dede034816b8282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8233a231416f6d0d17c876a0f714ddf8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIObjectQueue_1_1ProducerAccess.html#a8233a231416f6d0d17c876a0f714ddf8">length</a> () const</td></tr>
<tr class="memdesc:a8233a231416f6d0d17c876a0f714ddf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current length of the buffer.  <a href="#a8233a231416f6d0d17c876a0f714ddf8">More...</a><br /></td></tr>
<tr class="separator:a8233a231416f6d0d17c876a0f714ddf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fcca6aff55c06d8ab2d8eef211a93a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIObjectQueue_1_1ProducerAccess.html#a99fcca6aff55c06d8ab2d8eef211a93a">move_in</a> (T &amp;&amp;object)</td></tr>
<tr class="memdesc:a99fcca6aff55c06d8ab2d8eef211a93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an object into the buffer by means of <code>std::move</code>.  <a href="#a99fcca6aff55c06d8ab2d8eef211a93a">More...</a><br /></td></tr>
<tr class="separator:a99fcca6aff55c06d8ab2d8eef211a93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc2c4d2fe9ad807e2d9f759acc856df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIObjectQueue_1_1ProducerAccess.html#a8fc2c4d2fe9ad807e2d9f759acc856df">clear</a> ()</td></tr>
<tr class="memdesc:a8fc2c4d2fe9ad807e2d9f759acc856df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the buffer by putting the head where the tail is.  <a href="#a8fc2c4d2fe9ad807e2d9f759acc856df">More...</a><br /></td></tr>
<tr class="separator:a8fc2c4d2fe9ad807e2d9f759acc856df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8fc2c4d2fe9ad807e2d9f759acc856df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc2c4d2fe9ad807e2d9f759acc856df">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAIObjectQueue.html">AIObjectQueue</a>&lt; T &gt;::ProducerAccess::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the buffer by putting the head where the tail is. </p>
<p>Artificially stop all consumers from reading this buffer by faking that it is now empty. This should probably only be used as part of a clean up. The objects that weren't read are not destroyed; they will be destroyed when the buffer is destroyed, or, if one continues to use the buffer, they would be partially destroyed when another object is moved over them (the destructor is always only called once the buffer is destructed or <a class="el" href="classAIObjectQueue.html#a83d45c06e1d9653cab5f26b9ccdb8d13" title="Change the capacity of the buffer. ">reallocate()</a> is called). </p>

</div>
</div>
<a id="a8233a231416f6d0d17c876a0f714ddf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8233a231416f6d0d17c876a0f714ddf8">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAIObjectQueue.html">AIObjectQueue</a>&lt; T &gt;::ProducerAccess::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current length of the buffer. </p>
<p>This is the number of objects stored in the buffer. If the returned value equals the capacity of the buffer than the buffer is full and one should not call move_in. </p>

</div>
</div>
<a id="a99fcca6aff55c06d8ab2d8eef211a93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fcca6aff55c06d8ab2d8eef211a93a">&#9670;&nbsp;</a></span>move_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAIObjectQueue.html">AIObjectQueue</a>&lt; T &gt;::ProducerAccess::move_in </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write an object into the buffer by means of <code>std::move</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The object to move into the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>statefultask/<a class="el" href="AIObjectQueue_8h_source.html">AIObjectQueue.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer" style="text-align:left;">
<span style="margin-left: 10px; font-size: 90%;">Copyright &copy; 2018 Carlo Wood.&nbsp; All rights reserved.</span>
<span style="float:right;">
<small>Generated by&#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></span>
</address>
</body>
</html>
