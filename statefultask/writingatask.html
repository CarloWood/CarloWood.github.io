<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="Author" content="Carlo Wood">
<meta name="description" content="ai-statefultask">
<title>ai-statefultask version 2cfbfa5 documentation</title>
<link rel="shortcut icon" href="images/favicon.ico">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="main.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top">
<div id="titlearea">
<table>
 <tbody>
  <tr>
  <td style="width: 128px"><img src="images/aistatefultask_arc.png"></td>
  <td>
    <p id="html_header1"><span id="name">AIStatefulTask</span> &dash; Asynchronous, Stateful Task Scheduler library.</p>
    <p id="html_header2">Threads-like task objects evolving through user-defined states.</p>
  </td>
  </tr>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="usage.html">Usage</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Writing a task </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A typical Task will look like,</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="AIStatefulTask_8h.html">statefultask/AIStatefulTask.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classAIStatefulTask.html">AIStatefulTask</a></div><div class="line">{</div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">using</span> direct_base_type = <a class="code" href="classAIStatefulTask.html#ad63774288f04f401632549e944ee5183">AIStatefulTask</a>;      <span class="comment">// The immediate base class of this task.</span></div><div class="line"></div><div class="line">  <span class="comment">// The different states of the task.</span></div><div class="line">  <span class="keyword">enum</span> my_task_state_type {</div><div class="line">    MyTask_start = direct_base_type::state_end, <span class="comment">// The first state.</span></div><div class="line">    ...a list of all states...</div><div class="line">    MyTask_done                                 <span class="comment">// The last state.</span></div><div class="line">  };</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">static</span> state_type constexpr state_end = MyTask_done + 1;  <span class="comment">// The last state plus one.</span></div><div class="line"></div><div class="line"> ...</div><div class="line"></div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  ~MyTask() <span class="keyword">override</span>;</div><div class="line">  <span class="keywordtype">char</span> <span class="keyword">const</span>* <a class="code" href="classAIStatefulTask.html#abf2da57033c2f1d05a7f6b59fe392d67">state_str_impl</a>(state_type run_state) <span class="keyword">const override</span>;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classAIStatefulTask.html#a57233a1b95a6fdbef04c4cab3fd890ae">multiplex_impl</a>(state_type run_state) <span class="keyword">override</span>;</div><div class="line">  <span class="comment">// Optional:</span></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classAIStatefulTask.html#afe86c9acff86165977302965e5401e20">initialize_impl</a>() <span class="keyword">override</span>;  <span class="comment">// Default starts with first state.</span></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classAIStatefulTask.html#a61a6f86a6e413cf7391b756b0038d4f0">abort_impl</a>() <span class="keyword">override</span>;       <span class="comment">// Default does nothing.</span></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classAIStatefulTask.html#a872025f08ce55e54810495690da7b337">finish_impl</a>() <span class="keyword">override</span>;      <span class="comment">// Default does nothing.</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">char</span> <span class="keyword">const</span>* MyTask::state_str_impl(state_type run_state)</div><div class="line">{</div><div class="line">  <span class="keywordflow">switch</span> (run_state)</div><div class="line">  {</div><div class="line">    <span class="comment">// A complete listing of my_task_state_type.</span></div><div class="line">    AI_CASE_RETURN(MyTask_start);</div><div class="line">    ...a list of all states...</div><div class="line">    AI_CASE_RETURN(MyTask_done);</div><div class="line">  }</div><div class="line">  ASSERT(<span class="keyword">false</span>);</div><div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;UNKNOWN STATE&quot;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> MyTask::multiplex_impl(state_type run_state)</div><div class="line">{</div><div class="line">  <span class="keywordflow">switch</span> (run_state)</div><div class="line">  {</div><div class="line">    <span class="comment">// A complete listing of my_task_state_type.</span></div><div class="line">    <span class="keywordflow">case</span> MyTask_start:</div><div class="line">      <span class="comment">// Handle state.</span></div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    ...a list of all states...</div><div class="line">    <span class="keywordflow">case</span> MyTask_done:</div><div class="line">      <a class="code" href="group__group__protected.html#gaf7642911a8012284ec7aa5a9a700b06b">finish</a>();</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>Then in <span class="inlinecode">multiplex_impl</span> each state need to be implemented. Here are a few examples.</p>
<p>It is simply the last call to <span class="inlinecode">set_state</span> that is used to determine what state to run the next invocation of <span class="inlinecode">multiplex_impl</span>. Also, as might be intuitively correct, it is not really necessary to return from <span class="inlinecode">multiplex_impl</span> to change state; you are allowed to simply fall-through to the next state (even without calling <span class="inlinecode">set_state</span>).</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> MyTask_state10:</div><div class="line">  set_state(MyTask_state11);      <span class="comment">// By default run state11 next.</span></div><div class="line">  <span class="keywordflow">if</span> (something)</div><div class="line">  {</div><div class="line">    set_state(MyTask_state12);    <span class="comment">// Continue with state12.</span></div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (foobar)</div><div class="line">  {</div><div class="line">    <span class="comment">// Optional code here.</span></div><div class="line">    <span class="keywordflow">break</span>;                        <span class="comment">// Continue with state11.</span></div><div class="line">  }</div><div class="line">  <span class="comment">// Optional code here.</span></div><div class="line">  [[fallthrough]];                <span class="comment">// Continue with state11 without even</span></div><div class="line">                                  <span class="comment">// returning from multiplex_impl.</span></div><div class="line"><span class="keywordflow">case</span> MyTask_state11:</div><div class="line">  ...</div></div><!-- fragment --><p>If in the above code you'd have used a <span class="inlinecode">break</span> instead of falling through, then the program would have almost acted in the same way: upon return from <span class="inlinecode">multiplex_impl</span> the engine sees that the task is still running and will therefore immediately reenter <span class="inlinecode">multiplex_impl</span>.</p>
<p>In other words, doing a <span class="inlinecode">break</span> is <em>not</em> the same as a <span class="inlinecode">yield</span>.</p>
<p>Even if a task runs in an engine with a max_duration, and it would go over that time limit then doing a <span class="inlinecode">break</span> still doesn't do anything but immediately reentering <span class="inlinecode">multiplex_impl</span> to continue with the next state. The test that looks if the engine did run for too long only is done once we actually return to the <span class="inlinecode">mainloop()</span> of the engine which only happens when either <span class="inlinecode">wait</span> or <span class="inlinecode">yield</span> is called.</p>
<p>Hence, if you want this time check to take place, or if you simply want other tasks in the same engine to get a chance to run too while this task is working, call <a class="el" href="group__group__yield.html">yield*()</a>. For example,</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> MyTask_state10:</div><div class="line">  set_state(MyTask_state11);      <span class="comment">// By default run state11 next.</span></div><div class="line">  <span class="keywordflow">if</span> (something)</div><div class="line">  {</div><div class="line">    set_state(MyTask_state12);    <span class="comment">// Continue with state12.</span></div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (foobar)</div><div class="line">    do_computation_A();</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    do_computation_B();</div><div class="line">  yield();                      <span class="comment">// Make sure other tasks and/or the</span></div><div class="line">                                <span class="comment">// mainloop get CPU time too.</span></div><div class="line">  <span class="keywordflow">break</span>;                        <span class="comment">// Continue with state11.</span></div></div><!-- fragment --><p>Finally there are a couple of typical ways to go idle while waiting for some event to happen. Under the hood all of those use the same mechanism: you call <span class="inlinecode">wait(condition)</span> and the task goes idle until something else calls <span class="inlinecode">task.signal(condition)</span>.</p>
<p>Here <span class="inlinecode">condition</span> is simply a <span class="inlinecode">uint32_t</span> bit mask. Normally you will just use <code>1</code>. In order not to wake up when some old  <span class="inlinecode">signal</span> happens for a condition that you are no longer waiting for, each task has up to 32 different possible values. If you were waiting for mask <code>1</code> and it didn't come or might still be coming (again) but now you want to wait for something else, then simply wait for condition <code>2</code>, <code>4</code> or <code>8</code> etc so that you will automatically ignore an (old and lagging behind) signal on <code>1</code>. It is possible to wait and/or signal multiple conditions at the same time however: a call to <span class="inlinecode">wait(condition1)</span> is woken up by a call to <span class="inlinecode">signal(condition2)</span> when <span class="inlinecode">condition1 &amp; condition2</span> is non-zero.</p>
<p>For example,</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> some_event()</div><div class="line">{</div><div class="line">  <a class="code" href="namespacetask.html">task</a>.signal(1);</div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line">  <span class="keywordflow">case</span> MyTask_state20:</div><div class="line">    set_state(MyTask_state21);  <span class="comment">// Continue with state21.</span></div><div class="line">    wait(1);                    <span class="comment">// Go idle until some_event() is called.</span></div><div class="line">    <span class="keywordflow">break</span>;</div></div><!-- fragment --><p>Often you want to wait for a real condition however, for example <span class="inlinecode">x > y</span>, and it is not really possible to call <span class="inlinecode">signal</span> when that happens and then still be sure that this condition is still true once the task starts running again.</p>
<p>In general, you will only have events that when they happen make it possible, preferably likely that the condition that you are waiting for is true.</p>
<p>Code that needs this will typically look like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> some_event()</div><div class="line">{</div><div class="line">  ++x;  <span class="comment">// Now x might have become larger than y.</span></div><div class="line">  <a class="code" href="namespacetask.html">task</a>.signal(1);</div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line">  <span class="keywordflow">case</span> MyTask_state20:</div><div class="line">    wait_until([&amp;](){ <span class="keywordflow">return</span> x &gt; y;}, 1, MyTask_state21);</div><div class="line">        <span class="comment">// Continue with state21 as soon as x &gt; y.</span></div><div class="line">    <span class="keywordflow">break</span>;</div></div><!-- fragment --><p>Simply running another task and waiting until it is finished:</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> MyTask_state30:</div><div class="line">  m_task = <span class="keyword">new</span> MyChildTask;</div><div class="line">  m_task-&gt;run(handler, <span class="keyword">this</span>, 2);  <span class="comment">// 2 is just the condition bit to be used.</span></div><div class="line">  set_state(MyTask_state31);      <span class="comment">// Continue with state31 once m_task has finished.</span></div><div class="line">  <span class="keywordflow">break</span>;</div></div><!-- fragment --><p>Running some computational extensive function in another thread (see <a class="el" href="classAIPackagedTask_3_01R_07Args_8_8_8_08_4.html">AIPackagedTask</a>):</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyTask : <a class="code" href="classAIStatefulTask.html">AIStatefulTask</a></div><div class="line">{</div><div class="line">  AIPackagedTask&lt;int(double, double)&gt; m_calculate;</div><div class="line">  <span class="keyword">static</span> condition_type constexpr calculate_condition = 4;</div><div class="line">      <span class="comment">// The condition bit to be used.</span></div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  MyTask(<span class="keywordtype">int</span> calculate_handle) :</div><div class="line">      m_calculate(this, calculate_condition, &amp;func, calculate_handle) { }</div><div class="line">        <span class="comment">// m_calculate will call func(double, double).</span></div><div class="line">...</div><div class="line">};</div><div class="line"></div><div class="line">...</div><div class="line">  <span class="keywordflow">case</span> MyTask_state20:</div><div class="line">    m_calculate(3.0, 4.1);              <span class="comment">// Copy parameters to m_calculate.</span></div><div class="line">    <a class="code" href="group__group__protected.html#ga160831e7b091af4095a9f60e33834328">set_state</a>(MyTask_dispatch);</div><div class="line">  <span class="keywordflow">case</span> MyTask_dispatch:</div><div class="line">    <span class="keywordflow">if</span> (!m_calculate.dispatch())        <span class="comment">// Put m_calculate in the queue.</span></div><div class="line">    {</div><div class="line">      yield_frames(1);                  <span class="comment">// Yield because the queue was full.</span></div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    <a class="code" href="group__group__protected.html#ga160831e7b091af4095a9f60e33834328">set_state</a>(MyTask_state21);          <span class="comment">// Continue with state21 once the</span></div><div class="line">    <span class="keywordflow">break</span>;                              <span class="comment">//   function finished executing.</span></div><div class="line">  <span class="keywordflow">case</span> MyTask_state21:</div><div class="line">  {</div><div class="line">    <span class="keywordtype">int</span> result = m_calculate.get();     <span class="comment">// Get the result.</span></div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer" style="text-align:left; margin-left: 10px; font-size: 90%;">
Revised Mon Nov 25 2019
<span style="float:right;">Copyright &copy; Carlo Wood, 2018-2019.</span>
</address>
</body>
</html>
